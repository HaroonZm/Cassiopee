Voici un énoncé de problème :

Score :
1000
points
Problem Statement
There are
N
non-negative integers written on a blackboard. The
i
-th integer is
A_i
.
Takahashi can perform the following two kinds of operations any number of times in any order:
Select one integer written on the board (let this integer be
X
). Write
2X
on the board, without erasing the selected integer.
Select two integers, possibly the same, written on the board (let these integers be
X
and
Y
). Write
X
XOR
Y
(XOR stands for bitwise xor) on the blackboard, without erasing the selected integers.
How many different integers not exceeding
X
can be written on the blackboard? We will also count the integers that are initially written on the board.
Since the answer can be extremely large, find the count modulo
998244353
.
Constraints
1 \leq N \leq 6
1 \leq X < 2^{4000}
1 \leq A_i < 2^{4000}(1\leq i\leq N)
All input values are integers.
X
and
A_i(1\leq i\leq N)
are given in binary notation, with the most significant digit in each of them being
1
.
Input
Input is given from Standard Input in the following format:
N
X
A_1
:
A_N
Output
Print the number of different integers not exceeding
X
that can be written on the blackboard.
Sample Input 1
3 111
1111
10111
10010
Sample Output 1
4
Initially,
15
,
23
and
18
are written on the blackboard. Among the integers not exceeding
7
, four integers,
0
,
3
,
5
and
6
, can be written.
For example,
6
can be written as follows:
Double
15
to write
30
.
Take XOR of
30
and
18
to write
12
.
Double
12
to write
24
.
Take XOR of
30
and
24
to write
6
.
Sample Input 2
4 100100
1011
1110
110101
1010110
Sample Output 2
37
Sample Input 3
4 111001100101001
10111110
1001000110
100000101
11110000011
Sample Output 3
1843
Sample Input 4
1 111111111111111111111111111111111111111111111111111111111111111
1
Sample Output 4
466025955
Be sure to find the count modulo
998244353
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import random

mod=998244353
N,X=input().split()
N=int(N)
A=[]
for i in range(N):
    A.append(int(input(),2))
A.sort()

a=A[-1]
M=max(len(X)-1,a.bit_length()-1)
data=[0]*(M+1)
n=a.bit_length()-1
for i in range(M-n,-1,-1):
    data[i+n]=a<<i

low=n
for i in range(0,N-1):
    a=A[i]
    flag=True
    while flag:
        n=a.bit_length()
        for j in range(n-1,low-1,-1):
            a=min(a,a^data[j])
        if a!=0:
            data[a.bit_length()-1]=a
            id=a.bit_length()-1
            low=id
            while data[id+1]==0:
                data[id+1]=min((data[id]<<1)^a,(data[id]<<1))
                id+=1
            else:
                a=data[id]<<1
        else:
            break

data2=[0]*(M+1)
for i in range(M+1):
    data2[i]=(data[i]!=0)

for i in range(1,M+1):
    data2[i]+=data2[i-1]

data2=[0]+data2

#print(data)
#print(data2)

x=0
ans=0
n=len(X)-1
for i in range(len(X)):
    if X[i]=="1":
        if x>>(n-i)&1==1:
            if data[n-i]:
                ans+=pow(2,data2[n-i],mod)
                ans%=mod
        else:
            ans+=pow(2,data2[n-i],mod)
            ans%=mod
            if data[n-i]:
                x=x^data[n-i]
            else:
                break
    else:
        if x>>(n-i)&1==1:
            if data[n-i]:
                x=x^data[n-i]
            else:
                break
        else:
            continue
else:
    ans+=1
    ans%=mod
print(ans)
```