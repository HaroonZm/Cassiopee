En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from Queue import Queue
mvL=((-1, 0), (-1, 1), (-1, 2), (-1, -1), (-1, -2), (-2, 0), (-2, 1), (-2, -1), (-3, 0))
mvR=((1, 0), (1, 1), (1, 2), (1, -1), (1, -2), (2, 0), (2, 1), (2, -1), (3, 0))
mv=(mvL,mvR)
while True:
    w,h=map(int,raw_input().split())
    if w==h==0:break
    INF=1000
    LEFT,RIGHT=0,1
    S=[raw_input().split() for i in range(h)]
    D=[[[INF,INF] for j in range(w)] for i in range(h)]
    Q=Queue()
    posT=[]
    for i in range(h):
        for j in range(w):
            if S[i][j]=="S":
                Q.put((j,i,LEFT))
                Q.put((j,i,RIGHT))
                D[i][j][LEFT]=D[i][j][RIGHT]=0
            elif S[i][j]=="T":
                posT.append((j,i))
    while not Q.empty():
        x,y,foot=Q.get()
        if foot==RIGHT:
            for dx,dy in mv[LEFT]:
                mx=x+dx
                my=y+dy
                if 0<=mx<w and 0<=my<h and S[my][mx]!="X" and S[my][mx]!="S":
                    if S[my][mx]=="T":
                        cost=D[y][x][RIGHT]
                    else:
                        cost=int(S[my][mx])+D[y][x][RIGHT]
                    if D[my][mx][LEFT]>cost:
                        D[my][mx][LEFT]=cost
                        Q.put((mx,my,LEFT))
        elif foot==LEFT:
            for dx,dy in mv[RIGHT]:
                mx=x+dx
                my=y+dy
                if 0<=mx<w and 0<=my<h and S[my][mx]!="X" and S[my][mx]!="S":
                    if S[my][mx]=="T":
                        cost=D[y][x][LEFT]
                    else:
                        cost=int(S[my][mx])+D[y][x][LEFT]
                    if D[my][mx][RIGHT]>cost:
                        D[my][mx][RIGHT]=cost
                        Q.put((mx,my,RIGHT))
    minCost=INF
    for x,y in posT:
        minCost=min(minCost,D[y][x][LEFT])
        minCost=min(minCost,D[y][x][RIGHT])
    print minCost if minCost!=INF else -1
```