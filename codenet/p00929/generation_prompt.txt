Voici un énoncé de problème :

Problem F:
There is No Alternative
ICPC (Isles of Coral Park City) consist of several beautiful islands.
The citizens requested construction of bridges between islands to resolve inconveniences of using boats between islands, and they demand that all the islands should be reachable from any other islands via one or more bridges.
The city mayor selected a number of pairs of islands, and ordered a building company to estimate the costs to build bridges between the pairs. With this estimate, the mayor has to decide the set of bridges to build, minimizing the total construction cost.
However, it is difficult for him to select the most cost-efficient set of bridges among those connecting all the islands. For example, three sets of bridges connect all the islands for the Sample Input 1. The bridges in each set are expressed by bold edges in Figure F.1.
Figure F.1. Three sets of bridges connecting all the islands for Sample Input 1
As the first step, he decided to build only those bridges which are contained in all the sets of bridges to connect all the islands and minimize the cost. We refer to such bridges as
no alternative bridges
. In Figure F.2, no alternative bridges are drawn as thick edges for the Sample Input 1, 2 and 3.
Figure F.2. No alternative bridges for Sample Input 1, 2 and 3
Write a program that advises the mayor which bridges are no alternative bridges for the given input.
Input
The input consists of a single test case.
$N$ $M$
$S_1$ $D_1$ $C_1$
.
.
.
$S_M$ $D_M$ $C_M$
The first line contains two positive integers $N$ and $M$. $N$ represents the number of islands and each island is identified by an integer 1 through $N$. $M$ represents the number of the pairs of islands between which a bridge may be built.
Each line of the next $M$ lines contains three integers $S_i$, $D_i$ and $C_i$ ($1 \leq i \leq M$) which represent that it will cost $C_i$ to build the bridge between islands $S_i$ and $D_i$. You may assume $3 \leq N \leq 500$, $N − 1 \leq M \leq min(50000, N(N − 1)/2)$, $1 \leq S_i < D_i \leq N$, and $1 \leq C_i \leq 10000$. No two bridges connect the same pair of two islands, that is, if $i \ne j$ and $S_i = S_j$, then $D_i \ne D_j$ . If all the candidate bridges are built, all the islands are reachable from any other islands via one or more bridges.
Output
Output two integers, which mean the number of no alternative bridges and the sum of their construction cost, separated by a space.
Sample Input 1
4 4
1 2 3
1 3 3
2 3 3
2 4 3
Sample Output 1
1 3
Sample Input 2
4 4
1 2 3
1 3 5
2 3 3
2 4 3
Sample Output 2
3 9
Sample Input 3
4 4
1 2 3
1 3 1
2 3 3
2 4 3
Sample Output 3
2 4
Sample Input 4
3 3
1 2 1
2 3 1
1 3 1
Sample Output 4
0 0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

class UnionFind:
    def __init__(self, size):
        self.table = [-1 for _ in range(size)]

    def find(self, x):
        if self.table[x] < 0:
            return x
        else:
            self.table[x] = self.find(self.table[x])
            return self.table[x]

    def union(self, x, y):
        s1 = self.find(x)
        s2 = self.find(y)
        if s1 != s2:
            if self.table[s1] <= self.table[s2]:
                self.table[s1] += self.table[s2]
                self.table[s2] = s1
            else:
                self.table[s2] += self.table[s1]
                self.table[s1] = s2
            return True
        return False

    def subsetall(self):
        a = []
        for i in range(len(self.table)):
            if self.table[i] < 0:
                a.append((i, -self.table[i]))
        return a

def main():
    rr = []

    def f(n,m):
        ee = [LI() + [_] for _ in range(m)]
        e = sorted(ee, key=lambda x: [x[2], x[3]])
        s = []
        ns = []
        uf = UnionFind(n+1)
        t = 0
        ttc = 0
        for a,b,c,i in e:
            if uf.union(a,b):
                s.append(i)
                t += c
                ttc += 1
            else:
                ns.append((a,b,c))

        r = 0
        rc = 0
        for si in s:
            tr = 0
            tc = 0
            uf = UnionFind(n+1)
            w = ee[si][2]
            for sj in s:
                if si == sj:
                    continue
                uf.union(ee[sj][0],ee[sj][1])
            sf = True
            for a,b,c in ns:
                if c == w and uf.union(a,b):
                    sf = False
                    break
            if sf:
                rc += 1
                r += w

        return '{} {}'.format(rc, r)

    while 1:
        n,m = LI()
        if n == 0:
            break
        rr.append(f(n,m))
        break

    return '\n'.join(map(str,rr))

print(main())
```