En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq

S = input()

# 数え上げ
chars = [[0, n] for n in range(256)]
for s in S:
	chars[ord(s)][0] += 1

# ハフマン木生成
# ：ノードの構造：[count, char, left=None, right=None]
# ：[1]のcharは、heapqでユニークキーとして機能するように追加した
counts = []
for char in chars:
	if not char[0]:
		continue
	heapq.heappush(counts, [char[0], char[1], None, None, char])

# ハフマン木編成
while 1 < len(counts):
	a, b = heapq.heappop(counts), heapq.heappop(counts)
	heapq.heappush(counts, [a[0] + b[0], -1, a, b])
root = heapq.heappop(counts)

# コード化(左：0、右：1)
codes = {};
def dfs(node, code):
	# 節の処理
	if node[1] < 0:
		dfs(node[2], code + "0")
		dfs(node[3], code + "1")
		return
	# 葉の処理
	codes[chr(node[1])] = code
dfs(root, "")

# 集計
count = 0
for s in S:
	count += len(codes[s])

# 1種類の場合のみ例外処理…いずれなんとか
if 1 == len(set(S)):
	print(len(S))
else:
	print(count)
```