En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque
N=int(input())
Sec=[]
Left1,Right1=[],[]
for i in range(N):
  l,r=map(int,input().split())
  Sec.append((l,r))
  Left1.append((l,i))
  Right1.append((r,i))
Left1.sort()
Right1.sort(reverse=True)
Left2=Left1[:]
Right2=Right1[:]
Used=[False]*N
pos=0
n=0
ans1=0
f_l,f_r=0,0
while Left1 or Right1:
  if n%2==0:
    if not Left1:
      n+=1
      continue
    l,i=Left1[-1]
    if Used[i]:
      Left1.pop()
      continue
    if pos<l:
      ans1+=l-pos
      pos=l
      Used[i]=True
      Left1.pop()
      f_l=0
    else:
      if f_l==1:
        Left1.pop()
        f_l=0
      else:
        f_l=1
    n+=1
  elif n%2==1:
    if not Right1:
      n+=1
      continue
    r,i=Right1[-1]
    if Used[i]:
      Right1.pop()
      continue
    if r<pos:
      ans1+=pos-r
      pos=r
      Used[i]=True
      Right1.pop()
      f_r=0
    else:
      if f_r==1:
        Right1.pop()
        f_r=0
      else:
        f_r=1
    n+=1
  
ans1+=abs(pos)
n=0
ans2=0
Used=[False]*N
f_l,f_r=0,9
pos=0
while Left2 or Right2:
  if n%2==1:
    if not Left2:
      n+=1
      continue
    l,i=Left2[-1]
    if Used[i]:
      Left2.pop()
      continue
    if pos<l:
      ans2+=l-pos
      pos=l
      Used[i]=True
      Left2.pop()
      f_l=0
    else:
      if f_l==1:
        Left2.pop()
        f_l=0
      else:
        f_l=1
    n+=1
  elif n%2==0:
    if not Right2:
      n+=1
      continue
    r,i=Right2[-1]
    if Used[i]:
      Right2.pop()
      continue
    if r<pos:
      ans2+=pos-r
      pos=r
      Used[i]=True
      Right2.pop()
      f_r=0
    else:
      if f_r==1:
        Right2.pop()
        f_r=0
      else:
        f_r=1
    n+=1
    
ans2+=abs(pos)
print(max(ans1,ans2))
```