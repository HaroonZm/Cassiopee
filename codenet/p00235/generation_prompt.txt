Voici un énoncé de problème :

サージェント・ライアン
「ライアン軍曹を救え」という指令のもと、アイヅ軍の救出部隊はドイツリーの水上都市で敵軍と激しい戦闘を繰り広げていました。彼らは無事に軍曹と合流しましたが、敵の戦車が多く、救出ヘリを呼べずにいました。そこで、彼らは敵の戦車を混乱させるため、都市にある橋を全て爆破するという作戦を実行することにしました。
作戦はすぐに司令部に伝えられ、救出ヘリの準備が進められました。救出ヘリを飛ばすためには、いつ橋が全て爆破されるかを予測しなければなりません。軍のプログラマであるあなたの任務は、救出部隊が全ての橋の爆破に必要な時間を計算することです。
水上都市は
N
個の島で構成されており、島と島との間には橋がかかっています。すべての島はツリー状に繋がっています(下図参照) 。ある島からある島への経路は、一通りだけ存在します。各橋を渡るには、橋ごとに決められた時間がかかり、どちらの方向にもその時間で橋を渡ることが可能です。
救出部隊はボートなど水上を移動する手段を持っていないので島と島の間を移動するには橋を通る他ありません。救出部隊は、その時いる島に隣接している橋のうち、必要なものを一瞬で爆破することができます。救出部隊が全ての橋を爆破するのに必要な最小の時間はいくらでしょうか。ただし、島の中での移動時間は考えません。
島の数、それぞれの橋情報を入力とし、橋を全て爆破するのに必要な最小の時間を出力するプログラムを作成してください。島はそれぞれ 1 から
N
の番号で表されます。橋は
N
-1 本あります。橋情報は、その橋が隣接している二つの島の番号(
a
,
b
)と、その橋を渡るのに必要な時間
t
で構成されます。救出部隊は島番号 1 の島からスタートするものとします。
Input
複数のデータセットの並びが入力として与えられる。入力の終わりはゼロひとつの行で示される。各データセットは以下の形式で与えられる。
N
a
1
b
1
t
1
a
2
b
2
t
2
:
a
N-1
b
N-1
t
N-1
入力はすべて整数で与えられる。1 行目に島の数
N
(2 ≤
N
≤ 20) が与えられる。
続く
N
-1 行に
i
番目の橋の情報が与えられる。
a
i
,
b
i
,
t
i
(1 ≤
t
i
≤ 500) は、
i
番目の橋を通って島
a
i
と島
b
i
の間を時間
t
i
で移動できることを表す。
データセットの数は 100 を超えない。
Output
データセットごとに、橋を全て爆破するのに必要な最小の時間を1行に出力する。
Sample Input
7
1 2 5
2 3 2
3 4 3
2 5 3
5 6 3
5 7 8
0
Output for the Sample Input
12


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def tree_walk_1(start, parent=None):
    for i, t in adj[start]:
        if i != parent:
            P[i] = (start, t)
            C[start].append((i, t))
            tree_walk_1(i, start)

def tree_walk_2(start):
    global time
    notVisited[start] = False
    for c, t1 in C[start]:
        if notVisited[c]:
            time += 2 * t1
            tree_walk_2(c)
    p, t2 = P[start]
    if notVisited[p]:
        time += t2
        tree_walk_2(p)

from sys import stdin
f_i = stdin

while True:
    N = int(f_i.readline())
    if N == 0:
        break
    
    adj = [[] for i in range(N)]
    for i in range(N - 1):
        a, b, t = map(int, f_i.readline().split())
        a -= 1
        b -= 1
        adj[a].append((b, t))
        adj[b].append((a, t))
    
    # leaf cutting
    lf = []
    for i, a in enumerate(adj[1:], start=1):
        if len(a) == 1:
            lf.append(i)
    for l in lf:
        i, t = adj[l].pop()
        adj[i].remove((l, t))
    
    # root candidate
    rc = [i for i, a in enumerate(adj[1:], start=1) if len(a) == 1]
    if not rc:
        print(0)
        continue
    
    time_rec = []
    for r in rc:
        P = [None] * N
        P[r] = (r, 0)
        C = [[] for i in range(N)]
        tree_walk_1(r) #making a tree
        
        time = 0
        notVisited = [True] * N
        tree_walk_2(0)
        time_rec.append(time)
    
    print(min(time_rec))
```