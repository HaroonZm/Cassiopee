Voici un énoncé de problème :

JOI 公園 (JOI Park)
20XX 年に IOI 国で行われるオリンピックに備え，IOI 国にある JOI 公園を整備することになった．JOI公園には
N
個の広場があり，広場には 1 から
N
の番号がついている．広場を繋ぐ
M
本の道があり，道には 1 から
M
の番号がついている．道
i
(1 ≤
i
≤
M
) は広場
A
i
と広場
B
i
を双方向に繋いでおり，長さは
D
i
である．どの広場からどの広場へもいくつかの道を辿って行くことができる．
整備計画では，まず，0 以上の整数
X
を選び，広場 1 からの距離が
X
以下であるような広場 (広場 1 を含む) どうしをすべて相互に地下道で結ぶ．ただし，広場
i
と広場
j
の距離とは，広場
i
から広場
j
に行くときに通る道の長さの和の最小値である．整備計画では地下道の整備コストに関する整数
C
が定まっている．地下道の整備にかかるコストは
C × X
である．
次に，地下道で結ばれた広場どうしを結ぶ道をすべて撤去する．道の撤去にコストはかからない．最後に，撤去されずに残った道をすべて補修する．長さ
d
の道を補修するためにかかるコストは
d
である．整備計画実施前の JOI 公園には地下道はない．JOI 公園の整備にかかるコストの和の最小値を求めよ．
課題
JOI 公園の広場の情報と，地下道の整備コストに関する整数が与えられたとき，JOI 公園の整備にかかる
コストの和の最小値を求めるプログラムを作成せよ．
入力
標準入力から以下のデータを読み込め．
1 行目には，整数
N
,
M
,
C
が空白を区切りとして書かれている．これは，広場が
N
個，道が
M
本あり，地下道の整備コストに関する整数が
C
であることを表す．
続く
M
行のうちの
i
行目 (1 ≤
i
≤
M
) には，整数
A
i
,
B
i
,
D
i
が空白を区切りとして書かれている．これは，道
i
が広場
A
i
と広場
B
i
を繋ぎ，長さが
D
i
であることを表す．
出力
標準出力に，JOI 公園の整備にかかるコストの和の最小値を表す整数を 1 行で出力せよ．
制限
すべての入力データは以下の条件を満たす．
2 ≤
N
≤ 100 000．
1 ≤
M
≤ 200 000．
1 ≤
C
≤ 100 000．
1 ≤
A
i
≤
N
(1 ≤
i
≤
M
)．
1 ≤
B
i
≤
N
(1 ≤
i
≤
M
)．
A
i
≠
B
i
(1 ≤
i
≤
M
)．
(
A
i
,
B
i
) ≠ (
A
j
,
B
j
) および (
A
i
,
B
i
) ≠ (
B
j
,
A
j
) (1 ≤
i
<
j
≤
M
)．
1 ≤
D
i
≤ 100 000 (1 ≤
i
≤
M
)．
与えられる入力データにおいては，どの広場からどの広場へもいくつかの道を辿ることにより行けることが保証されている．
入出力例
入力例 1
5 5 2
2 3 1
3 1 2
2 4 3
1 2 4
2 5 5
出力例 1
14
この入力例では，
X
= 3 として，広場 1 からの距離が 3 以下であるような広場 (広場 1, 広場 2, 広場 3) どうしをすべて相互に地下道で結んだとき，整備にかかるコストの和は 2 × 3 + 3 + 5 = 14 となる．これが最小値である．
入力例 2
5 4 10
1 2 3
2 3 4
3 4 3
4 5 5
出力例 2
15
この入力例では，X = 0 のとき整備にかかるコストの和が最小になる．
入力例 3
6 5 2
1 2 2
1 3 4
1 4 3
1 5 1
1 6 5
出力例 3
10
この入力例では，
X
= 5 としてすべての広場を相互に地下道で結んだとき，整備にかかるコストの和が最小になる．
問題文と自動審判に使われるデータは、
情報オリンピック日本委員会
が作成し公開している問題文と採点用テストデータです。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop
INF = 10 ** 20

n, m, c = map(int, input().split())
edges = [[] for _ in range(n)]
edges_dict = {}
d_cost = 0
for _ in range(m):
  a, b, d = map(int, input().split())
  a -= 1
  b -= 1
  edges[a].append((b, d))
  edges[b].append((a, d))
  edges_dict[(a, b)] = d
  d_cost += d

dist = [INF] * n
dist[0] = 0
que = []
heappush(que, (0, 0))
while que:
  total, node = heappop(que)
  for to, d in edges[node]:
    if dist[to] > total + d:
      dist[to] = total + d
      heappush(que, (total + d, to))

removal = {}
for t, d in edges_dict.items():
  max_d = max(dist[t[0]], dist[t[1]])
  if max_d in removal:
    removal[max_d] += d
  else:
    removal[max_d] = d

ans = d_cost
for k, v in sorted(removal.items()):
  d_cost -= v
  if d_cost + k * c < ans:
    ans = d_cost + k * c

print(ans)
```