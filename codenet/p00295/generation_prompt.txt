Voici un énoncé de problème :

フロッピーキューブ
フロッピーキューブをプログラミングで解いてみましょう。フロッピーキューブは図のように表面に色のついた９個の立方体から構成されている立体パズルで、キューブの列を回転させることによって、６つの各面の色をそろえます。
フロッピーキューブに対しては下図のような４種類の操作を行うことができ、一回の操作で、端にある３つの隣接したキューブを１８０度回転することができます。わかりやすいように、図では、上面に＋(赤色)、下面に＊(緑色)、右前面に□(黄色)、左前面に●(青色)、右奥面に○(水色)、左奥面に■紫色) の記号が付いている状態を初期状態としています。
フロッピーキューブの初期状態が与えられるので、パズルを解くために必要な最小の操作回数を求めるプログラムを作成してください。
入力
入力は以下の形式で与えられる。
N
puzzle
1
puzzle
2
:
puzzle
N
１行目の
N
(1 ≤
N
≤ 30) は操作回数を計算したいパズルの数である。続くN行に各フロッピーキューブの初期状態
puzzle
i
が与えられる。
puzzle
i
は以下の形式で与えられる。
p
1
p
2
p
3
p
4
p
5
p
6
p
7
p
8
p
9
p
10
p
11
p
12
p
13
p
14
p
15
p
16
p
17
p
18
p
19
p
20
p
21
p
22
p
23
p
24
p
25
p
26
p
27
p
28
p
29
p
30
各フロッピーキューブの情報は 30 個の整数
p
i
(1 ≤
p
i
≤ 6) からなる。
p
i
は、下図のようにフロッピーキューブの各面に番号
i
を振ったときの、そのキューブの面の色を表す。
パズルは、多くとも８回の操作で解くことができると仮定してよい。
出力
パズルごとに、最小の操作回数を１行に出力する。
入出力例
入力例
4
1 1 1 1 1 1 1 1 1 2 2 2 4 4 4 6 6 6 5 5 5 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 1 1 1 2 2 2 4 4 6 4 6 6 5 5 5 3 3 3 3 3 3 1 1 1
3 3 3 1 1 3 1 1 1 2 2 5 6 4 4 4 6 6 2 5 5 3 3 3 1 3 3 1 1 1
1 3 1 3 1 3 3 1 3 2 2 2 6 4 4 6 6 4 5 5 5 1 3 1 1 3 1 3 1 3
出力例
0
1
2
7


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def rotate(p, comm):
    if comm==0:
        p[0],p[1],p[2], p[27],p[28],p[29] = p[27],p[28],p[29], p[0],p[1],p[2]
        p[14], p[15] = p[15], p[14]
        p[18], p[20] = p[20], p[18]
    elif comm==1:
        p[2],p[5],p[8], p[21],p[24],p[27] = p[21],p[24],p[27], p[2],p[5],p[8]
        p[11], p[18] = p[18], p[11]
        p[12], p[14] = p[14], p[12]
    elif comm==2:
        p[6],p[7],p[8], p[21],p[22],p[23] = p[21],p[22],p[23], p[6],p[7],p[8]
        p[12], p[17] = p[17], p[12]
        p[9], p[11] = p[11], p[9]
    elif comm==3:
        p[0],p[3],p[6], p[23],p[26],p[29] = p[23],p[26],p[29], p[0],p[3],p[6]
        p[9], p[20] = p[20], p[9]
        p[15], p[17] = p[17], p[15]
def all_eq(A, left, right):
    return all(A[i]==A[left] for i in xrange(left, right))
def is_correct(p):
    return all_eq(p, 9, 12) and all_eq(p, 12, 15) and all_eq(p, 15, 18) and all_eq(p, 18, 21) and all_eq(p, 0, 9) and all_eq(p, 21, 30)
ans = 8
def dfs(p, cnt, f):
    global ans
    if ans<=cnt:
        return
    if is_correct(p):
        ans = cnt
        return
    for k in xrange(4):
        if ans<=cnt+1:
            break
        if k==f:
            continue
        rotate(p, k)
        dfs(p, cnt+1, k)
        rotate(p, k)

n = input()
for _ in xrange(n):
    p = map(int, raw_input().split())
    ans = 8
    dfs(p, 0, -1)
    print ans
```