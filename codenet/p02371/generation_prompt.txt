Voici un énoncé de problème :

Diameter of a Tree
Given a tree
T
with non-negative weight, find the diameter of the tree.
The diameter of a tree is the maximum distance between two nodes in a tree.
Input
n
s
1
t
1
w
1
s
2
t
2
w
2
:
s
n-1
t
n-1
w
n-1
The first line consists of an integer
n
which represents the number of nodes in the tree. Every node has a unique ID from 0 to
n
-1 respectively.
In the following
n
-1 lines, edges of the tree are given.
s
i
and
t
i
represent end-points of the
i
-th edge (undirected) and
w
i
represents the weight (distance) of the
i
-th edge.
Output
Print the diameter of the tree in a line.
Constraints
1 ≤
n
≤ 100,000
0 ≤
w
i
≤ 1,000
Sample Input 1
4
0 1 2
1 2 1
1 3 3
Sample Output 1
5
Sample Input 2
4
0 1 1
1 2 2
2 3 4
Sample Output 2
7


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heapify, heappop, heappush, heappushpop, heapreplace

def diameter(tonodes, n):
    visited = [False for _ in range(n)]
    queue = []
    max_weight = 0
    max_node = 0
    for i, node in enumerate(tonodes):
        if len(node) > 0:
            visited[i] = True
            max_node = i
            for edge in node:
                heappush(queue, (-edge[0], edge[1]))
            break

    while len(queue) > 0:
        weight, node = heappop(queue)
        visited[node] = True
        if max_weight < -weight:
            max_weight = -weight
            max_node = node
        for edge in tonodes[node]:
            if not visited[edge[1]]:
                heappush(queue, (weight - edge[0], edge[1]))

    for i in range(n):
        visited[i] = False

    visited[max_node] = True

    for edge in tonodes[max_node]:
        heappush(queue, (-edge[0], edge[1]))

    max_weight = 0

    while len(queue) > 0:
        weight, node = heappop(queue)
        visited[node] = True
        if max_weight < -weight:
            max_weight = -weight
            max_node = node
        for edge in tonodes[node]:
            if not visited[edge[1]]:
                heappush(queue, (weight - edge[0], edge[1]))

    return max_weight

def main():
    n = int(input())
    tonodes = [[] for _ in range(n)]
    for _ in range(n - 1):
        s, t, w = map(int, input().split())
        tonodes[s].append((w, t))
        tonodes[t].append((w, s))
    max_weight = diameter(tonodes, n)
    print(max_weight)

if __name__ == "__main__":
    main()
```