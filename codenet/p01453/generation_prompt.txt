Voici un énoncé de problème :

Problem G: スプリング・タイル
ある朝、あなたが目覚めると、そこはバネだらけの迷宮の中だった。
なぜ自分がこんな見知らぬ場所にいるのかはわからない。この場でじっと助けを待つという選択肢も
あるにはあるが、こういった迷宮の中に長居していると、いつかは必ず突風が吹いてきて吹き飛ばさ
れてしまうことを、あなたは経験上知っていた。しかし、突風が吹いてくるまでの時間は判断のしよ
うがない。そこであなたは、迷宮から脱出するまでに必要な移動回数の期待値が最小になるように行
動するのが最善の戦略だと考えた。
足元に落ちていた正体不明の巻物を拾ってためしに読んでみたところ、偶然にも迷宮の全体マップを
知覚することができた。さらに、たまたま持っていた草を飲むことで、すべてのワナの位置も知るこ
とができた。どうやらこの迷宮には、危険なモンスターやバネ以外のワナは存在しないらしい。
この迷宮は、いくつかの種類のタイルが長方形に並んだ形をしており、たとえば以下のようにあらわ
される。
########
#..##g.#
#*#.*#.#
#......#
#*s#*.*#
########
「.」：床。この上なら自由に歩き回ることができる。
「#」：壁。あなたは壁の中に入ることはできない。
「s」：あなたの最初の位置。このタイルの下は床になっている。
「g」：階段。このタイルの上に乗れば、迷宮を脱出したことになる。
「*」：バネ。このタイルの上に乗ると、いずれかの床の上（階段、バネのタイルは除く）にランダムに飛ばされる。それぞれの床に飛ばされる確率はすべて等しい。
タイルの種類は、この５つのいずれかである。
あなたは、現在乗っているタイルから隣り合ったタイルへ、上下左右いずれかの方向に１マスずつ移
動することができる。ただし、ナナメに移動することはできない。
迷宮のマップが与えられたとき、最善の戦略をとった場合に迷宮から脱出するまでに必要な移動回数
の期待値を求めよ。バネで飛ばされるのは移動回数には含めない。
Input
W H
c
11
c
12
...
c
1
w
c
21
c
22
...
c
2
w
:: :
c
h
1
c
h
2
...
c
c
w
入力の１行目には、整数
W
（3 ≤
W
≤ 500）と整数
H
（3 ≤
H
≤ 500）が、この順に空白区切りで書かれている。整数
W
は迷宮の横幅を、整数
H
は迷宮の縦幅をあらわす。
続く
H
行には、迷宮のマップをあらわす
W
個の文字が書かれている（空白区切りではない）。この部分の形式は、先に挙げた例のとおりである。なお、データ中に「s」と「g」は、それぞれちょうど１回ずつ出現する。また、迷宮の周囲１マスは、必ず壁で囲まれている。
なお、与えられる迷宮では、どのように移動し、バネでどのように飛ばされたとしても、「バネで飛
ばされる床を任意に設定できたとしても脱出不可能な状態」に陥ることはないと仮定してよい。
Output
最善の戦略をとったときに、脱出までにかかる移動回数の期待値を出力せよ。出力は誤差を含んでい
てもよいが、真の値との相対誤差が10
-9
未満でなければならない。
Sample Input 1
8 6
########
#..##g.#
#*#.*#.#
#......#
#*s#*.*#
########
Sample Output 1
5.857142857143
Sample Input 2
21 11
#####################
#*#*.*.*.*.*.*.*.*#*#
#*#...............#*#
#*#.#.#.#.#.#.#.#.#*#
##.#.#.#.#.#.#.#.#.##
#...................#
##.#.#.#.#.#.#.#.#.##
#s#.#.#.#.#.#.#.#.#g#
#...................#
#...................#
#####################
Sample Output 2
20.000000000000
Sample Input 3
9 8
#########
#...#*.*#
#.*.#...#
#...#*.*#
#########
#.s....g#
#.*#.*..#
#########
Sample Output 3
5.000000000000


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque

w, h = map(int, input().split())
mp = [input() for _ in range(h)]

springs = []
tile_cnt = 0
for y in range(h):
  for x in range(w):
    if mp[y][x] == "*":
      springs.append((x, y))
    if mp[y][x] == "g":
      gx, gy = x, y
    if mp[y][x] == "s":
      sx, sy = x, y
      tile_cnt += 1
    if mp[y][x] == ".":
      tile_cnt += 1

vec = ((1, 0), (0, -1), (-1, 0), (0, 1))
INF = 10 ** 10

g_dist = [[INF] * w for _ in range(h)]
que = deque()
que.append((0, gx, gy))
g_dist[gy][gx] = 0
while que:
  score, x, y = que.popleft()
  for dx, dy in vec:
    nx, ny = x + dx, y + dy
    if mp[ny][nx] in (".", "s"):
      if g_dist[ny][nx] == INF:
        g_dist[ny][nx] = score + 1
        que.append((score + 1, nx, ny))

s_dist = [[INF] * w for _ in range(h)]
que = deque()
for x, y in springs:
  s_dist[y][x] = 0
  que.append((0, x, y))
while que:
  score, x, y = que.popleft()
  for dx, dy in vec:
    nx, ny = x + dx, y + dy
    if mp[ny][nx] in (".", "s"):
      if s_dist[ny][nx] == INF:
        s_dist[ny][nx] = score + 1
        que.append((score + 1, nx, ny))

sorted_tiles = sorted([(g_dist[y][x] - s_dist[y][x] if g_dist[y][x] != INF else INF, x, y) for y in range(h) for x in range(w) if mp[y][x] in (".", "s")])

acc_g = 0
acc_s = 0
acc_t = 0
acc_g_dic = {}
acc_s_dic = {}
acc_t_dic = {}
keys = set()
for key, x, y in sorted_tiles:
  acc_g += g_dist[y][x]
  acc_s += s_dist[y][x]
  acc_t += 1
  acc_g_dic[key] = acc_g
  acc_s_dic[key] = acc_s
  acc_t_dic[key] = acc_t
  keys.add(key)
keys = sorted(list(keys))

length = len(keys)
for i in range(length - 1):
  key = keys[i]
  next_key = keys[i + 1]
  E = (acc_g_dic[key] + acc_s - acc_s_dic[key]) / acc_t_dic[key]
  if key <= E < next_key:
    print(min(g_dist[sy][sx], s_dist[sy][sx] + E))
    break
else:
  print(g_dist[sy][sx])
```