Voici un énoncé de problème :

Rabbit Party
A rabbit Taro decided to hold a party and invite some friends as guests.
He has
n
rabbit friends, and
m
pairs of rabbits are also friends with each other.
Friendliness of each pair is expressed with a positive integer.
If two rabbits are not friends, their friendliness is assumed to be 0.
When a rabbit is invited to the party, his satisfaction score is defined as the minimal friendliness with any other guests.
The satisfaction of the party itself is defined as the sum of satisfaction score for all the guests.
To maximize satisfaction scores for the party, who should Taro invite?
Write a program to calculate the maximal possible satisfaction score for the party.
Input
The first line of the input contains two integers,
n
and
m
(
1 \leq n \leq 100
,
0 \leq m \leq 100
).
The rabbits are numbered from
1
to
n
.
Each of the following
m
lines has three integers,
u
,
v
and
f
.
u
and
v
(
1 \leq u, v \leq n
,
u \neq v
,
1 \leq f \leq 1,000,000
) stands for the rabbits' number, and
f
stands for their friendliness.
You may assume that the friendliness of a pair of rabbits will be given at most once.
Output
Output the maximal possible satisfaction score of the party in a line.
Sample Input 1
3 3
1 2 3
2 3 1
3 1 2
Output for the Sample Input 1
6
Sample Input 2
2 1
1 2 5
Output for the Sample Input 2
10
Sample Input 3
1 0
Output for the Sample Input 3
0
Sample Input 4
4 5
1 2 4
1 3 3
2 3 7
2 4 5
3 4 6
Output for the Sample Input 4
16


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from itertools import product
def main():
    INF = 10**9
    N, M = map(int, input().split())
    E = [[INF]*N for i in range(N)]
    G = [set() for i in range(N)]
    D = [0]*N
    for i in range(M):
        u, v, f = map(int, input().split()); u -= 1; v -= 1
        E[u][v] = E[v][u] = f
        G[u].add(v)
        G[v].add(u)
        D[u] += 1; D[v] += 1

    def calc(vs):
        if len(vs) == 1:
            return 0
        res = 0
        for ps in product([0, 1], repeat=len(vs)):
            R = [v for p, v in zip(ps, vs) if p]
            if len(R) == 1:
                continue
            rs = 0
            for v in R:
                r = INF
                for w in R:
                    if v == w:
                        continue
                    r = min(r, E[v][w])
                rs += r
            res = max(res, rs)
        return res

    def dfs(V, P, X):
        if not P and not X:
            return calc(V)
        u = next(iter(X or P))
        r = 0
        for v in P - G[u]:
            r = max(r, dfs(V | {v}, P & G[v], X & G[v]))
            P.remove(v)
            X.add(v)
        return r

    *I, = range(N)
    I.sort(key = D.__getitem__, reverse=1)

    ans = 0
    P = set(range(N))
    X = set()
    for v in I:
        ans = max(ans,  dfs({v}, P & G[v], X & G[v]))
        P.remove(v)
        X.add(v)
    print(ans)
main()
```