Voici un énoncé de problème :

環状すごろく
ユキさんは、子供会の催しでみんなで遊べるようにすごろくを作りました。このすごろくでは、環状にマスが並んでいて、それぞれのマスには１以上の整数が書いてあります。
プレイヤーは出発点としてどこかのマスを選んで自分の駒を置きます。そのマスに書いてある数だけ、時計回りに駒を進めます。止まったマスに書いてある数だけ、再び時計回りに駒を進めます。これを繰り返して、出発点に選んだマスの上で駒が止まったら「あがり」です。
実際には、マスの選び方によっては絶対に「あがり」にならない場合もあります。ユキさんは、このすごろくで「あがり」にたどり着けるマスの個数を数えようとしています。
すごろくの情報を入力とし、「あがり」にたどり着けるマスの個数を報告するプログラムを作成せよ。
Input
入力は以下の形式で与えられる。
N
a
1
a
2
...
a
N
１行目にすごろくに含まれるすべてのマスの個数
N
(1 ≤
N
≤ 100000) が与えられる。２行目に、それぞれのマスに書かれた数
a
i
(1 ≤
a
i
≤ 10
9
) が、時計回りに順番に与えられる。
Output
「あがり」にたどり着けるマスの個数を１行に出力する。
Sample Input 1
3
1 1 1
Sample Output 1
3
Sample Input 2
3
1 1 2
Sample Output 2
2
Sample Input 3
8
2 3 7 3 3 3 4 4
Sample Output 3
6


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
sys.setrecursionlimit(1000000)

n = int(input())
alst = list(map(int, input().split()))
edges = [[] for _ in range(n)]
rev_edges = [[] for _ in range(n)]
for i in range(n):
  edges[i].append((i + alst[i]) % n)
  rev_edges[(i + alst[i]) % n].append(i)

def dfs(x, ret, edges, visited):
  visited[x] = True
  for e in edges[x]:
    if not visited[e]:
      dfs(e, ret, edges, visited)
  ret.append(x)

def dfs_rev(x, cycles, rev_edges, visited):
  visited[x] = True
  flag = False
  for e in rev_edges[x]:
    if not visited[e]:
      cycles.add(e)
      dfs_rev(e, cycles, rev_edges, visited)
      flag = True
    elif x == e:
      flag = True
  if flag:
    cycles.add(x)

order = []
visited = [False] * n
for i in range(n):
  if not visited[i]:
    dfs(i, order, edges, visited)
order.reverse()

visited = [False] * n
cycles = set()
for i in order:
  if not visited[i]:
    dfs_rev(i, cycles, rev_edges, visited)
print(len(cycles))
```