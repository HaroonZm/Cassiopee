Voici un énoncé de problème :

Score :
100
points
Problem Statement
There is a grid with
H
horizontal rows and
W
vertical columns.
Let
(i, j)
denote the square at the
i
-th row from the top and the
j
-th column from the left.
For each
i
and
j
(
1 \leq i \leq H
,
1 \leq j \leq W
), Square
(i, j)
is described by a character
a_{i, j}
.
If
a_{i, j}
is
.
, Square
(i, j)
is an empty square; if
a_{i, j}
is
#
, Square
(i, j)
is a wall square.
It is guaranteed that Squares
(1, 1)
and
(H, W)
are empty squares.
Taro will start from Square
(1, 1)
and reach
(H, W)
by repeatedly moving right or down to an adjacent empty square.
Find the number of Taro's paths from Square
(1, 1)
to
(H, W)
.
As the answer can be extremely large, find the count modulo
10^9 + 7
.
Constraints
H
and
W
are integers.
2 \leq H, W \leq 1000
a_{i, j}
is
.
or
#
.
Squares
(1, 1)
and
(H, W)
are empty squares.
Input
Input is given from Standard Input in the following format:
H
W
a_{1, 1}
\ldots
a_{1, W}
:
a_{H, 1}
\ldots
a_{H, W}
Output
Print the number of Taro's paths from Square
(1, 1)
to
(H, W)
, modulo
10^9 + 7
.
Sample Input 1
3 4
...#
.#..
....
Sample Output 1
3
There are three paths as follows:
Sample Input 2
5 2
..
#.
..
.#
..
Sample Output 2
0
There may be no paths.
Sample Input 3
5 5
..#..
.....
#...#
.....
..#..
Sample Output 3
24
Sample Input 4
20 20
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
....................
Sample Output 4
345263555
Be sure to print the count modulo
10^9 + 7
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys, re
from collections import deque, defaultdict, Counter
from math import sqrt, hypot, factorial, pi, sin, cos, radians
if sys.version_info.minor >= 5: from math import gcd
else: from fractions import gcd 
from heapq import heappop, heappush, heapify, heappushpop
from bisect import bisect_left, bisect_right
from itertools import permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from functools import reduce, partial
from fractions import Fraction
from string import ascii_lowercase, ascii_uppercase, digits

def input(): return sys.stdin.readline().strip()
def ceil(a, b=1): return int(-(-a // b))
def round(x): return int((x*2+1) // 2)
def fermat(x, y, MOD): return x * pow(y, MOD-2, MOD) % MOD
def lcm(x, y): return (x * y) // gcd(x, y)
def lcm_list(nums): return reduce(lcm, nums, 1)
def gcd_list(nums): return reduce(gcd, nums, nums[0])
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
MOD = 10 ** 9 + 7

H, W = MAP()

# 四方に一回り大きいグリッドを作る
grid = [['#'] * (W+2) for i in range(H+2)]
for i in range(1,H+1):
    row = list(input())
    for j in range(1, W+1):
        grid[i][j] = row[j-1]

dp = [[0] * (W+2) for i in range(H+2)]
# スタート地点に1通りを初期値設定
dp[1][1] = 1
for i in range(1,H+1):
    for j in range(1, W+1):
        # 現在位置が壁なら何もできない
        if grid[i][j] == '#':
            continue
        # 上が壁でなければ、値を持ってくる
        if grid[i-1][j] != '#':
            dp[i][j] += dp[i-1][j]
        # 左が壁でなければ、値を持ってくる
        if grid[i][j-1] != '#':
            dp[i][j] += dp[i][j-1]
# ゴール地点の値を確認する
print(dp[H][W] % MOD)
```