Voici un énoncé de problème :

Score :
500
points
Problem Statement
There are
N
towns on a plane. The
i
-th town is located at the coordinates
(x_i,y_i)
. There may be more than one town at the same coordinates.
You can build a road between two towns at coordinates
(a,b)
and
(c,d)
for a cost of
min(|a-c|,|b-d|)
yen (the currency of Japan). It is not possible to build other types of roads.
Your objective is to build roads so that it will be possible to travel between every pair of towns by traversing roads. At least how much money is necessary to achieve this?
Constraints
2 ≤ N ≤ 10^5
0 ≤ x_i,y_i ≤ 10^9
All input values are integers.
Input
Input is given from Standard Input in the following format:
N
x_1
y_1
x_2
y_2
:
x_N
y_N
Output
Print the minimum necessary amount of money in order to build roads so that it will be possible to travel between every pair of towns by traversing roads.
Sample Input 1
3
1 5
3 9
7 8
Sample Output 1
3
Build a road between Towns
1
and
2
, and another between Towns
2
and
3
. The total cost is
2+1=3
yen.
Sample Input 2
6
8 3
4 9
12 19
18 1
13 5
7 6
Sample Output 2
8


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import *
#->: 型注釈
class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n
    
    #要素xが属するグループの根を返す
    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    #xのグループとyのグループを併合
    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

N = int(input())
X = []
for i in range(N):
    x, y = map(int, input().split())
    X.append((x, y, i))

X.sort(key=lambda x: x[0])

H = []
heapify(H)
for i in range(N-1):
    x1, j1 = X[i][0], X[i][2]
    x2, j2 = X[i+1][0], X[i+1][2]
    heappush(H,(x2-x1, j1, j2))
    # print(x1, x2)
    # print("=--")

X.sort(key=lambda x: x[1])

for i in range(N-1):
    y1, j1 = X[i][1], X[i][2]
    y2, j2 = X[i+1][1], X[i+1][2]
    heappush(H,(y2-y1, j1, j2))
    # print(y1, y2)

ans = 0
# print(H)
uf = UnionFind(N)
while H:
    w,s,t = heappop(H)
    if uf.find(s) != uf.find(t):
        uf.union(s,t)
        ans += w
print(ans)
```