Voici un énoncé de problème :

Edit Distance (Levenshtein Distance)
Find the edit distance between given two words
s1
and
s2
.
The disntace is the minimum number of single-character edits required to change one word into the other. The edits including the following operations:
insertion
: Insert a character at a particular position.
deletion
: Delete a character at a particular position.
substitution
: Change the character at a particular position to a different character
Input
s1
s2
Two words
s1
and
s2
are given in the first line and the second line respectively. The words will consist of lower case characters.
Output
Print the edit distance in a line.
Constraints
1 ≤ length of
s1
≤ 1000
1 ≤ length of
s2
≤ 1000
Sample Input 1
acac
acm
Sample Output 1
2
Sample Input 2
icpc
icpc
Sample Output 2
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def main():
    s=input()
    t=input()
    n=len(s)
    m=len(t)
    memo=[[n+m for _ in [0]*(m+1)] for _ in [0]*(n+1)]
    memo[0][0]=0
    
    for i in range(n+m):
        for j in range(i+1):
            k=i-j
            if 0<=j<n and 0<=k<m:
                if s[j]==t[k]:
                    memo[j+1][k+1]=min(memo[j+1][k+1],memo[j][k])
                else:
                    memo[j+1][k]=min(memo[j+1][k],memo[j][k]+1)
                    memo[j][k+1]=min(memo[j][k+1],memo[j][k]+1)
                    memo[j+1][k+1]=min(memo[j+1][k+1],memo[j][k]+1)
            elif j==n:
                memo[j][k+1]=min(memo[j][k+1],memo[j][k]+1)
            elif k==m:
                memo[j+1][k]=min(memo[j+1][k],memo[j][k]+1)
    print(memo[n][m])
                
if __name__ == '__main__':
    main()
```