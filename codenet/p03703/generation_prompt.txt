Voici un énoncé de problème :

Score :
600
points
Problem Statement
You are given an integer sequence of length
N
,
a =
{
a_1, a_2, …, a_N
}, and an integer
K
.
a
has
N(N+1)/2
non-empty contiguous subsequences, {
a_l, a_{l+1}, …, a_r
}
(1 ≤ l ≤ r ≤ N)
. Among them, how many have an arithmetic mean that is greater than or equal to
K
?
Constraints
All input values are integers.
1 ≤ N ≤ 2 \times 10^5
1 ≤ K ≤ 10^9
1 ≤ a_i ≤ 10^9
Input
Input is given from Standard Input in the following format:
N
K
a_1
a_2
:
a_N
Output
Print the number of the non-empty contiguous subsequences with an arithmetic mean that is greater than or equal to
K
.
Sample Input 1
3 6
7
5
7
Sample Output 1
5
All the non-empty contiguous subsequences of
a
are listed below:
{
a_1
} = {
7
}
{
a_1, a_2
} = {
7, 5
}
{
a_1, a_2, a_3
} = {
7, 5, 7
}
{
a_2
} = {
5
}
{
a_2, a_3
} = {
5, 7
}
{
a_3
} = {
7
}
Their means are
7
,
6
,
19/3
,
5
,
6
and
7
, respectively, and five among them are
6
or greater. Note that {
a_1
} and {
a_3
} are indistinguishable by the values of their elements, but we count them individually.
Sample Input 2
1 2
1
Sample Output 2
0
Sample Input 3
7 26
10
20
30
40
30
20
10
Sample Output 3
13


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import itertools
import os
import sys

if os.getenv("LOCAL"):
    sys.stdin = open("_in.txt", "r")

sys.setrecursionlimit(2147483647)
INF = float("inf")

class BinaryIndexedTree:
    # http://hos.ac/slides/20140319_bit.pdf
    def __init__(self, size):
        """
        :param int size:
        """
        self._bit = [0 for _ in range(size)]
        self._size = size

    def add(self, i, w):
        """
        i 番目に w を加える
        :param int i:
        :param int w:
        :return:
        """
        x = i + 1
        while x <= self._size:
            self._bit[x - 1] += w
            x += x & -x

    def sum(self, i):
        """
        0 番目から i 番目までの合計
        :param int i:
        :return:
        """
        ret = 0
        x = i + 1
        while x > 0:
            ret += self._bit[x - 1]
            x -= x & -x
        return ret

    def __len__(self):
        return self._size

N, K = list(map(int, sys.stdin.readline().split()))
A = [int(sys.stdin.readline()) for _ in range(N)]

# cumsum の最初を 0 にする
N += 1
# D[l-1] <= D[r] (l <= r) なら平均が K 以上。
D = list(itertools.accumulate([0] + [a - K for a in A]))

def compress(arr):
    """
    :param list of int arr:
    :return:
    """
    ret = [0] * len(arr)
    rank = 0
    prev = None
    for a, i in sorted([(a, i) for i, a in enumerate(arr)]):
        if a != prev:
            rank += 1
        ret[i] = rank
    return ret

def count(arr):
    """
    転倒数の逆。arr[L-1] <= arr[r] となる (L, r) の組み合わせ数
    :param list of int arr:
    :return:
    """
    ranks = compress(arr)
    bit = BinaryIndexedTree(size=max(ranks) + 1)
    ret = 0
    for i, rank in enumerate(ranks):
        ret += bit.sum(rank)
        bit.add(rank, 1)
    return ret

print(count(D))
```