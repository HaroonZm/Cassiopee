En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 7)

import numpy as np

MOD = 10**9 + 7

H,W,N = map(int,input().split())
R,C = np.array(sys.stdin.read().split() + [H,W],dtype=np.int64).reshape(N+1,2).T

ind = np.argsort((R<<32)+C)
R = R[ind]
C = C[ind]

def cumprod(arr):
    L = len(arr); Lsq = int(L**.5+1)
    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)
    for n in range(1,Lsq):
        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD
    for n in range(1,Lsq):
        arr[n] *= arr[n-1,-1]; arr[n] %= MOD
    return arr.ravel()[:L]

U = 2 * 10**5 + 10
x = np.arange(U,dtype=np.int64)
x[0] = 1
fact = cumprod(x)
x = np.arange(U,0,-1,dtype=np.int64)
x[0] = pow(int(fact[-1]),MOD-2,MOD)
fact_inv = cumprod(x)[::-1]

dp = np.zeros(N+1,dtype=np.int64)
dp += fact[R+C-2] * fact_inv[R-1] % MOD * fact_inv[C-1] % MOD

for i,(r,c) in enumerate(zip(R,C)):
    j = np.where((R<=r)&(C<=c)&(R+C<r+c))
    dx,dy = r-R[j],c-C[j]
    dp[i] -= (dp[j] * fact[dx+dy] % MOD * fact_inv[dx] % MOD * fact_inv[dy] % MOD).sum()
    dp[i] %= MOD

answer = dp[-1]
print(answer)
```