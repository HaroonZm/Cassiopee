Voici un énoncé de problème :

Score :
300
points
Problem Statement
There are
N
cities numbered
1
through
N
, and
M
bidirectional roads numbered
1
through
M
.
Road
i
connects City
A_i
and City
B_i
.
Snuke can perform the following operation zero or more times:
Choose two distinct cities that are not directly connected by a road, and build a new road between the two cities.
After he finishes the operations, it must be possible to travel from any city to any other cities by following roads (possibly multiple times).
What is the minimum number of roads he must build to achieve the goal?
Constraints
2 \leq N \leq 100,000
1 \leq M \leq 100,000
1 \leq A_i < B_i \leq N
No two roads connect the same pair of cities.
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
M
A_1
B_1
:
A_M
B_M
Output
Print the answer.
Sample Input 1
3 1
1 2
Sample Output 1
1
Initially, there are three cities, and there is a road between City
1
and City
2
.
Snuke can achieve the goal by building one new road, for example, between City
1
and City
3
.
After that,
We can travel between
1
and
2
directly.
We can travel between
1
and
3
directly.
We can travel between
2
and
3
by following both roads (
2
-
1
-
3
).


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#unionfind
class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

n,m=map(int,input().split())
uf=UnionFind(n)
for _ in range(m):
    a,b=map(int,input().split())
    a-=1
    b-=1
    uf.union(a,b)
s=set()
for i in range(n):
    s.add(uf.find(i))
print(len(s)-1)
```