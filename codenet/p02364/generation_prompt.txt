Voici un énoncé de problème :

Minimum Spanning Tree
Find the sum of weights of edges of the Minimum Spanning Tree for a given weighted undirected graph
G
= (
V
,
E
).
Input
|V|
|E|
s
0
t
0
w
0
s
1
t
1
w
1
:
s
|E|-1
t
|E|-1
w
|E|-1
, where
|V|
is the number of vertices and
|E|
is the number of edges in the graph. The graph vertices are named with the numbers 0, 1,...,
|V|
-1 respectively.
s
i
and
t
i
represent source and target verticess of
i
-th edge (undirected) and
w
i
represents the weight of the
i
-th edge.
Output
Print the sum of the weights of the Minimum Spanning Tree.
Constraints
1 ≤
|V|
≤ 10,000
0 ≤
|E|
≤ 100,000
0 ≤
w
i
≤ 10,000
The graph is connected
There are no parallel edges
There are no self-loops
Sample Input 1
4 6
0 1 2
1 2 1
2 3 1
3 0 1
0 2 3
1 3 5
Sample Output 1
3
Sample Input 2
6 9
0 1 1
0 2 3
1 2 1
1 3 7
2 4 1
1 4 3
3 4 1
3 5 1
4 5 6
Sample Output 2
5


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq

def makeSet(x):
    p[x] = x
    rank[x] = 0

def union(x, y):
    link(findSet(x), findSet(y))

def link(x, y):
    if rank[x] > rank[y]:
        p[y] = x
    else:
        p[x] = y
        if rank[x] == rank[y]:
            rank[y] += 1

def findSet(x):
    if x != p[x]:
        p[x] = findSet(p[x])
    return p[x]

v,e = map(int, input().split())
edge = [[] for _ in range(v)]

p = [0]*v
rank = [0]*v
for x in range(v):
    makeSet(x)

S = []
ans = 0
for _ in range(e):
    s,t,w = map(int, input().split())
    heapq.heappush(S, [w, s, t])
    
while S:
    w,s,t = heapq.heappop(S)
    if findSet(s) != findSet(t):
        union(s,t)
        ans += w
print(ans)
```