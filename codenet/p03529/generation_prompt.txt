Voici un énoncé de problème :

Score :
1000
points
Problem Statement
Consider the following game:
The game is played using a row of
N
squares and many stones.
First,
a_i
stones are put in Square
i\ (1 \leq i \leq N)
.
A player can perform the following operation as many time as desired: "Select an integer
i
such that Square
i
contains exactly
i
stones. Remove all the stones from Square
i
, and add one stone to each of the
i-1
squares from Square
1
to Square
i-1
."
The final score of the player is the total number of the stones remaining in the squares.
For a sequence
a
of length
N
, let
f(a)
be the minimum score that can be obtained when the game is played on
a
.
Find the sum of
f(a)
over all sequences
a
of length
N
where each element is between
0
and
K
(inclusive).
Since it can be extremely large, find the answer modulo
1000000007 (= 10^9+7)
.
Constraints
1 \leq N \leq 100
1 \leq K \leq N
Input
Input is given from Standard Input in the following format:
N
K
Output
Print the sum of
f(a)
modulo
1000000007 (= 10^9+7)
.
Sample Input 1
2 2
Sample Output 1
10
There are nine sequences of length
2
where each element is between
0
and
2
. For each of them, the value of
f(a)
and how to achieve it is as follows:
f(\{0,0\})
:
0
(Nothing can be done)
f(\{0,1\})
:
1
(Nothing can be done)
f(\{0,2\})
:
0
(Select Square
2
, then Square
1
)
f(\{1,0\})
:
0
(Select Square
1
)
f(\{1,1\})
:
1
(Select Square
1
)
f(\{1,2\})
:
0
(Select Square
1
, Square
2
, then Square
1
)
f(\{2,0\})
:
2
(Nothing can be done)
f(\{2,1\})
:
3
(Nothing can be done)
f(\{2,2\})
:
3
(Select Square
2
)
Sample Input 2
20 17
Sample Output 2
983853488


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
import numpy as np
import numba
from numba import njit
i8 = numba.int64

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

MOD = 1_000_000_007

@njit((i8, i8), cache=True)
def main(N, K):
    power = np.zeros(N + 10, np.int64)
    power[0] = 1
    for n in range(1, N + 10):
        power[n] = power[n - 1] * (K + 1) % MOD
    ret = K * (K + 1) // 2 * N * power[N - 1] % MOD

    dp = np.array([1], np.int64)
    dp[0] = 1
    for n in range(N, 0, -1):
        newdp = np.zeros(len(dp) * (n + 1) // n + 1, np.int64)
        for k in range(K + 1):
            for t in range(len(dp)):
                if k > n:
                    x = 0
                else:
                    x = (k + t) // n
                    ret -= x * dp[t] % MOD * power[n - 1] % MOD
                newdp[t + x] += dp[t]
        dp = newdp % MOD
    return ret % MOD

N, K = map(int, read().split())

print(main(N, K))
```