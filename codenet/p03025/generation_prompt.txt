Voici un énoncé de problème :

Score :
500
points
Problem Statement
Takahashi and Aoki will play a game. They will repeatedly play it until one of them have
N
wins in total.
When they play the game once, Takahashi wins with probability
A
%, Aoki wins with probability
B
%, and the game ends in a draw (that is, nobody wins) with probability
C
%.
Find the expected number of games that will be played, and print it as follows.
We can represent the expected value as
P/Q
with coprime integers
P
and
Q
.
Print the integer
R
between
0
and
10^9+6
(inclusive) such that
R \times Q \equiv P\pmod {10^9+7}
.
(Such an integer
R
always uniquely exists under the constraints of this problem.)
Constraints
1 \leq N \leq 100000
0 \leq A,B,C \leq 100
1 \leq A+B
A+B+C=100
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
A
B
C
Output
Print the expected number of games that will be played, in the manner specified in the statement.
Sample Input 1
1 25 25 50
Sample Output 1
2
Since
N=1
, they will repeat the game until one of them wins.
The expected number of games played is
2
.
Sample Input 2
4 50 50 0
Sample Output 2
312500008
C
may be
0
.
Sample Input 3
1 100 0 0
Sample Output 3
1
B
may also be
0
.
Sample Input 4
100000 31 41 28
Sample Output 4
104136146


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# C - Best-of-(2n-1)
class Combi():
    def __init__(self, N, mod):
        self.power = [1 for _ in range(N+1)]
        self.rev = [1 for _ in range(N+1)]
        self.mod = mod
        for i in range(2, N+1):
            self.power[i] = (self.power[i-1]*i) % self.mod
        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)
        for j in range(N, 0, -1):
            self.rev[j-1] = (self.rev[j]*j) % self.mod

    def com(self, K, R):
        if K < R:
            return 0
        else:
            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod

    def pom(self, K, R):
        if K < R:
            return 0
        else:
            return (self.power[K])*(self.rev[K-R]) % self.mod

mod = 10**9 + 7
combi = Combi(2*10**5, mod)
N, A, B, C = map(int, input().split())

X = 0
Y = (100-C)*pow(A+B, 2*N-1, mod)

for i in range(N, 2*N):
    X += pow(A+B, 2*N-1-i, mod)*i*combi.com(i-1, N-1)*(pow(A, N, mod)
                                                       * pow(B, i-N, mod)+pow(B, N, mod)*pow(A, i-N, mod))
    X %= mod
X *= 100
ans = X*pow(Y, mod-2, mod) % mod
print(ans)
```