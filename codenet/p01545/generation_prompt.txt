Voici un énoncé de problème :

引越し
太郎君は引っ越しをすることになりました。太郎君はたくさんの荷物を持っているので、荷物の運搬を引っ越し業者に頼むことにしました。荷物はいろいろな重さの物があるので、わかりやすいように軽い方から順番に並べて置いてもらうように頼みましたが、引っ越し業者の人はばらばらの順番で荷物を置いていってしまいました。そこで太郎君は荷物を並べ替えようとしましたが、荷物は重いので運ぶのには体力が必要です。それぞれの荷物は今ある場所から他の荷物の間や荷物の端など好きな場所に運ぶことができますが、ある荷物を運ぶにはその荷物の重さと同じだけ体力を使います。太郎君はあまり体力がないので、できるだけ体力を使わずに荷物を軽い方から順番に並べる方法を考えることにしました。
Input
n
x
1
x
2
...
x
n
n
は太郎君の持っている荷物の数を表す
x
1
から
x
n
はそれぞれの荷物の重さを表し、現在は
x
1
、
x
2
、…、
x
n
の順に並んでいる
Constraints
1 ≤ n ≤ 10
5
1 ≤ x
i
≤ n (1 ≤ i ≤ n)
x
i
≠ x
j
(
1 ≤ i, j ≤ n
かつ
i ≠ j
)
入力はすべて整数で与えられる
Output
S
荷物を軽い方から順番に並べるのに必要な最小の体力の合計
S
を出力せよ、ただし最後に改行を出力せよ
Sample Input 1
4
1 4 2 3
Output for the Sample Input 1
4
重さ4の荷物を右端に運ぶと重さの軽い順になります
Sample Input 2
5
1 5 3 2 4
Output for the Sample Input 2
7
重さ2の荷物を重さ1の荷物の右側に運び、重さ5の荷物を右端に運ぶと重さの軽い順になります
Sample Input 3
7
1 2 3 4 5 6 7
Output for the Sample Input 3
0
最初から重さの軽い順に並んでいます
Sample Input 4
8
6 2 1 3 8 5 4 7
Output for the Sample Input 4
19


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math
import sys
if sys.version[0] == '2':
    range, input = xrange, raw_input

class FenwickTree:
    def __init__(self, a_list, f, default):
        # 0-indexed
        self.N = len(a_list)
        self.bit = a_list[:]
        self.f = f
        self.default = default
        for _ in range(self.N, 1 << int(math.ceil(math.log(self.N, 2)))):
            self.bit.append(self.default)
        for i in range(self.N - 1):
            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])

    def update(self, i, val):
        while i < self.N:
            self.bit[i] = self.f(self.bit[i], val)
            i |= i + 1

    def query(self, n):
        # [0, n]
        ret = 0
        while n >= 0:
            ret = self.f(ret, self.bit[n])
            n = (n & (n + 1)) - 1
        return ret

N = int(input())
X = [int(x) for x in input().split()]
dp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)
for x, i in sorted((x, i) for i, x in enumerate(X)):
    dp.update(i, dp.query(i) + x)
print(N * (N + 1) // 2 - dp.query(N - 1))
```