Voici un énoncé de problème :

Score :
700
points
Problem Statement
You are given an integer
N
. Determine if there exists a tree with
2N
vertices numbered
1
to
2N
satisfying the following condition, and show one such tree if the answer is yes.
Assume that, for each integer
i
between
1
and
N
(inclusive), Vertex
i
and
N+i
have the weight
i
. Then, for each integer
i
between
1
and
N
, the bitwise XOR of the weights of the vertices on the path between Vertex
i
and
N+i
(including themselves) is
i
.
Constraints
N
is an integer.
1 \leq N \leq 10^{5}
Input
Input is given from Standard Input in the following format:
N
Output
If there exists a tree satisfying the condition in the statement, print
Yes
; otherwise, print
No
.
Then, if such a tree exists, print the
2N-1
edges of such a tree in the subsequent
2N-1
lines, in the following format:
a_{1}
b_{1}
\vdots
a_{2N-1}
b_{2N-1}
Here each pair (
a_i
,
b_i
) means that there is an edge connecting Vertex
a_i
and
b_i
. The edges may be printed in any order.
Sample Input 1
3
Sample Output 1
Yes
1 2
2 3
3 4
4 5
5 6
The sample output represents the following graph:
Sample Input 2
1
Sample Output 2
No
There is no tree satisfying the condition.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n=int(input())
if n<=2 or n==4:
  print("No")
elif n==3:
  print("Yes")
  for i in range(5):
    print(i+1,i+2)
elif n%2==0:
  nn=n.bit_length()
  if n==2**(nn-1):
    print("No")
  else:
    print("Yes")
    print(1,2)
    print(2,3)
    print(3,n+1)
    print(n+1,n+2)
    print(n+2,n+3)
    for i in range(4,n):
      print(n+1,i)
      if i%2==0:
        print(i,i+n+1)
      else:
        print(i,i+n-1)
    n1,n2=2**(nn-1),(n+1)-2**(nn-1)
    print(n1,n)
    print(n2,2*n)
else:
  print("Yes")
  print(1,2)
  print(2,3)
  print(3,n+1)
  print(n+1,n+2)
  print(n+2,n+3)
  for i in range(4,n+1):
    print(1,i)
    if i%2==0:
      print(i,i+n+1)
    else:
      print(i,i+n-1)
```