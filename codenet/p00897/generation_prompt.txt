Voici un énoncé de problème :

Problem D:
Long Distance Taxi
A taxi driver, Nakamura, was so delighted because he got a passenger who wanted to go to a
city thousands of kilometers away. However, he had a problem. As you may know, most taxis in
Japan run on liquefied petroleum gas (LPG) because it is cheaper than gasoline. There are more
than 50,000 gas stations in the country, but less than one percent of them sell LPG. Although
the LPG tank of his car was full, the tank capacity is limited and his car runs 10 kilometer per
liter, so he may not be able to get to the destination without filling the tank on the way. He
knew all the locations of LPG stations.
Your task is to write a program that finds the best way from the current location to the destination without running out of gas.
Input
The input consists of several datasets, and each dataset is in the following format.
N M cap
src dest
c
1,1
c
1,2
d
1
c
2,1
c
2,2
d
2
.
.
.
c
N,1
c
N,2
d
N
s
1
s
2
.
.
.
s
M
The first line of a dataset contains three integers (
N, M, cap
), where
N
is the number of roads
(1 ≤
N
≤ 3000),
M
is the number of LPG stations (1≤
M
≤ 300), and
cap
is the tank capacity
(1 ≤
cap
≤ 200) in liter. The next line contains the name of the current city (
src
) and the name
of the destination city (
dest
). The destination city is always different from the current city.
The following
N
lines describe roads that connect cities. The road i (1 ≤
i
≤ N) connects two
different cities
c
i,1
and
c
i,2
with an integer distance
d
i
(0 <
d
i
≤ 2000) in kilometer, and he can
go from either city to the other. You can assume that no two different roads connect the same
pair of cities. The columns are separated by a single space. The next
M
lines (
s
1
,
s
2
,...,
s
M
) indicate the names of the cities with LPG station.
You can assume that a city with LPG station has at least one road.
The name of a city has no more than 15 characters. Only English alphabet ('A' to 'Z' and 'a'
to 'z', case sensitive) is allowed for the name.
A line with three zeros terminates the input.
Output
For each dataset, output a line containing the length (in kilometer) of the shortest possible
journey from the current city to the destination city. If Nakamura cannot reach the destination,
output "-1" (without quotation marks). You must not output any other characters.
The actual tank capacity is usually a little bit larger than that on the specification sheet, so
you can assume that he can reach a city even when the remaining amount of the gas becomes
exactly zero. In addition, you can always fill the tank at the destination so you do not have to
worry about the return trip.
Sample Input
6 3 34
Tokyo Kyoto
Tokyo Niigata 335
Tokyo Shizuoka 174
Shizuoka Nagoya 176
Nagoya Kyoto 195
Toyama Niigata 215
Toyama Kyoto 296
Nagoya
Niigata
Toyama
6 3 30
Tokyo Kyoto
Tokyo Niigata 335
Tokyo Shizuoka 174
Shizuoka Nagoya 176
Nagoya Kyoto 195
Toyama Niigata 215
Toyama Kyoto 296
Nagoya
Niigata
Toyama
0 0 0
Output for the Sample Input
846
-1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    rr = []

    def f(n,m,cap):
        cap *= 10
        s,t = LS()
        e = collections.defaultdict(list)
        for _ in range(n):
            a,b,c = LS()
            c = int(c)
            e[a].append((b,c))
            e[b].append((a,c))
        cs = set([S() for _ in range(m)])

        def search(s,t):
            d = collections.defaultdict(lambda: inf)
            d[(s,cap)] = 0
            q = []
            heapq.heappush(q, (0, (s,cap)))
            v = collections.defaultdict(bool)
            while len(q):
                k, u = heapq.heappop(q)
                if v[u]:
                    continue
                v[u] = True
                if u[0] == t:
                    return k

                for uv, ud in e[u[0]]:
                    uc = u[1] - ud
                    if uc < 0:
                        continue
                    if uv in cs:
                        uc = cap
                    uv = (uv, uc)
                    if v[uv]:
                        continue
                    vd = k + ud
                    if d[uv] > vd:
                        d[uv] = vd
                        heapq.heappush(q, (vd, uv))

            return None

        r = search(s,t)
        if r is None:
            return -1

        return r

    while 1:
        n,m,l = LI()
        if n == 0:
            break
        rr.append(f(n,m,l))
        # print('rr', rr[-1])

    return '\n'.join(map(str,rr))

print(main())
```