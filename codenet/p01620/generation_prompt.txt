Voici un énoncé de problème :

王様の視察
とある国の偉い王様が、突然友好国の土地を視察することになった。
その国は電車が有名で、王様はいろいろな駅を視察するという。
電車の駅は52個あり、それぞれに大文字か小文字のアルファベット1文字の名前がついている（重なっている名前はない）。
この電車の路線は環状になっていて、aの駅の次はbの駅、bの駅の次はcの駅と順に並んでいてz駅の次はA駅、その次はBの駅と順に進み、Z駅の次はa駅になって元に戻る。
単線であり、逆方向に進む電車は走っていない。
ある日、新聞社の記者が王様が訪れる駅の順番のリストを手に入れた。
「dcdkIlkP…」
最初にd駅を訪れ、次にc駅、次にd駅と順に訪れていくという。これで、偉い国の王様を追跡取材できると思った矢先、思わぬことが発覚した。そのリストは、テロ対策のため暗号化されていたのだ！記者の仲間が、その暗号を解く鍵を入手したという。早速この記者は鍵を譲ってもらい、リストの修正にとりかかった。鍵はいくつかの数字の列で構成されている。
「3 1 4 5 3」
この数字の意味するところは、はじめに訪れる駅は、リストに書いてある駅の3つ前の駅。
2番目に訪れる駅はリストの2番目の駅の前の駅、という風に、実際訪れる駅がリストの駅の何駅前かを示している。
記者は修正に取りかかったが、訪れる駅のリストの数よりも、鍵の数の方が小さい、どうするのかと仲間に聞いたところ、最後の鍵をつかったら、またはじめの鍵から順に使っていけばよいらしい。
そして記者はようやくリストを修正することができた。
「abZfFijL…」
これでもう怖い物は無いだろう、そう思った矢先、さらに思わぬ事態が発覚した。
偉い王様は何日間も滞在し、さらにそれぞれの日程ごとにリストと鍵が存在したのだ。
記者は上司から、すべてのリストを復号するように指示されたが、量が量だけに、彼一人では終わらない。
あなたの仕事は彼を助け、このリストの復号を自動で行うプログラムを作成することである。
Input
入力は複数のデータセットから構成される。各データセットの形式は次の通りである。
n
k1
k2...
kn
s
n は鍵の数を表す整数であり、1以上 100 以下と仮定して良い。
続く行には鍵のリストが記載されている。k
i
はi番目の鍵を示す。1以上52以下と仮定して良い。
sはアルファベット大文字・小文字からなる文字列で、訪れる駅のリストを示す。1文字以上100文字以下であると仮定して良い。
n=0 は入力の終わりを示す。これはデータセットには含めない。
Output
各データセットに対する復号されたリストを各1行に出力せよ。
Sample Input
2
1 2
bdd
3
3 2 1
DDDA
5
3 1 4 5 3
dcdkIlkP
0
Output for Sample Input
abc
ABCx
abZfFijL


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n2c = dict(zip(range(0,52),"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
c2n = dict(zip("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",range(0,52)))

def f(c,k):
	return n2c[(c2n[c]-k)%52]

while True:
	kl=int(raw_input())
	if kl==0: break
	ks = map(int, raw_input().split())
	oms = list(raw_input())
	nms = []
	for ki, om in enumerate(oms):
		k = ks[ki%kl]
		nm = f(om,k)
		nms.append(nm)
	print "".join(nms)
```