Voici un énoncé de problème :

E： たい焼きマスターと食べ盛り - Taiyaki-Master and Eater
物語
つたさんはたい焼きを作るのがとても上手い。えびちゃんはそんなつたさんが作るたい焼きが大好きだ。
2
人は毎週たい焼きを作って食べて幸せに過ごしているが、たい焼きを作っているそばで食べ盛りのえびちゃんにつまみ食いをされてしまうのがつたさんの最近の悩みだ。
学校祭でたい焼きを作ることになったつたさんは、いつものようにえびちゃんにつまみ食いされていたら売上が心配なので、自分が注目している範囲のたい焼きの様子を知ることができればいいなと思った。学校祭が成功するように、つたさんを助けてあげよう。
問題
縦
H
、横
W
の長方形状のたい焼きプレートがあり、たい焼きをセットしてから焼き上がるまでに
T
分かかる。このプレートはたい焼きを一度に最大
HW
個焼くことができ、プレートの上から
i
(1 \leq i \leq H)
番目で左から
j
(1 \leq j \leq W)
番目の場所で焼いているたい焼きは
(i, j)
で表される。
次の
3
種類のイベントが合計
Q
回発生する。なお、初期状態ではたい焼きはいずれの場所にもセットされていない。
時刻
t
につたさんが
(h, w)
にたい焼きを
1
つセットする。そのたい焼きは
T
分で焼き上がり、時刻
t+T
の時点で食べることができるようになる。ただし、すでにたい焼きがセットされている場所にたい焼きをセットすることはない。
時刻
t
に、えびちゃんが
(h, w)
にあるたい焼きをつまみ食いしようとする。ただし、
つまみ食いできるのはすでに焼き上がったたい焼きのみである
。つまみ食いした後はその場所からたい焼きが無くなる (すなわち、たい焼きがセットされていない状態になる)。たい焼きが焼き上がっていない、またはたい焼きがない場所にもつまみ食いのイベントが発生する場合があることに注意せよ。
左上が
(h_1, w_1)
、右下が
(h_2, w_2)
となるような長方形領域内 (
(h_1, w_1)
および
(h_2, w_2)
を含む) のたい焼きについて、次の数が時刻
t
の時点でそれぞれいくつであるかをつたさんがカウントする。
すでに焼き上がったたい焼きの数
まだ焼き上がっていないたい焼きの数
入力形式
H
W
T
Q
t_1
c_1
h_{11}
w_{11}
(h_{12}
w_{12})
t_2
c_2
h_{21}
w_{21}
(h_{22}
w_{22})
…
t_Q
c_Q
h_{Q1}
w_{Q1}
(h_{Q2}
w_{Q2})
入力は全て整数で与えられる。
1
行目には、たい焼きプレートの縦
H
、 横
W
、 たい焼きをセットしてから焼きあがるまでの時間
T
、 イベントの数
Q
が与えられる。
1+i
(1 \leq i \leq Q)
行目には、時刻
t_i
で発生したイベントの内容が与えられる。
c_i
はイベントの種類を表す。この値が
0
ならばたい焼きをセットするイベント、
1
ならばつまみ食いをするイベント、
2
ならばたい焼きをカウントするイベントを指す。
h_{i1}
(1 \leq h_{i1} \leq H)
、
w_{i1}
(1 \leq w_{i1} \leq W)
は、
c_i = 0, 1
において次のような意味である。
c_i = 0
のとき、
(h_{i1}, w_{i1})
の場所にたい焼きを1つセットする。
c_i = 1
のとき、
(h_{i1}, w_{i1})
の場所に焼き上がった状態のたい焼きがあればつまみ食いをし、そうでなければ何もしない。
h_{i2}
、
w_{i2}
は、
c_i = 2
のときのみ与えられる。
c_i = 2
のとき、左上を
(h_{i1}, w_{i1})
、 右下を
(h_{i2}, w_{i2})
とする長方形領域内のたい焼きについてカウントする。
入出力が非常に多くなることが予想されるため、入出力に遅い関数を使っている場合は注意してください。
制約
1 \leq H \leq 2 \times 10^3
1 \leq W \leq 2 \times 10^3
1 \leq T \leq 10^9
1 \leq Q \leq 10^5
1 \leq t_i \leq 10^9
i \lt j
ならば、
t_i \lt t_j
0 \leq c_i \leq 2
1 \leq h_{i1} \leq h_{i2} \leq H
1 \leq w_{i1} \leq w_{i2} \leq W
出力形式
(
c_i = 2
(1 \leq i \leq Q)
の個数) を
n
とする。たい焼きのカウントの結果を、次の書き方に従ってイベントの発生時間が早い順に
n
行に出力せよ。
a_1
b_1
a_2
b_2
…
a_n
b_n
a_i
は、領域内にある「焼き上がったたい焼きの数」である。
b_i
は、領域内にある「まだ焼き上がっていないたい焼きの数」である。
末尾の改行を忘れないこと。
入力例1
3 3 3 6
1 0 1 1
2 2 1 1 2 2
3 1 1 1
4 0 2 1
5 2 1 1 2 2
6 2 2 1 3 3
出力例1
0 1
1 1
0 1
この入出力例では以下のイベントが発生している。
時刻
1
分に、
(1, 1)
にたい焼きをセットする。このたい焼きは時刻
4
分に焼き上がる。
時刻
2
分に、左上
(1, 1)
、右下
(2, 2)
の長方形領域にあるたい焼きをカウントする。
(1, 1)
にセットしたたい焼きはまだ焼き上がっていないため、
0 1
を出力する。
時刻
3
分に、
(1, 1)
にあるたい焼きをつまみ食いしようとするが、まだ焼き上がっていないので何もしない。
時刻
4
分に、
(2, 1)
にたい焼きをセットする。このたい焼きは時刻
7
分に焼き上がる。
時刻
5
分に、左上
(1, 1)
、右下
(2, 2)
の長方形領域にあるたい焼きをカウントする。
(1, 1)
のたい焼きは焼き上がっており、
(2, 1)
のたい焼きはまだ焼き上がっていないため、
1 1
を出力する。
時刻
6
分に、左上
(2, 1)
、右下
(3, 3)
の長方形領域にあるたい焼きをカウントする。
(2, 1)
のたい焼きはまだ焼き上がっていないため、
0 1
を出力する。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
class fenwick_tree_2d:
    def __init__(self, h, w):
        self.H = h
        self.W = w
        self.tree = [[0]*(w+1) for _ in range(h+1)]

    def init_array(self, A):
        for i in range(self.H):
            for j in range(self.W):
                self.add(i+1, j+1, A[i][j])

    def add(self, i, j, x):
        if i <= 0 or j <= 0:
            raise IndexError
        while i <= self.H:
            k = j
            while k <= self.W:
                self.tree[i][k] += x
                k += k & -k
            i += i & -i

    def sum_until(self, i, j):
        if i < 0 or j < 0:
            raise IndexError
        s = 0
        while i > 0:
            k = j
            while k > 0:
                s += self.tree[i][k]
                k -= k & -k
            i -= i & -i
        return s

    def sum_acc(self, h1, h2, w1, w2):
        """
        0 <= h1 < h2 <= H
        0 <= w1 < w2 <= W
        [h1,h2) * [w1,w2) の長方形区域の値の総和を返す
        """
        return self.sum_until(h2, w2) - self.sum_until(h2, w1) \
            - self.sum_until(h1, w2) + self.sum_until(h1, w1)

def main():
    import sys
    input = sys.stdin.buffer.readline
    from collections import deque
    H, W, T, Q = (int(i) for i in input().split())
    taikaki_set = fenwick_tree_2d(H, W)
    taikaki_baked = fenwick_tree_2d(H, W)

    Query_t = deque([])
    Query_h = deque([])
    Query_w = deque([])
    for _ in range(Q):
        t, c, *A = (int(i) for i in input().split())
        while Query_t and Query_t[0] <= t:
            Query_t.popleft()
            th = Query_h.popleft()
            tw = Query_w.popleft()
            taikaki_set.add(th, tw, -1)
            taikaki_baked.add(th, tw, 1)
        if c == 0:
            (h, w) = A
            taikaki_set.add(h, w, 1)
            Query_t.append(t+T)
            Query_h.append(h)
            Query_w.append(w)
        elif c == 1:
            (h, w) = A
            cur = taikaki_baked.sum_acc(h-1, h, w-1, w)
            if 0 < cur:
                taikaki_baked.add(h, w, -1)
        else:
            (h1, w1, h2, w2) = A
            baked = taikaki_baked.sum_acc(h1-1, h2, w1-1, w2)
            t_set = taikaki_set.sum_acc(h1-1, h2, w1-1, w2)
            print(baked, t_set)

if __name__ == '__main__':
    main()
```