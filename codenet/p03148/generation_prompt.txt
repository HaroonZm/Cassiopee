Voici un énoncé de problème :

Score :
400
points
Problem Statement
There are
N
pieces of sushi. Each piece has two parameters: "kind of topping"
t_i
and "deliciousness"
d_i
.
You are choosing
K
among these
N
pieces to eat.
Your "satisfaction" here will be calculated as follows:
The satisfaction is the sum of the "base total deliciousness" and the "variety bonus".
The base total deliciousness is the sum of the deliciousness of the pieces you eat.
The variety bonus is
x*x
, where
x
is the number of different kinds of toppings of the pieces you eat.
You want to have as much satisfaction as possible.
Find this maximum satisfaction.
Constraints
1 \leq K \leq N \leq 10^5
1 \leq t_i \leq N
1 \leq d_i \leq 10^9
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
K
t_1
d_1
t_2
d_2
.
.
.
t_N
d_N
Output
Print the maximum satisfaction that you can obtain.
Sample Input 1
5 3
1 9
1 7
2 6
2 5
3 1
Sample Output 1
26
If you eat Sushi
1,2
and
3
:
The base total deliciousness is
9+7+6=22
.
The variety bonus is
2*2=4
.
Thus, your satisfaction will be
26
, which is optimal.
Sample Input 2
7 4
1 1
2 1
3 1
4 6
4 5
4 5
4 5
Sample Output 2
25
It is optimal to eat Sushi
1,2,3
and
4
.
Sample Input 3
6 5
5 1000000000
2 990000000
3 980000000
6 970000000
6 960000000
4 950000000
Sample Output 3
4900000016
Note that the output may not fit into a
32
-bit integer type.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq

def main():
    num_sushi, chose_num = map(int, input().split())
    data = [list(map(int, input().split())) for i in range(num_sushi)]

    data.sort(key=lambda x: -x[1])
    delicious_heap = []
    count_d, count_n = 0, 0
    neta_data = [0 for i in range(num_sushi + 1)]

    for i in range(chose_num):
        neta, oishisa = data[i]

        if neta_data[neta]:
            heapq.heappush(delicious_heap, oishisa)
        else:
            neta_data[neta] = 1
            count_n += 1

        count_d += oishisa

    ans = count_d + count_n ** 2

    for i in range(chose_num, num_sushi):
        if len(delicious_heap) == 0:
            break
        neta, oishisa = data[i]

        if neta_data[neta]:
            continue
        neta_data[neta] = 1
        count_n += 1
        pop_oishisa = heapq.heappop(delicious_heap)
        count_d += oishisa - pop_oishisa

        ans = max(ans, count_d + count_n ** 2)

    print(ans)

if __name__ == '__main__':
    main()
```