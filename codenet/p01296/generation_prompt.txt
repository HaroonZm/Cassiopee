Voici un énoncé de problème :

Problem D:
Futon
The sales department of Japanese Ancient Giant Corp. is visiting a hot spring resort for their
recreational trip. For deepening their friendships, they are staying in one large room of a
Japanese-style hotel called a ryokan.
In the ryokan, people sleep in Japanese-style beds called futons. They all have put their futons
on the floor just as they like. Now they are ready for sleeping but they have one concern: they
don’t like to go into their futons with their legs toward heads — this is regarded as a bad custom
in Japanese tradition. However, it is not obvious whether they can follow a good custom. You
are requested to write a program answering their question, as a talented programmer.
Here let's model the situation. The room is considered to be a grid on an
xy
-plane. As usual,
x
-axis points toward right and
y
-axis points toward up. Each futon occupies two adjacent cells.
People put their pillows on either of the two cells. Their heads come to the pillows; their foots
come to the other cells. If the cell of some person's foot becomes adjacent to the cell of another
person's head, regardless their directions, then it is considered as a bad case. Otherwise people
are all right.
Input
The input is a sequence of datasets. Each dataset is given in the following format:
n
x
1
y
1
dir
1
...
x
n
y
n
dir
n
n
is the number of futons (1 ≤
n
≤ 20,000); (
x
i
,
y
i
) denotes the coordinates of the left-bottom
corner of the
i
-th futon;
dir
i
is either '
x
' or '
y
' and denotes the direction of the
i
-th futon,
where '
x
' means the futon is put horizontally and '
y
' means vertically. All coordinate values are
non-negative integers not greater than 10
9
.
It is guaranteed that no two futons in the input overlap each other.
The input is terminated by a line with a single zero. This is not part of any dataset and thus
should not be processed.
Output
For each dataset, print "
Yes
" in a line if it is possible to avoid a bad case, or "
No
" otherwise.
Sample Input
4
0 0 x
2 0 x
0 1 x
2 1 x
4
1 0 x
0 1 x
2 1 x
1 2 x
4
0 0 x
2 0 y
0 1 y
1 2 x
0
Output for the Sample Input
Yes
No
Yes


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    rr = []

    while True:
        n = I()
        if n == 0:
            break

        a = [LS() for _ in range(n)]
        d = collections.defaultdict(int)
        ed = collections.defaultdict(lambda: None)
        for i in range(n):
            x, y, di = a[i]
            x = int(x)
            y = int(y)
            d[(x,y)] = i + 1
            if di == 'x':
                d[(x+1,y)] = i + 1
                ed[(x,y)] = (x+1,y)
                ed[(x+1,y)] = (x,y)
            else:
                d[(x,y+1)] = i + 1
                ed[(x,y)] = (x,y+1)
                ed[(x,y+1)] = (x,y)

        ee = collections.defaultdict(set)
        dka = list(d.keys())
        for x,y in list(d.keys()):
            dt = d[(x,y)]
            for di,dj in dd:
                ni = x + di
                nj = y + dj
                if d[(ni,nj)] > 0 and d[(ni,nj)] != dt:
                    ee[(x,y)].add((ni,nj))

        v = collections.defaultdict(bool)
        f = True
        for k in dka:
            if v[k]:
                continue
            s1 = set()
            s2 = set()
            ns1 = set([k])
            ns2 = set()
            while ns1:
                na = list(ns1)
                s1 |= ns1
                ns1 = set()
                for k in na:
                    ns1 |= ee[k]
                    ns2.add(ed[k])
                ns2 -= s2

                while ns2:
                    na = list(ns2)
                    s2 |= ns2
                    ns2 = set()
                    for k in na:
                        ns2 |= ee[k]
                        ns1.add(ed[k])
                    ns2 -= s2

                ns1 -= s1

            if s1 & s2:
                f = False
            # print('k', k)
            # print('s1', s1)
            # print('s2', s2)

            if f:
                for k in s1:
                    v[k] = 1
                for k in s2:
                    v[k] = 1
            else:
                break

        if f:
            rr.append('Yes')
        else:
            rr.append('No')

    return '\n'.join(map(str,rr))

print(main())
```