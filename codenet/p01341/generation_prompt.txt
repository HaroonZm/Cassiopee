En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
class UnionFind:
    def __init__(self, n):
        self.data=[-1 for i in range(n)]

    def root(self,x):
        if self.data[x]<0:
            return x
        else:
            self.data[x]=self.root(self.data[x])
            return self.data[x]

    def uni(self,x,y):
        x=self.root(x)
        y=self.root(y)
        if(x==y):
            return
        if self.data[y]<self.data[x]:
            x,y=y,x
        self.data[x]+= self.data[y]
        self.data[y] = x

    def same(self,x,y):
        return self.root(x)==self.root(y)

    def size(self,x):
        return -self.data[self.root(x)]

n,m=map(int,input().split())
uf=UnionFind(n)
cd=[]
g=[[] for i in range(n)]
sm=0.0
for i in range(n):
    cd.append(tuple(map(int,input().split())))
f=0
for j in range(m):
    p,q=map(int,input().split())
    p,q=p-1,q-1
    uf.uni(p,q)
    f=p
    g[p].append((-((cd[p][0]-cd[q][0])**2+(cd[p][1]-cd[q][1])**2)**0.50,q))
    g[q].append((-((cd[p][0]-cd[q][0])**2+(cd[p][1]-cd[q][1])**2)**0.50,p))
    sm+=((cd[p][0]-cd[q][0])**2+(cd[p][1]-cd[q][1])**2)**0.50

from heapq import heappush, heappop, heapify
used = [0 for i in range(n)]
ans = 0
for i in range(n):
    if uf.data[i]>=0:
        continue
    que = [(c, w) for c, w in g[i]]
    used[i] = 1
    heapify(que)
    while que:
        cv, v = heappop(que)
        if used[v]:
            continue
        used[v] = 1
        ans -= cv
        for c, w in g[v]:
            if used[w]:
                continue
            heappush(que, (c, w))

print(sm-ans)
```