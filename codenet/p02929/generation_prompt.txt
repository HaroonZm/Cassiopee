Voici un énoncé de problème :

Score :
500
points
Problem Statement
There are
2N
squares arranged from left to right. You are given a string of length
2N
representing the color of each of the squares.
The color of the
i
-th square from the left is black if the
i
-th character of
S
is
B
, and white if that character is
W
.
You will perform the following operation exactly
N
times: choose two distinct squares, then invert the colors of these squares and the squares between them. Here, to invert the color of a square is to make it white if it is black, and vice versa.
Throughout this process, you cannot choose the same square twice or more. That is, each square has to be chosen exactly once.
Find the number of ways to make all the squares white at the end of the process, modulo
10^9+7
.
Two ways to make the squares white are considered different if and only if there exists
i
(1 \leq i \leq N)
such that the pair of the squares chosen in the
i
-th operation is different.
Constraints
1 \leq N \leq 10^5
|S| = 2N
Each character of
S
is
B
or
W
.
Input
Input is given from Standard Input in the following format:
N
S
Output
Print the number of ways to make all the squares white at the end of the process, modulo
10^9+7
. If there are no such ways, print
0
.
Sample Input 1
2
BWWB
Sample Output 1
4
There are four ways to make all the squares white, as follows:
Choose Squares
1, 3
in the first operation, and choose Squares
2, 4
in the second operation.
Choose Squares
2, 4
in the first operation, and choose Squares
1, 3
in the second operation.
Choose Squares
1, 4
in the first operation, and choose Squares
2, 3
in the second operation.
Choose Squares
2, 3
in the first operation, and choose Squares
1, 4
in the second operation.
Sample Input 2
4
BWBBWWWB
Sample Output 2
288
Sample Input 3
5
WWWWWWWWWW
Sample Output 3
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import bisect
import heapq
import math
import random
import sys
from collections import Counter, defaultdict, deque
from decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal
from functools import lru_cache, reduce
from itertools import combinations, combinations_with_replacement, product, permutations
from operator import add, mul, sub

sys.setrecursionlimit(100000)
input = sys.stdin.readline

def read_int():
    return int(input())

def read_int_n():
    return list(map(int, input().split()))

def read_float():
    return float(input())

def read_float_n():
    return list(map(float, input().split()))

def read_str():
    return input().strip()

def read_str_n():
    return list(map(str, input().split()))

def error_print(*args):
    print(*args, file=sys.stderr)

def mt(f):
    import time

    def wrap(*args, **kwargs):
        s = time.time()
        ret = f(*args, **kwargs)
        e = time.time()

        error_print(e - s, 'sec')
        return ret

    return wrap

class Mod:
    def __init__(self, m):
        self.m = m

    def add(self, a, b):
        return (a + b) % self.m

    def sub(self, a, b):
        return (a - b) % self.m

    def mul(self, a, b):
        return ((a % self.m) * (b % self.m)) % self.m

    def div(self, a, b):
        return self.mul(a, pow(b, self.m-2, self.m))

    def pow(self, a, b):
        return pow(a, b, self.m)

@mt
def slv(N, S):
    if S[0] != 'B' or S[-1] != 'B':
        return 0

    LR = [''] * N * 2
    l = 0
    ans = 1
    M = Mod(10**9+7)
    for i in range(2*N):
        if S[i] == 'B':
            if l % 2 == 0:
                LR[i] = 'L'
                l += 1
            else:
                LR[i] = 'R'
                ans = M.mul(ans, l)
                l -= 1

        else:
            if l % 2 == 0:
                LR[i] = 'R'
                ans = M.mul(ans, l)
                l -= 1
            else:
                LR[i] = 'L'
                l += 1

    C = Counter(LR)
    if C['L'] != C['R']:
        return 0

    for i in range(1, N+1):
        ans = ans = M.mul(ans, i)

    return ans

def main():
    N = read_int()
    S = read_str()
    print(slv(N, S))

if __name__ == '__main__':
    main()
```