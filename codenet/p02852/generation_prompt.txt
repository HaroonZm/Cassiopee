Voici un énoncé de problème :

Score :
600
points
Problem Statement
Takahashi is playing a board game called Sugoroku.
On the board, there are
N + 1
squares numbered
0
to
N
. Takahashi starts at Square
0
, and he has to stop exactly at Square
N
to win the game.
The game uses a roulette with the
M
numbers from
1
to
M
. In each turn, Takahashi spins the roulette. If the number
x
comes up when he is at Square
s
, he moves to Square
s+x
. If this makes him go beyond Square
N
, he loses the game.
Additionally, some of the squares are Game Over Squares. He also loses the game if he stops at one of those squares. You are given a string
S
of length
N + 1
, representing which squares are Game Over Squares. For each
i
(0 \leq i \leq N)
, Square
i
is a Game Over Square if
S[i] = 1
and not if
S[i] = 0
.
Find the sequence of numbers coming up in the roulette in which Takahashi can win the game in the fewest number of turns possible. If there are multiple such sequences, find the lexicographically smallest such sequence. If Takahashi cannot win the game, print
-1
.
Constraints
1 \leq N \leq 10^5
1 \leq M \leq 10^5
|S| = N + 1
S
consists of
0
and
1
.
S[0] =
0
S[N] =
0
Input
Input is given from Standard Input in the following format:
N
M
S
Output
If Takahashi can win the game, print the lexicographically smallest sequence among the shortest sequences of numbers coming up in the roulette in which Takahashi can win the game, with spaces in between.
If Takahashi cannot win the game, print
-1
.
Sample Input 1
9 3
0001000100
Sample Output 1
1 3 2 3
If the numbers
1
,
3
,
2
,
3
come up in this order, Takahashi can reach Square
9
via Square
1
,
4
, and
6
. He cannot reach Square
9
in three or fewer turns, and this is the lexicographically smallest sequence in which he reaches Square
9
in four turns.
Sample Input 2
5 4
011110
Sample Output 2
-1
Takahashi cannot reach Square
5
.
Sample Input 3
6 6
0101010
Sample Output 3
6


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
class SegmentTree():
    """一点更新、区間取得クエリをそれぞれO(logN)で答えるデータ構造を構築する。
    built(array)   := arrayを初期値とするセグメント木を構築する O(N)。
    update(i, val) := i番目の要素をvalに変更する。
    get_val(l, r)  := 区間[l, r)に対する二項演算の畳み込みの結果を返す。
    """
    def __init__(self, n, op, e):
        """要素数、二項演算、単位元を引数として渡す
        例) 区間最小値 SegmentTree(n, min, 10 ** 18)
            区間和     SegmentTree(n, lambda a, b : a + b, 0)
        """
        self.n = n
        self.op = op
        self.e = e
        self.size = 2 ** ((n - 1).bit_length())
        self.node = [self.e] * (2 * self.size)

    def built(self, array):
        """arrayを初期値とするセグメント木を構築する"""
        for i in range(self.n):
            self.node[self.size + i] = array[i]
        for i in range(self.size - 1, 0, -1):
            self.node[i] = self.op(self.node[i << 1], self.node[(i << 1) + 1])

    def update(self, i, val):
        """i番目の要素をvalに変更する"""
        i += self.size
        self.node[i] = val
        while i > 1:
            i >>= 1
            self.node[i] = self.op(self.node[i << 1], self.node[(i << 1) + 1])

    def get_val(self, l, r):
        """[l, r)の畳み込みの結果を返す"""
        l, r = l + self.size, r + self.size
        res_l, res_r = self.e, self.e
        while l < r:
            if l & 1:
                res_l = self.op(res_l, self.node[l])
                l += 1
            if r & 1:
                r -= 1
                res_r = self.op(self.node[r], res_r)
            l, r = l >> 1, r >> 1
        return self.op(res_l, res_r)

n, m = map(int, input().split())
s = input()
INF = 10 ** 18

st = SegmentTree(n + 1, min, INF)
st.update(n, 0)

for i in range(n)[::-1]:
    if s[i] == "1":
        continue
    tmp = st.get_val(i + 1, min(i + 1 + m, n + 1)) + 1
    st.update(i, tmp)

if st.get_val(0, 1) >= INF:
    print(-1)
    exit()

ans = []
ind = 0
for i in range(n + 1):
    if st.get_val(ind, ind + 1) - 1 == st.get_val(i, i + 1):
        ans.append(i - ind)
        ind = i
print(*ans)
```