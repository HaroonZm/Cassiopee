Voici un énoncé de problème :

Railroad Conflict
Nate U. Smith は大都市圏の鉄道会社を経営している．この大都市圏には，彼の鉄道会社以外にライバルの鉄道会社がある．2 社は互いに競合関係にある．
この大都市圏では，列車の運行を容易にするため，全ての路線は両端の駅を結んだ線分を経路としている．また，踏切等の設置をさけるため，全ての路線は高架または地下に敷設されている．既存路線は，全線にわたって高架を走るか，または全線にわたって地下を走るかのいずれかである．
ところで，最近，この大都市圏にある 2 つの街区 A，B がさかんに開発されていることから，Nate の会社ではこれらの街区の間に新しい路線を設けることを決断した．この新路線は，従来の路線と同様に A，B を両端とする線分を経路としたいが，経路の途中には別の路線があることから，高架あるいは地下のいずれかに全線を敷設することは不可能である．そこで，路線の一部を高架に，残りの部分を地下に敷設することにした．このとき，新路線が自社の既存路線と交わるところでは，新路線と既存路線との間の乗り継ぎを便利にするため，既存路線が高架ならば新路線も高架に，既存路線が地下ならば新路線も地下を走るようにする．また，新路線が他社の既存路線と交わるところでは，他社による妨害をさけるため，既存路線が高架ならば新路線は地下に，既存路線が地下ならば新路線は高架を走るようにする．A 駅および B 駅をそれぞれ高架あるいは地下のいずれに設けるかは特に問わない．
当然のことながら，新路線が高架から地下に，あるいは地下から高架に移るところには出入口を設けなければならない．ところが，出入口を設けるためには費用がかかるため，新路線に設ける出入口の個数は最小限に抑えたい．それには，プログラマであるあなたの助けを要すると考えた Nate は，あなたを彼の会社に呼び出した．
あなたの仕事は，A 駅，B 駅の位置，そして既存路線に関する情報が与えられたときに，新路線において最低限設けなければならない出入口の個数を求めるプログラムを作成することである．
以下の図は，サンプルとして与えた入力および出力の内容を示したものである．
Input
入力の先頭行には単一の正の整数が含まれ，これはデータセットの個数を表す．それぞれのデータセットは次の形式で与えられる．
xa
ya
xb
yb
n
xs
1
ys
1
xt
1
yt
1
o
1
l
1
xs
2
ys
2
xt
2
yt
2
o
2
l
2
...
xs
n
ys
n
xt
n
yt
n
o
n
l
n
ただし，(
xa
,
ya
) および (
xb
,
yb
) はそれぞれ A 駅，B 駅の座標を表す．
N
は既存路線の数を表す 100 以下の正の整数である．(
xs
i
,
ys
i
) および (
ys
i
,
yt
i
) は
i
番目の既存路線における始点および終点の座標を表す．
o
i
は
i
番目の既存路線の所有者を表す整数である．これは 1 または 0 のいずれかであり，1 はその路線が自社所有であることを，0 は他社所有であることをそれぞれ表す．
l
i
は
i
番目の既存路線が高架または地下のいずれにあるかを表す整数である．これも 1 または 0 のいずれかであり，1 はその路線が高架にあることを，0 は地下にあることをそれぞれ表す．
入力中に現れる x 座標および y 座標の値は -10000 から 10000 の範囲にある（両端も範囲に含まれる）．また，それぞれのデータセットにおいて，新路線を含めた全ての路線に対して，以下の条件を満たすと仮定してよい．ここで 2 点が非常に近いとは，その 2 点間の距離が 10
-9
以下であることを表す．
ある交点の非常に近くに別の交点があることはない．
ある路線の端点の非常に近くを別の路線が通ることはない．
2 つの路線の一部または全部が重なることはない．
Output
それぞれのデータセットに対して，最低限設けなければならない出入口の個数を 1 行に出力しなさい．
Sample Input
2
-10 1 10 1
4
-6 2 -2 -2 0 1
-6 -2 -2 2 1 0
6 2 2 -2 0 0
6 -2 2 2 1 1
8 12 -7 -3
8
4 -5 4 -2 1 1
4 -2 4 9 1 0
6 9 6 14 1 1
-7 6 7 6 0 0
1 0 1 10 0 0
-5 0 -5 10 0 1
-7 0 7 0 0 1
-1 0 -1 -5 0 1
Output for the Sample Input
1
3


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python

from collections import deque
import itertools as it
import sys
import math

sys.setrecursionlimit(10000000)

def in_sec(a, b, c):
    return min(a, b) <= c <= max(a, b)

q = input()

for loop in range(q):
    x0, y0, x1, y1 = map(int, raw_input().split())
    n = input()
    ls = []
    for i in range(n):
        x2, y2, x3, y3, o, l = map(int, raw_input().split())
        flag = (o + l) % 2
        #(y1 - y0)(x - x0) = (x1 - x0)(y - y0)
        a1, b1, c1 = [y1 - y0, x0 - x1, x0 * (y1 - y0) - y0 * (x1 - x0)]
        a2, b2, c2 = [y3 - y2, x2 - x3, x2 * (y3 - y2) - y2 * (x3 - x2)]
        det = a1 * b2 - b1 * a2
        if det == 0:
            dx, dy = [x2 - x0, y2 - y0]
            if dx * a1 + dy * b1 != 0:
                pass
            elif max(x0, x1) < min(x2, x3) or max(x2, x3) < min(x0, x1) \
                or max(y0, y1) < min(y2, y3) or max(y2, y3) < min(y0, y1):
                pass
            else:
                p = [(x0, y0), (x1, y1), (x2, y2), (x3, y3)]
                ls += [(p[i], flag) for i in range(4) for j in range(4) if p[i] == p[j]]
            continue
        
        xdet = c1 * b2 - c2 * b1
        ydet = c2 * a1 - c1 * a2
        if in_sec(det * x0, det * x1, xdet) and in_sec(det * y0, det * y1, ydet) \
            and in_sec(det * x2, det * x3, xdet) and in_sec(det * y2, det * y3, ydet):
            det = float(det)
            ls += [((xdet / det, ydet / det), flag)]
    ls.sort()
    ans = 0
    for i in range(len(ls) - 1):
        if ls[i][1] != ls[i + 1][1]:
            ans += 1
    print ans
```