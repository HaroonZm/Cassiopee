Voici un énoncé de problème :

Score :
800
points
Problem Statement
There is a directed graph with
N
vertices and
N
edges. The vertices are numbered
1, 2, ..., N
.
The graph has the following
N
edges:
(p_1, 1), (p_2, 2), ..., (p_N, N)
, and the graph is weakly connected. Here, an edge from Vertex
u
to Vertex
v
is denoted by
(u, v)
, and a weakly connected graph is a graph which would be connected if each edge was bidirectional.
We would like to assign a value to each of the vertices in this graph so that the following conditions are satisfied. Here,
a_i
is the value assigned to Vertex
i
.
Each
a_i
is a non-negative integer.
For each edge
(i, j)
,
a_i \neq a_j
holds.
For each
i
and each integer
x(0 ≤ x < a_i)
, there exists a vertex
j
such that the edge
(i, j)
exists and
x = a_j
holds.
Determine whether there exists such an assignment.
Constraints
2 ≤ N ≤ 200
000
1 ≤ p_i ≤ N
p_i \neq i
The graph is weakly connected.
Input
Input is given from Standard Input in the following format:
N
p_1
p_2
...
p_N
Output
If the assignment is possible, print
POSSIBLE
; otherwise, print
IMPOSSIBLE
.
Sample Input 1
4
2 3 4 1
Sample Output 1
POSSIBLE
The assignment is possible: {
a_i
} = {
0, 1, 0, 1
} or {
a_i
}
=
{
1, 0, 1, 0
}.
Sample Input 2
3
2 3 1
Sample Output 2
IMPOSSIBLE
Sample Input 3
4
2 3 1 1
Sample Output 3
POSSIBLE
The assignment is possible: {
a_i
}
=
{
2, 0, 1, 0
}.
Sample Input 4
6
4 5 6 5 6 4
Sample Output 4
IMPOSSIBLE


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
sys.setrecursionlimit(10**6)
n = int(input())
p = list(map(int, input().split()))
c = [[] for _ in range(n)]
is_leaf = [True for _ in range(n)]
for i in range(n):
	p[i] -= 1
	c[p[i]].append(i)
	is_leaf[p[i]] = False

if sum(is_leaf) == 0:
	if n%2 == 0:
		print("POSSIBLE")
	else:
		print("IMPOSSIBLE")
	sys.exit()

for i in range(n):
	if is_leaf[i]:
		cur = i
		break

visited_set = {cur}
visited_list = [cur]
while p[cur] not in visited_set:
	visited_list.append(p[cur])
	visited_set.add(p[cur])
	cur = p[cur]

root = p[cur]

grundy = [-1 for _ in range(n)]
g_set = [set() for _ in range(n)]

def dfs(x):
	res = 0
	for v in c[x]:
		dfs(v)
		g_set[x].add(grundy[v])
	while res in g_set[x]:
		res += 1
	grundy[x] = res
	return res

loop = [False for _ in range(n)]
loop[root] = True
ind = len(visited_list)-1
while visited_list[ind] != root:
	loop[visited_list[ind]] = True
	ind -= 1
#print(loop)

for i in range(n):
	if loop[i]:
		for x in c[i]:
			if not loop[x]:
				dfs(x)
				g_set[i].add(grundy[x])

cand = []
num = 0
while num in g_set[root]:
	num += 1
cand.append(num)
num += 1
while num in g_set[root]:
	num += 1
cand.append(num)

for x in cand:
	cur = root
	grundy[root] = x
	while True:
		num = 0
		while num in g_set[p[cur]] or num == grundy[cur]:
			num += 1
		grundy[p[cur]] = num
		if p[cur] == root:
			break
		cur = p[cur]
	if grundy[root] == x:
		#print(grundy)
		print("POSSIBLE")
		sys.exit()

print("IMPOSSIBLE")
```