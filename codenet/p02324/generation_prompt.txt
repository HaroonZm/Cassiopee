Voici un énoncé de problème :

Chinese Postman Problem
For a given weighted undirected graph
G(V, E)
, find the distance of the shortest route that meets the following criteria:
It is a closed cycle where it ends at the same point it starts.
The route must go through every edge at least once.
Input
|V|
|E|
s
0
t
0
d
0
s
1
t
1
d
1
:
s
|E|-1
t
|E|-1
d
|E|-1
, where
|V|
is the number of vertices and
|E|
is the number of edges in the graph. The graph vertices are named with the numbers 0, 1,...,
|V|
-1 respectively.
s
i
and
t
i
represent source and target verticess of
i
-th edge (undirected) and
d
i
represents the distance between
s
i
and
t
i
(the
i
-th edge).
Note that there can be multiple edges between a pair of vertices.
Output
Print the shortest distance in a line.
Constraints
2 ≤
|V|
≤ 15
0 ≤
|E|
≤ 1,000
0 ≤
d
i
≤ 1,000
s
i
≠
t
i
The graph is connected
Sample Input 1
4 4
0 1 1
0 2 2
1 3 3
2 3 4
Sample Output 1
10
Sample Input 2
4 5
0 1 1
0 2 2
1 3 3
2 3 4
1 2 5
Sample Output 2
18
Sample Input 3
2 3
0 1 1
0 1 2
0 1 3
Sample Output 3
7


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#! /usr/bin/python

"""Chinese Postman Problem."""

import sys

f_i = sys.stdin

V, E = map(int, f_i.readline().split())

# adjacency matrix
no_edge = 14001

adj = [[no_edge] * V for i in range(V)]

for i in range(V):
    adj[i][i] = 0

odd_b = 0 # bit DP to record odd vertex

ans = 0

# acceptance of input
for l_i in f_i:
    s, t, d = map(int, l_i.split())
    t_d = min(d, adj[s][t])
    adj[s][t] = t_d
    adj[t][s] = t_d
    odd_b ^= 1 << s
    odd_b ^= 1 << t
    ans += d

# A function to check if the number of 1 is odd in binary notation
def odd_one(n):
    ans = 0
    while n:
        ans ^= (n & 1)
        n >>= 1
    return ans

import math

if odd_b:
    # Warshall???Floyd Algorithm
    for k in range(V):
        for i in range(V):
            for j in range(V):
                adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])
                
    # Minimum weighted matching
    mw = [no_edge] * (odd_b + 1)
    mw[0] = 0
    digits = int(math.log2(odd_b)) + 1

    for b in range(odd_b):
        if odd_one(b):
            continue
        for i in range(0, digits):
            if not (b & (1 << i)):
                for j in range(i + 1, digits):
                    if not (b & (1 << j)):
                        t_b = b + (1 << i) + (1 << j)
                        if t_b == t_b & odd_b:
                            t_w = mw[t_b]
                            mw[t_b] = min(t_w, mw[b] + adj[i][j])

    # Output
    ans += mw[odd_b]
    print(ans)
else:
    print(ans)
```