Voici un énoncé de problème :

Problem A : ID
A大学ではIDの入力ミスが多発していた。
そこで、A大学は入力ミス防止のため新しいIDを発行することにした。
新しいIDには入力ミス防止のためにIDが正しいかどうかチェックする方法がある。
・全ての桁の数字の総和を求める。
・ただし、右端の桁を１番目として、偶数番目の桁の数字を２倍にする。
・２倍することによって数字が１０以上になった時、１の位の数字と１０の位の数字を加算した数字をその桁の数字とする。
・総和が１０で割り切れれば正しいID、そうでなければ間違いとする。
例として、53579というIDをチェックする。
全ての桁の数字の総和を求めるので、
5 + 3 + 5 + 7 + 9
ただし、偶数番目の桁の数字を２倍にするので、
5 +
6
+ 5 +
14
+ 9
２倍することによって数字が１０以上になった時、１の位の数字と１０の位の数字を加算した数字をその桁の数字とするので、
5 + 6 + 5 +
(1 + 4)
+ 9
以上より、総和は30となる。30は10で割り切れるので、53579は正しいIDである。
B君はA大学の大学生であり、新しいIDを発行してもらったが、IDの一部の桁を忘れてしまった。
しかし、忘れてしまった部分にどんな数字が入るか、いくつか候補を絞ることに成功した。
あなたの仕事は、B君のIDの正しい組み合わせが何通りあるかを求めることである。
Input
入力は以下のフォーマットで与えられる。
n
ID
m
a
0
a
1
... a
m-1
n
は
ID
の桁の数である。
ID
の各桁には0~9の数字または忘れた桁であるということを示す'*'という文字が入る。
m
は'*'に入る数字の候補の数である。
a
i
は'*'に入る数字の候補である。
入力は以下の制約を満たす
1 ≤
n
≤ 100,000
1 ≤
m
≤ 10
0 ≤
a
i
≤ 9
1 ≤ '*'の数 ≤ 7
Output
答えの値を１行に出力せよ
Sample Input 1
5
5*57*
2
3 9
Sample Output 1
1
Sample Input 2
15
2***9*2*6*1199*
9
0 1 2 3 4 6 7 8 9
Sample Output 2
478297


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import itertools

n = int(input())
id = input()[::-1]
count = 0
a = []
odd, even = 0 , 0
tmp = 0
for i in range(1,n+1):
    if id[i-1] == "*":
        if i % 2:
            odd += 1
        else:
            even += 1
    elif i % 2 == 0:
        x = int(id[i-1])
        if x >= 5:
            tmp += (x * 2 - 9)
        else:
            tmp += (x * 2)
    else:
        tmp += (int(id[i-1]))
m = int(input())

data = list(map(int, input().split()))

def sum2(ls):
    ans = 0
    for k in ls:
        if k >= 5:
            ans += (k * 2 - 9)
        else:
            ans += (k * 2)
    return ans

odd_list = list(map(lambda x: (sum(x) % 10),list(itertools.product(data, repeat=odd))))
even_list = list(map(lambda x: ((sum2(x)) % 10),list(itertools.product(data, repeat=even))))
odd_mod = [odd_list.count(i) for i in range(10)]
even_mod = [even_list.count(i) for i in range(10)]
for i in range(10):
    for j in range(10):
        if ((i + j + tmp) % 10) == 0:
            count += odd_mod[i] * even_mod[j]

print(count)
```