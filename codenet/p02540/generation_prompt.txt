Voici un énoncé de problème :

Score :
300
points
Problem Statement
There are
N
cities on a 2D plane. The coordinate of the
i
-th city is
(x_i, y_i)
. Here
(x_1, x_2, \dots, x_N)
and
(y_1, y_2, \dots, y_N)
are both permuations of
(1, 2, \dots, N)
.
For each
k = 1,2,\dots,N
, find the answer to the following question:
Rng is in City
k
.
Rng can perform the following move arbitrarily many times:
move to another city that has a smaller
x
-coordinate and a smaller
y
-coordinate, or a larger
x
-coordinate and a larger
y
-coordinate, than the city he is currently in.
How many cities (including City
k
) are reachable from City
k
?
Constraints
1 \leq N \leq 200,000
(x_1, x_2, \dots, x_N)
is a permutation of
(1, 2, \dots, N)
.
(y_1, y_2, \dots, y_N)
is a permutation of
(1, 2, \dots, N)
.
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
x_1
y_1
x_2
y_2
:
x_N
y_N
Output
Print
N
lines. In
i
-th line print the answer to the question when
k = i
.
Sample Input 1
4
1 4
2 3
3 1
4 2
Sample Output 1
1
1
2
2
Rng can reach City
4
from City
3
, or conversely City
3
from City
4
.
Sample Input 2
7
6 4
4 3
3 5
7 1
2 7
5 2
1 6
Sample Output 2
3
3
1
1
2
3
2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
readline = sys.stdin.readline
from operator import itemgetter

class UF():
    def __init__(self, num):
        self.par = [-1]*num
    def find(self, x):
        if self.par[x] < 0:
            return x
        else:
            stack = []
            while self.par[x] >= 0:
                stack.append(x)
                x = self.par[x]
            for xi in stack:
                self.par[xi] = x
            return x
    
    def union(self, x, y):
        rx = self.find(x)
        ry = self.find(y)
        if rx != ry:
            if self.par[rx] > self.par[ry]:
                rx, ry = ry, rx
            self.par[rx] += self.par[ry]
            self.par[ry] = rx
        return rx

N = int(readline())
XY = []
for i in range(N):
    x, y = map(int, readline().split())
    XY.append((i, x, y))

_, _, Y = map(list, zip(*XY))

XY.sort(key = itemgetter(1))

T = UF(N)

stack = []
for i, _, y in XY:
    my = i
    while stack and Y[stack[-1]] < y:
        if Y[stack[-1]] < Y[my]:
            my = stack[-1]
        T.union(stack.pop(), i)
    stack.append(my)
ans = [-T.par[T.find(i)] for i in range(N)]
    
print('\n'.join(map(str, ans)))
```