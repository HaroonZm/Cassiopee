Voici un énoncé de problème :

Score :
1600
points
Problem Statement
Joisino has a bar of length
N
, which has
M
marks on it.
The distance from the left end of the bar to the
i
-th mark is
X_i
.
She will place several squares on this bar.
Here, the following conditions must be met:
Only squares with integral length sides can be placed.
Each square must be placed so that its bottom side touches the bar.
The bar must be completely covered by squares.
That is, no square may stick out of the bar, and no part of the bar may be left uncovered.
The boundary line of two squares may not be directly above a mark.
Examples of arrangements that satisfy/violate the conditions
The
beauty
of an arrangement of squares is defined as the
product
of the areas of all the squares placed.
Joisino is interested in the sum of the beauty over all possible arrangements that satisfy the conditions.
Write a program to find it.
Since it can be extremely large, print the sum modulo
10^9+7
.
Constraints
All input values are integers.
1 \leq N \leq 10^9
0 \leq M \leq 10^5
1 \leq X_1 < X_2 < ... < X_{M-1} < X_M \leq N-1
Input
Input is given from Standard Input in the following format:
N
M
X_1
X_2
...
X_{M-1}
X_M
Output
Print the sum of the beauty over all possible arrangements that satisfy the conditions, modulo
10^9+7
.
Sample Input 1
3 1
2
Sample Output 1
13
There are two possible arrangements:
Place a square of side length
1
to the left, and place another square of side length
2
to the right
Place a square of side length
3
The sum of the beauty of these arrangements is
(1 \times 1 \times 2 \times 2) + (3 \times 3) = 13
.
Sample Input 2
5 2
2 3
Sample Output 2
66
Sample Input 3
10 9
1 2 3 4 5 6 7 8 9
Sample Output 3
100
Sample Input 4
1000000000 0
Sample Output 4
693316425


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N,M,*X = map(int,read().split())

MOD = 10 ** 9 + 7

def mult(a,b,c,d,e,f):
    # (a+bx+cx^2)(d+ex+fx^2) modulo 1-4x+2x^2-x^3
    a,b,c,d,e = a*d,a*e+b*d,a*f+b*e+c*d,b*f+c*e,c*f
    b += e; c -= 4*e; d += 2*e; e = 0
    a += d; b -= 4*d; c += 2*d; d = 0
    a %= MOD; b %= MOD; c %= MOD
    return a,b,c

# (1/x)^i modulo (1-4x+2x^2-x^3)
M = 10 ** 5
A1 = [0] * (M+1)
a,b,c = 1,0,0
for i in range(M+1):
    A1[i] = (a,b,c)
    a,b,c = b+4*a,c-2*a,a
    a %= MOD; b %= MOD; c %= MOD

# (1/x)^Mi modulo (1-4x+2x^2-x^3)
A2 = [0] * (M+1)
a,b,c = 1,0,0
d,e,f = A1[M]
for i in range(M+1):
    A2[i] = (a,b,c)
    a,b,c = mult(a,b,c,d,e,f)

def power(n):
    # (1/x)^n modulo (1-4x+2x^2-x^3)
    q,r = divmod(n,M)
    a,b,c = A1[r]
    d,e,f = A2[q]
    return mult(a,b,c,d,e,f)

X.append(N)

a,b,c = 0,1,1
prev_x = 0
for x in X:
    a,b,c = mult(a,b,c,*power(x - prev_x))
    b -= a; c -= a
    prev_x = x

answer = a
print(answer)
```