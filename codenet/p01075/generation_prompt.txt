En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# AOJ 590: One-Time Path
# Python3 2018.7.13 bal4u

INF = 0x7fffffff
import heapq
def dijkstra(V, to, start):
	dist = [INF]*V
	Q = []
	dist[start] = 0
	heapq.heappush(Q, (0, start))
	while Q:
		t, s = heapq.heappop(Q)
		if dist[s] < t: continue
		for e, cost in to[s]:
			if t <= cost and cost < dist[e]:
				dist[e] = cost
				heapq.heappush(Q, (cost, e))
	return dist

n, m = map(int, input().split())
n1 = n - 1
last = []
to = [[] for i in range(n)]
for i in range(m):
	a, b, c = map(int, input().split())
	a -= 1; b -= 1
	to[a].append((b, c))
	if b == n-1: last.append((a, c))

dist = dijkstra(n, to, 0)
if dist[n-1] >= INF: print(-1)
else:
	last.sort(key=lambda x:(-x[1]))
	for a, c in last:
		if dist[a] <= c: print(c); break
```