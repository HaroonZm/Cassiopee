Voici un énoncé de problème :

Problem D: One-Time Path
Problem
N
個の島と
M
本の橋がある。
N
個の島にはそれぞれ1から
N
までの番号が割り振られている。
M
本の橋にもそれぞれ1から
M
までの番号が割り振られている。
がっちょ君は現在(時刻0の時点で)、1番目の島にいる。
がっちょ君は
i
番目の橋を利用することにより、
a
i
番目の島から
b
i
番目の島へと単方向に移動することができる。
しかし、時刻0の時点では、すべての橋は潮が満ちていて海の中に沈んでしまっている。
i
番目の橋は、時刻
c
i
になると潮が引いて渡れるようになる。
そして、時刻
c
i
を過ぎると、すぐにまた潮が満ちて
i
番目の橋は再び沈んでしまう。
再び沈んでしまうと、またいつ潮が引いて渡れるようになるかはわからない。
そこで、がっちょ君はそうなった橋は永遠に渡れなくなると考えるようにした。
がっちょ君は、できるだけ長い間、1から
N
-1番目の島の景色を眺めていたいのだが、
N
番目の島に船を泊めてあるので、最終的には
N
番目の島に到着していなければならない。また、船の中で両親を待たせているため、がっちょ君は
N
番目の島についたらすぐに船で出発して家へと帰らなければならない。
がっちょ君が橋を渡ったり島の中を移動する時間はとても短いので、0と仮定してよい。がっちょ君が1から
N
-1番目のいずれかの島にいることのできる時間の最大値を求めよ。ただし、どのように移動してもがっちょ君が
N
番目の島へと移動できない場合は代わりに-1を出力せよ。
Input
入力は以下の形式で与えられる。
N
M
a
1
b
1
c
1
a
2
b
2
c
2
…
a
M
b
M
c
M
1行目には、2つの整数
N
,
M
が空白区切りで与えられる。
2行目から
M
+1行目のそれぞれの行
i
には、3つの整数
a
i
,
b
i
,
c
i
が空白区切りで与えられる。
Constraints
2 ≤
N
≤ 10
5
1 ≤
M
≤ 2 × 10
5
1 ≤
a
i
<
N
1 ≤
b
i
≤
N
1 ≤
c
i
≤ 10
9
a
i
≠
b
i
Output
がっちょ君が
N
番目の島へと移動できる場合は、がっちょ君が1から
N
-1番目のいずれかの島にいることのできる時間の最大値を出力する。
N
番目の島へと移動できない場合は、代わりに-1を出力する。
Sample Input 1
3 2
1 2 10
2 3 20
Sample Output 1
20
まず、1番目の島で時刻が10になるまで待ってから、2番目の島へと移動する。
次に、2番目の島で時刻が20になるまで待ってから、3番目の島へと移動する。
以上より、1から2番目のいずれかの島にいる時間は20となる。
Sample Input 2
4 4
1 2 27
1 3 37
2 3 47
3 1 57
Sample Output 2
-1
4番目の島に繋がる橋がないため、4番目の島へ移動することができない。
Sample Input 3
3 3
1 2 13
2 3 17
2 3 15
Sample Output 3
17
Sample Input 4
3 2
1 2 20
2 3 10
Sample Output 4
-1
Sample Input 5
3 2
1 2 10
2 3 10
Sample Output 5
10


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# AOJ 590: One-Time Path
# Python3 2018.7.13 bal4u

INF = 0x7fffffff
import heapq
def dijkstra(V, to, start):
	dist = [INF]*V
	Q = []
	dist[start] = 0
	heapq.heappush(Q, (0, start))
	while Q:
		t, s = heapq.heappop(Q)
		if dist[s] < t: continue
		for e, cost in to[s]:
			if t <= cost and cost < dist[e]:
				dist[e] = cost
				heapq.heappush(Q, (cost, e))
	return dist

n, m = map(int, input().split())
n1 = n - 1
last = []
to = [[] for i in range(n)]
for i in range(m):
	a, b, c = map(int, input().split())
	a -= 1; b -= 1
	to[a].append((b, c))
	if b == n-1: last.append((a, c))

dist = dijkstra(n, to, 0)
if dist[n-1] >= INF: print(-1)
else:
	last.sort(key=lambda x:(-x[1]))
	for a, c in last:
		if dist[a] <= c: print(c); break
```