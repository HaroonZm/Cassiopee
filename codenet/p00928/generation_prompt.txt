Voici un énoncé de problème :

Problem E:
Automotive Navigation
The International Commission for Perfect Cars (ICPC) has constructed a city scale test course for advanced driver assistance systems. Your company, namely the Automotive Control Machines (ACM), is appointed by ICPC to make test runs on the course.
The test course consists of streets, each running straight either east-west or north-south. No streets of the test course have dead ends, that is, at each end of a street, it meets another one. There are no grade separated streets either, and so if a pair of orthogonal streets run through the same geographical location, they always meet at a crossing or a junction, where a car can turn from one to the other. No U-turns are allowed on the test course and a car never moves outside of the streets.
Oops! You have just received an error report telling that the GPS (Global Positioning System) unit of a car running on the test course was broken and the driver got lost. Fortunately, however, the odometer and the electronic compass of the car are still alive.
You are requested to write a program to estimate the current location of the car from available information. You have the car's location just before its GPS unit was broken. Also, you can remotely measure the running distance and the direction of the car once every time unit. The measured direction of the car is one of north, east, south, and west. If you measure the direction of the car while it is making a turn, the measurement result can be the direction either before or after the turn. You can assume that the width of each street is zero.
The car's direction when the GPS unit was broken is not known. You should consider every possible direction consistent with the street on which the car was running at that time.
Input
The input consists of a single test case. The first line contains four integers $n$, $x_0$, $y_0$, $t$, which are the number of streets ($4 \leq n \leq 50$), $x$- and $y$-coordinates of the car at time zero, when the GPS unit was broken, and the current time ($1 \leq t \leq 100$), respectively. $(x_0, y_0)$ is of course on some street. This is followed by $n$ lines, each containing four integers $x_s$, $y_s$, $x_e$, $y_e$ describing a street from $(x_s, y_s)$ to $(x_e, y_e)$ where $(x_s, y_s) \ne (x_e, y_e)$. Since each street runs either east-west or north-south, $x_s = x_e$ or $y_s = y_e$ is also satisfied. You can assume that no two parallel streets overlap or meet. In this coordinate system, the $x$- and $y$-axes point east and north, respectively. Each input coordinate is non-negative and at most 50. Each of the remaining $t$ lines contains an integer $d_i$ ($1 \leq d_i \leq 10$), specifying the measured running distance from time $i − 1$ to $i$, and a letter $c_i$, denoting the measured direction of the car at time $i$ and being either
N
for north,
E
for east,
W
for west, or
S
for south.
Output
Output all the possible current locations of the car that are consistent with the measurements. If they are $(x_1, y_1),(x_2, y_2), . . . ,(x_p, y_p)$ in the lexicographic order, that is, $x_i < x_j$ or $x_i = x_j$ and $y_i < y_j$ if $1 \leq i < j \leq p$, output the following:
$x_1$ $y_1$
$x_2$ $y_2$
.
.
.
$x_p$ $y_p$
Each output line should consist of two integers separated by a space.
You can assume that at least one location on a street is consistent with the measurements
Sample Input 1
4 2 1 1
1 1 1 2
2 2 2 1
2 2 1 2
1 1 2 1
9 N
Sample Output 1
1 1
2 2
Sample Input 2
6 0 0 2
0 0 2 0
0 1 2 1
0 2 2 2
0 0 0 2
1 0 1 2
2 0 2 2
2 E
7 N
Sample Output 2
0 1
1 0
1 2
2 1
Sample Input 3
7 10 0 1
5 0 10 0
8 5 15 5
5 10 15 10
5 0 5 10
8 5 8 10
10 0 10 10
15 5 15 10
10 N
Sample Output 3
5 5
8 8
10 10
15 5


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque

import sys
readline = sys.stdin.readline
write = sys.stdout.write
def solve():
    L = 55
    N, x0, y0, T = map(int, readline().split())
    X = [[0]*L for i in range(L)]
    Y = [[0]*L for i in range(L)]
    Z = [[0]*L for i in range(L)]
    for i in range(N):
        xs, ys, xe, ye = map(int, readline().split())
        if xs == xe:
            if not ys < ye:
                ys, ye = ye, ys
            for j in range(ys, ye):
                X[xs][j] = Z[j][xs] = 1
            Z[ye][xs] = 1
        else:
            if not xs < xe:
                xs, xe = xe, xs
            for j in range(xs, xe):
                Y[ys][j] = Z[ys][j] = 1
            Z[ys][xe] = 1
    DR = "WNES"
    R = [[[None]*4 for i in range(L)] for j in range(L)]
    E = [[[0]*4 for i in range(L)] for j in range(L)]
    U = [[[0]*L for i in range(L)] for j in range(4)]
    U0, U1, U2, U3 = U
    col = 0
    for i in range(L):
        for j in range(L):
            if not Z[i][j]:
                continue
            if Y[i][j-1]:
                E[i][j][0] = 1
            if X[j][i]:
                E[i][j][1] = 1
            if Y[i][j]:
                E[i][j][2] = 1
            if X[j][i-1]:
                E[i][j][3] = 1
            for l in range(4):
                S = [(j, i, l)]
                res = [S]
                for k in range(10):
                    col += 1
                    S1 = []
                    push = S1.append
                    for x, y, e in S:
                        if e != 2 and Y[y][x-1] and U0[y][x-1] != col:
                            U0[y][x-1] = col
                            push((x-1, y, 0))
                        if e != 3 and X[x][y] and U1[y+1][x] != col:
                            U1[y+1][x] = col
                            push((x, y+1, 1))
                        if e != 0 and Y[y][x] and U2[y][x+1] != col:
                            U2[y][x+1] = col
                            push((x+1, y, 2))
                        if e != 1 and X[x][y-1] and U3[y-1][x] != col:
                            U3[y-1][x] = col
                            push((x, y-1, 3))
                    res.append(S1)
                    S = S1
                R[i][j][l] = res
    dd = ((-1, 0), (0, 1), (1, 0), (0, -1))
    S = set()
    d, s = readline().strip().split(); d = int(d); s = DR.index(s)
    for l in range(4):
        if not E[y0][x0][l]:
            continue
        dx, dy = dd[l]
        for x, y, e in R[y0+dy][x0+dx][l][d-1]:
            if e == s:
                for l1 in range(4):
                    if l1 == (e + 2) % 4 or not E[y][x][l1]:
                        continue
                    S.add((x, y, l1))
            elif (e + 2) % 4 != s and E[y][x][s]:
                S.add((x, y, s))

    for i in range(T-1):
        S1 = set()
        d, s = readline().strip().split(); d = int(d); s = DR.index(s)
        for x1, y1, e1 in S:
            if not E[y1][x1][e1]:
                continue
            dx, dy = dd[e1]
            for x, y, e in R[y1+dy][x1+dx][e1][d-1]:
                if e == s:
                    for l1 in range(4):
                        if l1 == (e + 2) % 4 or not E[y][x][l1]:
                            continue
                        S1.add((x, y, l1))
                elif (e + 2) % 4 != s and E[y][x][s]:
                    S1.add((x, y, s))
        S = S1
    P = sorted(set((x, y) for x, y, _ in S))
    for x, y in P:
        write("%d %d\n" % (x, y))
solve()
```