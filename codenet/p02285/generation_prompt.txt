Voici un énoncé de problème :

Binary Search Tree III
Write a program which performs the following operations to a binary search tree $T$ by adding delete operation to B: Binary Search Tree II.
insert
$k$: Insert a node containing $k$ as key into $T$.
find
$k$: Report whether $T$ has a node containing $k$.
delete
$k$: Delete a node containing $k$.
print
: Print the keys of the binary search tree by inorder tree walk and preorder tree walk respectively.
The operation delete $k$ for deleting a given node $z$ containing key $k$ from $T$ can be implemented by an algorithm which considers the following cases:
If $z$ has no children, we modify its parent $z.p$ to replace $z$ with NIL as its child (delete $z$).
If $z$ has only a single child, we "splice out" $z$ by making a new link between its child and its parent.
If $z$ has two children, we splice out $z$'s successor $y$ and replace $z$'s key with $y$'s key.
Input
In the first line, the number of operations $m$ is given. In the following $m$ lines, operations represented by
insert
$k$,
find
$k$,
delete
$k$ or
print
are given.
Output
For each
find
$k$ operation, print "
yes
" if $T$ has a node containing $k$, "
no
" if not.
In addition, for each
print
operation, print a list of keys obtained by inorder tree walk and preorder tree walk in a line respectively. Put a space character
before each key
Constraints
The number of operations $\leq 500,000$
The number of print operations $\leq 10$.
$-2,000,000,000 \leq key \leq 2,000,000,000$
The height of the binary tree does not exceed 100 if you employ the above pseudo code.
The keys in the binary search tree are all different.
Sample Input 1
18
insert 8
insert 2
insert 3
insert 7
insert 22
insert 1
find 1
find 2
find 3
find 4
find 5
find 6
find 7
find 8
print
delete 3
delete 7
print
Sample Output 1
yes
yes
yes
no
no
no
yes
yes
1 2 3 7 8 22
8 2 1 3 7 22
1 2 8 22
8 2 1 22
Reference
Introduction to Algorithms, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. The MIT Press.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
class Node:
    def __init__(self,key,left,right,parent):
        self.key = key
        self.left = left
        self.right = right
        self.p = parent

    def __repr__(self):
        #return str(self.key) + "[" + str(self.p)+"]"
        return str(self.key)

def insert(T, z):
    y = None
    x = T 
    while x != None:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.p = y
    #print(x,y,z)
    if y == None:
        #print("Y==None")
        T = z
        print(T)
    elif z.key<y.key:
        #print("z.key<y.key")
        y.left = z
    else:
        #print("z.key<y.key")
        y.right = z

def find(T, k, show):
    x = T 
    while x != None:
        if k == x.key:
            if show:
                print('yes')
            return x
        if k < x.key:
            x = x.left
        else:
            x = x.right
    print('no')
    

def getScu(x):
    if x.right == None:
        y = x.p
        while x == y.right and y != None:
            x = y
            y = x.p
        return y
    x = x.right
    while x != None:
        y = x
        x = x.left
    return y

def delete(T,x):
    #print(x.key, id(x))
    if x.left == x.right == None:
        #print("x.left == x.right == None")
        if x.p.key < x.key:
            x.p.right = None
        else:
            x.p.left = None

    elif x.left == None:
        #print("x.left == None")
        y = x.right
        x.key = y.key
        x.right = y.right
        x.left = y.left
        #print(x.key, id(x))
    elif x.right == None:
        #print("x.right == None")
        y = x.left
        x.key = y.key
        x.right = y.right
        x.left = y.left
        #print(x.key, id(x))
    else:
        y = getScu(x)
        delete(T, y)
        x.key = y.key

    

def printPreorder(x):
    if x == None:
        return
    printPreorder(x.left)
    print(end=' ')
    print(x,end='')
    printPreorder(x.right)

def printMidorder(x):
    if x == None:
        return
    print(end=' ')
    print(x,end='')
    printMidorder(x.left)
    printMidorder(x.right)

def printal(x):
    printPreorder(x)
    print()
    printMidorder(x)
    print()

N = int(input())
Q = input().split()
T = Node(int(Q[1]),None,None,None)
for i in range(N-1):
    Q = input().split()
    if Q[0] == "print":
        printal(T)
        continue
    elif Q[0] == "find":
        find(T,int(Q[1]),True)
        continue
    elif Q[0] == "delete":
        delete(T,find(T, int(Q[1]), False))
        continue
    insert(T,Node(int(Q[1]),None,None,None))
```