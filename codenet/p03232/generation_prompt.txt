Voici un énoncé de problème :

Score :
600
points
Problem Statement
There are
N
blocks arranged in a row, numbered
1
to
N
from left to right.
Each block has a weight, and the weight of Block
i
is
A_i
.
Snuke will perform the following operation on these blocks
N
times:
Choose one block that is still not removed, and remove it.
The cost of this operation is the sum of the weights of the blocks that are connected to the block being removed (including itself).
Here, two blocks
x
and
y
(
x \leq y
) are
connected
when, for all
z
(
x \leq z \leq y
), Block
z
is still not removed.
There are
N!
possible orders in which Snuke removes the blocks.
For all of those
N!
orders, find the total cost of the
N
operations, and calculate the sum of those
N!
total costs.
As the answer can be extremely large, compute the sum modulo
10^9+7
.
Constraints
1 \leq N \leq 10^5
1 \leq A_i \leq 10^9
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
A_1
A_2
...
A_N
Output
For all of the
N!
orders, find the total cost of the
N
operations, and print the sum of those
N!
total costs, modulo
10^9+7
.
Sample Input 1
2
1 2
Sample Output 1
9
First, we will consider the order "Block
1
-> Block
2
".
In the first operation, the cost of the operation is
1+2=3
, as Block
1
and
2
are connected.
In the second operation, the cost of the operation is
2
, as only Block
2
remains.
Thus, the total cost of the two operations for this order is
3+2=5
.
Then, we will consider the order "Block
2
-> Block
1
".
In the first operation, the cost of the operation is
1+2=3
, as Block
1
and
2
are connected.
In the second operation, the cost of the operation is
1
, as only Block
1
remains.
Thus, the total cost of the two operations for this order is
3+1=4
.
Therefore, the answer is
5+4=9
.
Sample Input 2
4
1 1 1 1
Sample Output 2
212
Sample Input 3
10
1 2 4 8 16 32 64 128 256 512
Sample Output 3
880971923


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def remov(n,a):

    mod=10**9+7

    k=[1]*(n+1)
    gk=k[:]
    kb1=k[:]

    for i in range(1,n+1):
        k[i]=k[i-1]*i%mod

    gk[n]=pow(k[n],mod-2,mod)
    for i in range(n,0,-1):
        gk[i-1]=gk[i]*i%mod

    for i in range(1,n+1):
        kb1[i]=gk[i]*k[i-1]%mod

    kerui=[0]*(n+1)
    for i in range(1,n+1):
        kerui[i]=(kerui[i-1]+kb1[i])%mod

    ans=0
    for i in range(n):
        ans+=a[i]*(kerui[i+1]+kerui[n-i]-1)%mod
        ans%=mod
    ans*=k[n]

    return ans%mod

print(remov(int(input()),[int(i) for i in input().split()]))
```