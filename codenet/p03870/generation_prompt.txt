Voici un énoncé de problème :

Score :
500
points
Problem Statement
A cheetah and a cheater are going to play the game of Nim.
In this game they use
N
piles of stones.
Initially the
i
-th pile contains
a_i
stones.
The players take turns alternately, and the cheetah plays first.
In each turn, the player chooses one of the piles, and takes one or more stones from the pile.
The player who can't make a move loses.
However, before the game starts, the cheater wants to cheat a bit to make sure that he can win regardless of the moves by the cheetah.
From each pile, the cheater takes zero or one stone and eats it before the game.
In case there are multiple ways to guarantee his winning, he wants to minimize the number of stones he eats.
Compute the number of stones the cheater will eat.
In case there is no way for the cheater to win the game even with the cheating, print
-1
instead.
Constraints
1 ≤ N ≤ 10^5
2 ≤ a_i ≤ 10^9
Input
The input is given from Standard Input in the following format:
N
a_1
:
a_N
Output
Print the answer.
Sample Input 1
3
2
3
4
Sample Output 1
3
The only way for the cheater to win the game is to take stones from all piles and eat them.
Sample Input 2
3
100
100
100
Sample Output 2
-1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    n = I()
    a = sorted([I() for _ in range(n)])
    x = 0
    for c in a:
        x ^= c
    s = set()
    for c in a:
        s.add(c ^ (c-1))

    r = 0
    for c in sorted(s, reverse=True):
        cb = bin(c)
        xb = bin(x)
        if len(cb) == len(xb) and x > 0:
            x ^= c
            r += 1

    if x != 0:
        return -1

    return r

print(main())
```