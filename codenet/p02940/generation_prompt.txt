Voici un énoncé de problème :

Score :
800
points
Problem Statement
We have
3N
colored balls with IDs from
1
to
3N
.
A string
S
of length
3N
represents the colors of the balls. The color of Ball
i
is red if
S_i
is
R
, green if
S_i
is
G
, and blue if
S_i
is
B
. There are
N
red balls,
N
green balls, and
N
blue balls.
Takahashi will distribute these
3N
balls to
N
people so that each person gets one red ball, one blue ball, and one green ball.
The people want balls with IDs close to each other, so he will additionally satisfy the following condition:
Let
a_j < b_j < c_j
be the IDs of the balls received by the
j
-th person in ascending order.
Then,
\sum_j (c_j-a_j)
should be as small as possible.
Find the number of ways in which Takahashi can distribute the balls. Since the answer can be enormous, compute it modulo
998244353
.
We consider two ways to distribute the balls different if and only if there is a person who receives different sets of balls.
Constraints
1 \leq N \leq 10^5
|S|=3N
S
consists of
R
,
G
, and
B
, and each of these characters occurs
N
times in
S
.
Input
Input is given from Standard Input in the following format:
N
S
Output
Print the number of ways in which Takahashi can distribute the balls, modulo
998244353
.
Sample Input 1
3
RRRGGGBBB
Sample Output 1
216
The minimum value of
\sum_j (c_j-a_j)
is
18
when the balls are, for example, distributed as follows:
The first person gets Ball
1
,
5
, and
9
.
The second person gets Ball
2
,
4
, and
8
.
The third person gets Ball
3
,
6
, and
7
.
Sample Input 2
5
BBRGRRGRGGRBBGB
Sample Output 2
960


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from functools import reduce

N = int(input())
S = input()

MOD = 998244353

class ModInt:
    def __init__(self, x):
        self.x = x % MOD

    def __str__(self):
        return str(self.x)

    __repr__ = __str__

    def __add__(self, other):
        return (
            ModInt(self.x + other.x) if isinstance(other, ModInt) else
            ModInt(self.x + other)
        )

    def __sub__(self, other):
        return (
            ModInt(self.x - other.x) if isinstance(other, ModInt) else
            ModInt(self.x - other)
        )

    def __mul__(self, other):
        return (
            ModInt(self.x * other.x) if isinstance(other, ModInt) else
            ModInt(self.x * other)
        )

    def __truediv__(self, other):
        return (
            ModInt(
                self.x * pow(other.x, MOD - 2, MOD)
            ) if isinstance(other, ModInt) else
            ModInt(self.x * pow(other, MOD - 2, MOD))
        )

    def __pow__(self, other):
        return (
            ModInt(
                pow(self.x, other.x, MOD)
            ) if isinstance(other, ModInt) else
            ModInt(pow(self.x, other, MOD))
        )

    def __radd__(self, other):
        return ModInt(other + self.x)

    def __rsub__(self, other):
        return ModInt(other - self.x)

    def __rmul__(self, other):
        return ModInt(other * self.x)

    def __rtruediv__(self, other):
        return ModInt(other * pow(self.x, MOD - 2, MOD))

    def __rpow__(self, other):
        return ModInt(pow(other, self.x, MOD))

# 先頭のボールから順に、割り当て可能な人のうち最もボールを持っている人に割り当てることを繰り返す
def f(s, res, z, r, g, b, rg, gb, br):
    return (
        (
            (res * gb, z, r, g, b, rg, gb - 1, br) if gb else
            (res * g, z, r, g - 1, b, rg + 1, gb, br) if g else
            (res * b, z, r, g, b - 1, rg, gb, br + 1) if b else
            (res * z, z - 1, r + 1, g, b, rg, gb, br)
        ) if s == 'R' else
        (
            (res * br, z, r, g, b, rg, gb, br - 1) if br else
            (res * r, z, r - 1, g, b, rg + 1, gb, br) if r else
            (res * b, z, r, g, b - 1, rg, gb + 1, br) if b else
            (res * z, z - 1, r, g + 1, b, rg, gb, br)
        ) if s == 'G' else
        (
            (res * rg, z, r, g, b, rg - 1, gb, br) if rg else
            (res * r, z, r - 1, g, b, rg, gb, br + 1) if r else
            (res * g, z, r, g - 1, b, rg, gb + 1, br) if g else
            (res * z, z - 1, r, g, b + 1, rg, gb, br)
        )
    )

ans, *_ = reduce(
    lambda acc, s: f(s, *acc),
    S,
    (ModInt(1), N, 0, 0, 0, 0, 0, 0)
)

print(ans)
```