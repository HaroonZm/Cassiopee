En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!usr/bin/env python3
from collections import defaultdict,deque
from heapq import heappush, heappop
import sys
import math
import bisect
import random
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def LS():return [list(x) for x in sys.stdin.readline().split()]
def S():
    res = list(sys.stdin.readline())
    if res[-1] == "\n":
        return res[:-1]
    return res
def IR(n):
    return [I() for i in range(n)]
def LIR(n):
    return [LI() for i in range(n)]
def SR(n):
    return [S() for i in range(n)]
def LSR(n):
    return [LS() for i in range(n)]

sys.setrecursionlimit(1000000)
mod = 1000000007

#A
def A():
    x,y = LI()
    if x < 0:
        if y < 0:
            if x < y:
                print(y-x)
            else:
                print(x-y+2)
        else:
            if abs(x) < y:
                print(y-abs(x)+1)
            else:
                print(-y-x+(y>0))
    else:
        if y < 0:
            if x < abs(y):
                print(abs(y)-x+1)
            else:
                print(x+y+1)
        else:
            if x < y:
                print(y-x)
            else:
                print(x-y+(x>0)+(y>0))
    return

#B
def B():

    return

#C
def C():
    a = LI()
    if a[0] > 0 and a[3] > 0 and a[4] > 0:
        print(max(2*(a[0]//2)+a[1]+2*(a[3]//2)+2*(a[4]//2), 2*((a[0]-1)//2)+a[1]+2*((a[3]-1)//2)+2*((a[4]-1)//2)+3))
    else:
        print(2*(a[0]//2)+a[1]+2*(a[3]//2)+2*(a[4]//2))
    return

#D
def D():
    n = I()
    x = LI()
    f = [(x[i],i) for i in range(n)]
    f.sort()
    b = []
    for xi,i in f:
        b += [i+1]*i
    for xi,i in f:
        b += [i+1]*(n-i-1)
    ans = []
    l = 0
    for xi,i in f:
        while len(ans)+1 < xi:
            if l == len(b):
                break
            ans.append(b[l])
            l += 1
        ans.append(i+1)
    for i in range(l,len(b)):
        ans.append(b[i])
    f = [0]*n
    for i in range(len(ans)):
        ai = ans[i]-1
        if f[ai] == ai:
            if i+1 != x[ai]:
                print("No")
                return
        f[ai] += 1
    print("Yes")
    print(*ans)
    return

#E
def E():

    return

#F
def F():

    return

#Solve
if __name__ == "__main__":
    D()
```