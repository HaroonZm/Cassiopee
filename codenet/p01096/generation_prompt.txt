Voici un énoncé de problème :

Daruma Otoshi
You are playing a variant of a game called "Daruma Otoshi (Dharma Block Striking)".
At the start of a game, several wooden blocks of the same size but with varying weights
are stacked on top of each other, forming a tower.
Another block symbolizing Dharma is placed atop.
You have a wooden hammer with its head thicker than the height of a block,
but not twice that.
You can choose any two adjacent blocks, except Dharma on the top,
differing at most 1 in their weight,
and push both of them out of the stack with a single blow of your hammer.
The blocks above the removed ones then fall straight down,
without collapsing the tower.
You cannot hit a block pair with weight difference of 2 or more,
for that makes too hard to push out blocks while keeping the balance of the tower.
There is no chance in hitting three blocks out at a time,
for that would require superhuman accuracy.
The goal of the game is to remove as many blocks as you can.
Your task is to decide the number of blocks that can be removed
by repeating the blows in an optimal order.
Figure D1. Striking out two blocks at a time
In the above figure, with a stack of four blocks weighing 1, 2, 3, and
1, in this order from the bottom, you can hit middle
two blocks, weighing 2 and 3, out from the stack. The blocks above will
then fall down, and two blocks weighing 1 and the Dharma block will remain.
You can then push out the remaining pair of weight-1 blocks after that.
Input
The input consists of multiple datasets.
The number of datasets is at most 50.
Each dataset is in the following format.
n
w
1
w
2
…
w
n
n
is the number of blocks, except Dharma on the top.
n
is a positive integer not exceeding 300.
w
i
gives the weight of the
i
-th block counted from the bottom.
w
i
is an integer between 1 and 1000, inclusive.
The end of the input is indicated by a line containing a zero.
Output
For each dataset, output in a line the maximum number of blocks you can remove.
Sample Input
4
1 2 3 4
4
1 2 3 1
5
5 1 2 3 6
14
8 7 1 4 3 5 4 1 6 8 10 4 6 5
5
1 3 5 1 3
0
Output for the Sample Input
4
4
2
12
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def solve(n,lst):
    #i行j列はjから連続したi個のうち落とせる個数の最大値
    dp=[[0]*n for _ in range(n+1)]

    #initialize
    for j in range(n-1):
        if abs(lst[j]-lst[j+1])<=1 : dp[2][j]=2
    

    #真ん中2*i個が抜けて上下を落とせる場合と2*(i+1)個を複数の部分に分けて落とせる場合の2通りが考えられる
    for i in range(3,n+1):
        for j in range(n-i+1):
            mx=0
            if i%2==0:
                if abs(lst[j]-lst[j+i-1])<=1:
                    if dp[i-2][j+1]==i-2:
                        dp[i][j]=i
                        continue
                mx=dp[i-2][j+1]                
                for k in range(2,i,2):
                    if mx<dp[k][j]+dp[i-k][j+k]:
                        mx=dp[k][j]+dp[i-k][j+k]
                        if mx==i:break
            else :
                for k in range(1,i,2):
                    if mx<dp[k][j]+dp[i-k][j+k]:
                        mx=dp[k][j]+dp[i-k][j+k]                
            dp[i][j]=mx
    print(dp[n][0])        
    #print(dp) 

                

while 1:
    n=int(input())
    if n==0 : break
    lst=tuple(map(int,input().split()))
    solve(n,lst)
```