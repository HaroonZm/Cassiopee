Voici un énoncé de problème :

Problem Statement
We have
N
pieces of ropes, numbered
1
through
N
. The length of piece
i
is
a_i
.
At first, for each
i (1≤i≤N-1)
, piece
i
and piece
i+1
are tied at the ends, forming one long rope with
N-1
knots. Snuke will try to untie all of the knots by performing the following operation repeatedly:
Choose a (connected) rope with a total length of at least
L
, then untie one of its knots.
Is it possible to untie all of the
N-1
knots by properly applying this operation? If the answer is positive, find one possible order to untie the knots.
Constraints
2≤N≤10^5
1≤L≤10^9
1≤a_i≤10^9
All input values are integers.
Input
The input is given from Standard Input in the following format:
N
L
a_1
a_2
...
a_n
Output
If it is not possible to untie all of the
N-1
knots, print
Impossible
.
If it is possible to untie all of the knots, print
Possible
, then print another
N-1
lines that describe a possible order to untie the knots. The
j
-th of those
N-1
lines should contain the index of the knot that is untied in the
j
-th operation. Here, the index of the knot connecting piece
i
and piece
i+1
is
i
.
If there is more than one solution, output any.
Sample Input 1
3 50
30 20 10
Sample Output 1
Possible
2
1
If the knot
1
is untied first, the knot
2
will become impossible to untie.
Sample Input 2
2 21
10 10
Sample Output 2
Impossible
Sample Input 3
5 50
10 20 30 40 50
Sample Output 3
Possible
1
2
3
4
Another example of a possible solution is
3
,
4
,
1
,
2
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n,l=map(int,input().split())
a=list(map(int,input().split()))
failflag=1
for i in range(n-1):
  if a[i]+a[i+1]>=l:
    failflag=0
    k=i
    break
if failflag==1:
  print('Impossible')
else:
  print('Possible')
  for i in range(1,k+1):
    print(i)
  for i in range(n-1-k):
    print(n-1-i)
```