Voici un énoncé de problème :

ぴょん吉の夏
会津大学には一面芝生で覆われた公園があり、日差しを遮る木や建物がありません。日差しの強い夏の日には、公園内に設置されたスプリンクラーが作動して芝生に散水しています。この公園にはカエルのぴょん吉が住み着いています。ぴょん吉は暑いのが苦手で、日差しが強い夏の日には常にスプリンクラーの水に当たっていないと干からびて死んでしまいます。公園に設置されたスプリンクラーは、節水のため一度に一つだけ散水することになっているので、ぴょん吉はスプリンクラーの作動に合わせて移動しなくてはなりません。
(a) 公園の地図
(b) ぴょん吉のジャンプ範囲
(c) スプリンクラーの散水範囲
公園は上図の(a)のとおりで、公園内の場所は縦横それぞれ 0~9 の座標で表し、黒い●がスプリンクラーで、その番号が作動する順番を表しています。これは一例で各スプリンクラーの場所と作動順序は日々変わります。
ぴょん吉は不器用なので、移動するにも決まった距離をジャンプすることしかできません。ぴょん吉のジャンプできる範囲は上図(b)のとおりで、それ以外の場所に移動することはできません。しかも、一回のジャンプで相当体力を消耗するため、しばらく水に当たって休まなくてはなりません。
スプリンクラーが散水できる範囲は上図(c)のとおりで、スプリンクラー自身の座標も含みます。各スプリンクラーは一定時間散水すると停止し、すぐに次のスプリンクラーが作動を開始します。ぴょん吉はこの時に一回だけジャンプするものとし、次に散水が停止するまでジャンプしないものとします。また、公園の四方は灼熱のアスファルトで囲まれているので公園の外にでてしまうような方向にはジャンプしないものとします。
猛暑となったこの夏。果たしてぴょん吉は生き延びることができたのでしょうか? ある日のぴょん吉の初期位置、スプリンクラーの位置と作動順序を読み込み、ぴょん吉が生き延びられる移動経路が存在している場合は”OK”、どう頑張っても死んでしまう場合は”NA”を出力するプログラムを作成してください。ただし、スプリンクラーの数は最大 10 個とし、ぴょん吉は一番目のスプリンクラーの作動と同時に初期位置からジャンプすることとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
px
py
n
x
1
y
1
x
2
y
2
...
x
n
y
n
1 行目にぴょん吉の初期位置の横座標
px
と縦座標
py
が与えられます。
2 行目にスプリンクラーの数
n
が与えられます。
3 行目に
i
番目に動作するスプリンクラーの横座標
x
i
と縦座標
y
i
が与えられます。
入力はゼロ２つの行で終わります。データセットの数は 20 を超えません。
Output
各データセットについて、生存の場合は OK、そうでない場合は NA を１行に出力してください。
Sample Input
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 8 3
6 1
10
6 4 3 3 1 2 0 5 4 6 1 8 5 9 7 7 8 6 9 0
0 0
Output for the Sample Input
OK
NA


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def search(table, x, y, depth, max_depth):

    if depth == max_depth:
        return True

    if x < 0 or x >= 10 or y < 0 or y >= 10:
        return False

    if depth >= 0 and table[x][y][depth] == 0:
        return False

    if search(table, x-2, y-1, depth+1, max_depth):
        return True
    if search(table, x-2, y, depth+1, max_depth):
        return True
    if search(table, x-2, y+1, depth+1, max_depth):
        return True

    if search(table, x-1, y-2, depth+1, max_depth):
        return True
    if search(table, x, y-2, depth+1, max_depth):
        return True
    if search(table, x+1, y-2, depth+1, max_depth):
        return True

    if search(table, x+2, y-1, depth+1, max_depth):
        return True
    if search(table, x+2, y, depth+1, max_depth):
        return True
    if search(table, x+2, y+1, depth+1, max_depth):
        return True

    if search(table, x-1, y+2, depth+1, max_depth):
        return True
    if search(table, x, y+2, depth+1, max_depth):
        return True
    if search(table, x+1, y+2, depth+1, max_depth):
        return True

while True:
    px,py = [int(i) for i in input().split()]
    if px == 0 and py == 0:
        break

    table = [[[0 for i in range(10)] for j in range(10)] for k in range(10)]

    n = int(input())
    N = [int(i) for i in input().split()]
    traps = []

    for i in range(0, len(N), 2):
        x = N[i]
        y = N[i+1]
        prx = max(x-1, 0)
        pry = max(y-1, 0)
        pox = min(x+1, 9)
        poy = min(y+1, 9)

        d = int(i//2)
        table[prx][pry][d] = 1
        table[prx][y][d] = 1
        table[prx][poy][d] = 1
        table[x][pry][d] = 1
        table[x][y][d] = 1
        table[x][poy][d] = 1
        table[pox][pry][d] = 1
        table[pox][y][d] = 1
        table[pox][poy][d] = 1

    if search(table, px, py, -1, n):
        print("OK")
    else:
        print("NA")
```