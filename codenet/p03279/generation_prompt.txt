Voici un énoncé de problème :

Score :
900
points
Problem Statement
There are
N
robots and
M
exits on a number line.
The
N + M
coordinates of these are all integers and all distinct.
For each
i
(
1 \leq i \leq N
), the coordinate of the
i
-th robot from the left is
x_i
.
Also, for each
j
(
1 \leq j \leq M
), the coordinate of the
j
-th exit from the left is
y_j
.
Snuke can repeatedly perform the following two kinds of operations in any order to move all the robots simultaneously:
Increment the coordinates of all the robots on the number line by
1
.
Decrement the coordinates of all the robots on the number line by
1
.
Each robot will disappear from the number line when its position coincides with that of an exit, going through that exit.
Snuke will continue performing operations until all the robots disappear.
When all the robots disappear, how many combinations of exits can be used by the robots?
Find the count modulo
10^9 + 7
.
Here, two combinations of exits are considered different when there is a robot that used different exits in those two combinations.
Constraints
1 \leq N, M \leq 10^5
1 \leq x_1 < x_2 < ... < x_N \leq 10^9
1 \leq y_1 < y_2 < ... < y_M \leq 10^9
All given coordinates are integers.
All given coordinates are distinct.
Input
Input is given from Standard Input in the following format:
N
M
x_1
x_2
...
x_N
y_1
y_2
...
y_M
Output
Print the number of the combinations of exits that can be used by the robots when all the robots disappear, modulo
10^9 + 7
.
Sample Input 1
2 2
2 3
1 4
Sample Output 1
3
The
i
-th robot from the left will be called Robot
i
, and the
j
-th exit from the left will be called Exit
j
.
There are three possible combinations of exits (the exit used by Robot
1
, the exit used by Robot
2
) as follows:
(
Exit
1
,
Exit
1
)
(
Exit
1
,
Exit
2
)
(
Exit
2
,
Exit
2
)
Sample Input 2
3 4
2 5 10
1 3 7 13
Sample Output 2
8
The exit for each robot can be chosen independently, so there are
2^3 = 8
possible combinations of exits.
Sample Input 3
4 1
1 2 4 5
3
Sample Output 3
1
Every robot uses Exit
1
.
Sample Input 4
4 5
2 5 7 11
1 3 6 9 13
Sample Output 4
6
Sample Input 5
10 10
4 13 15 18 19 20 21 22 25 27
1 5 11 12 14 16 23 26 29 30
Sample Output 5
22


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from bisect import bisect
from collections import defaultdict

class Bit:
    def __init__(self, n, MOD):
        self.size = n
        self.tree = [0] * (n + 1)
        self.depth = n.bit_length()
        self.mod = MOD

    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s % self.mod

    def add(self, i, x):
        while i <= self.size:
            self.tree[i] = (self.tree[i] + x) % self.mod
            i += i & -i

    def debug_print(self):
        for i in range(1, self.size + 1):
            j = (i & -i).bit_length()
            print('  ' * j, self.tree[i])

    def lower_bound(self, x):
        sum_ = 0
        pos = 0
        for i in range(self.depth, -1, -1):
            k = pos + (1 << i)
            if k <= self.size and sum_ + self.tree[k] < x:
                sum_ += self.tree[k]
                pos += 1 << i
        return pos + 1, sum_

n, m = map(int, input().split())
xxx = list(map(int, input().split()))
yyy = list(map(int, input().split()))
ab = defaultdict(set)
coordinates = set()

for x in xxx:
    if x < yyy[0] or yyy[-1] < x:
        continue
    i = bisect(yyy, x)
    a = x - yyy[i - 1]
    b = yyy[i] - x
    ab[a].add(b)
    coordinates.add(b)

# Bitのindexは1から始まるように作っているが、"0"を取れるようにするため、全体を1ずらす
cor_dict = {b: i for i, b in enumerate(sorted(coordinates), start=2)}
cdg = cor_dict.get
MOD = 10 ** 9 + 7
bit = Bit(len(coordinates) + 1, MOD)
bit.add(1, 1)

for a in sorted(ab):
    bbb = sorted(map(cdg, ab[a]), reverse=True)
    for b in bbb:
        bit.add(b, bit.sum(b - 1))

print(bit.sum(bit.size))
```