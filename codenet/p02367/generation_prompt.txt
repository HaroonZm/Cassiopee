Voici un énoncé de problème :

Bridges
Find bridges of an undirected graph
G(V, E)
.
A bridge (also known as a cut-edge) is an edge whose deletion increase the number of connected components.
Input
|V|
|E|
s
0
t
0
s
1
t
1
:
s
|E|-1
t
|E|-1
, where
|V|
is the number of nodes and
|E|
is the number of edges in the graph. The graph nodes are named with the numbers 0, 1,...,
|V|
-1 respectively.
s
i
and
t
i
represent source and target nodes of
i
-th edge (undirected).
Output
A list of
bridges
of the graph ordered by name. For each bridge, names of its end-ponints, source and target (source < target), should be printed separated by a space. The sources should be printed ascending order, then the target should also be printed ascending order for the same source.
Constraints
1 ≤
|V|
≤ 100,000
0 ≤
|E|
≤ 100,000
The graph is connected
There are no parallel edges
There are no self-loops
Sample Input 1
4 4
0 1
0 2
1 2
2 3
Sample Output 1
2 3
Sample Input 2
5 4
0 1
1 2
2 3
3 4
Sample Output 2
0 1
1 2
2 3
3 4


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def solve():
    N, M = map(int, input().split())
    edges = [[] for _ in [0] * N]
    for _ in [0] * M:
        a, b = map(int, input().split())
        edges[a].append(b)
        edges[b].append(a)
    bridges = sorted((a, b) if a < b else (b, a) for a, b in get_lowlink(edges, M)[0])
    for a, b in bridges:
        print(a, b)

def get_lowlink(edges, edge_num):
    import sys
    sys.setrecursionlimit(10**7)

    n = len(edges)
    order = [-1] * n
    low = [float("inf")] * n
    bridges = []
    articulations = [0] if edge_num == n-1 and len(edges[0]) > 1 else []
    append_bridge, append_articulation = bridges.append, articulations.append

    def dfs(v, prev, k):
        order[v] = low[v] = k

        is_articulation = False
        for dest in edges[v]:
            if order[dest] == -1:
                dfs(dest, v, k + 1)
                if low[v] > low[dest]:
                    low[v] = low[dest]
                if order[v] < low[dest]:
                    append_bridge((v, dest))
                is_articulation |= order[v] <= low[dest]

            elif dest != prev and low[v] > order[dest]:
                low[v] = order[dest]

        if v > 0 and is_articulation:
            append_articulation(v)

    dfs(0, 0, 0)
    return bridges, articulations

if __name__ == "__main__":
    solve()
```