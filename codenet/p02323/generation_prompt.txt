Voici un énoncé de problème :

Traveling Salesman Problem
For a given weighted directed graph
G(V, E)
, find the distance of the shortest route that meets the following criteria:
It is a closed cycle where it ends at the same point it starts.
It visits each vertex exactly once.
Input
|V|
|E|
s
0
t
0
d
0
s
1
t
1
d
1
:
s
|E|-1
t
|E|-1
d
|E|-1
|V|
is the number of vertices and
|E|
is the number of edges in the graph. The graph vertices are named with the numbers 0, 1,...,
|V|
-1 respectively.
s
i
and
t
i
represent source and target vertices of
i
-th edge (directed) and
d
i
represents the distance between
s
i
and
t
i
(the
i
-th edge).
Output
Print the shortest distance in a line. If there is no solution, print -1.
Constraints
2 ≤
|V|
≤ 15
0 ≤
d
i
≤ 1,000
There are no multiedge
Sample Input 1
4 6
0 1 2
1 2 3
1 3 9
2 0 1
2 3 6
3 2 4
Sample Output 1
16
Sample Input 2
3 3
0 1 1
1 2 1
0 2 1
Sample Output 2
-1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# https://www.slideshare.net/hcpc_hokudai/advanced-dp-2016 動的計画法の問題の解説がされている 神

# これが比較的わかりやすいかも https://algo-logic.info/bit-dp/

'''
定式化(本は"集める"DPで定義してるが、わかりやすさのため"配る"DPで定式化)

ノーテーション
S ... 頂点集合
| ... 和集合演算子
dp[S][v] ... 重みの総和の最小。頂点0から頂点集合Sを経由してvに到達する。

更新則
dp[S|{v}] = min{dp[S][u]+d(u,v) | u∈S} ただしv∉S

初期条件
dp[∅][0] = 0 #Vはあらゆる集合
dp[V][u] = INF #ほかはINFで初期化しておく

答え
dp[すべての要素][0] ... 0からスタートしてすべての要素を使って最後に0に戻るための最小コスト
'''

# verify https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/all/DPL_2_A
INF = 2 ** 31
from itertools import product

def solve(n, graph):
    '''nは頂点数、graphは隣接行列形式'''
    max_S = 1 << n  # n個のbitを用意するため
    dp = [[INF] * n for _ in range(max_S)]
    dp[0][0] = 0
    for S in range(max_S):
        for u, v in product(range(n), repeat=2):
            if (S >> v) & 1 == 1:  # vが訪問済みの場合は飛ばす
                continue
            dp[S | (1 << v)][v] = min(dp[S | (1 << v)][v],
                                      dp[S][u] + graph[u][v])
    print(dp[-1][0] if dp[-1][0] != INF else -1)

# # 入力例
# n = 5
# graph = [[INF, 3, INF, 4, INF],
#          [INF, INF, 5, INF, INF],
#          [4, INF, INF, 5, INF],
#          [INF, INF, INF, 0, 3],
#          [7, 6, INF, INF, INF]]
# solve(n, graph)

# verify用
n, e = map(int, input().split())
graph = [[INF] * n for _ in range(n)]
for _ in range(e):
    s, t, d = map(int, input().split())
    graph[s][t] = d
solve(n, graph)
```