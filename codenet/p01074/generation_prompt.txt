En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from itertools import product

n, m, l = map(int, input().split())
subjects = [[] for _ in range(5)]
for _ in range(m):
    d, a, k, t = map(int, input().split())
    subjects[d].append((a, a + k - 1, t))

for i in range(5):
    subjects[i].sort(key=lambda x:x[1])
 
#各曜日の科目数ごとの最大幸福
def calcDp(i):
    #dp[y][x] ... y科目xコマまでの最大幸福
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    sub = subjects[i]
    for init, end, value in sub:
        for y in range(n):
            new_score = dp[y][init - 1] + value
            for x in range(end, n + 1):
                dp[y + 1][x] = max(dp[y + 1][x], new_score)
    ret = []
    for i in range(n + 1):
        ret.append(max(dp[i]))
    return ret

lst = [calcDp(i) for i in range(5)]

ans = 0
for t in product(range(n + 1), repeat=5):
    if sum(t) > l:continue
    score = 0
    for i, v in enumerate(t):
        score += lst[i][v]
    ans = max(score, ans)
print(ans)
```