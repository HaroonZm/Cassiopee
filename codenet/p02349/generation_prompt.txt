Voici un énoncé de problème :

Range Add Query (RAQ)
Write a program which manipulates a sequence
A
= {
a
1
, a
2
, . . . , a
n
} with the following operations:
add(s, t, x)
: add
x
to
a
s
,
a
s+1
, ...,
a
t
.
get(i)
: output the value of
a
i
.
Note that the initial values of
a
i
(
i = 1, 2, . . . , n
) are 0.
Input
n
q
query
1
query
2
:
query
q
In the first line,
n
(the number of elements in
A
) and
q
(the number of queries) are given. Then,
i
th query
query
i
is given in the following format:
0
s
t
x
or
1
t
The first digit represents the type of the query. '0' denotes
add(s, t, x)
and '1' denotes
get(i)
.
Output
For each
get
operation, print the value.
Constraints
1 ≤ n ≤ 100000
1 ≤ q ≤ 100000
1 ≤ s ≤ t ≤ n
1 ≤ i ≤ n
0 ≤ x ≤ 1000
Sample Input 1
3 5
0 1 2 1
0 2 3 2
0 3 3 3
1 2
1 3
Sample Output 1
3
5
Sample Input 2
4 3
1 2
0 1 4 1
1 2
Sample Output 2
0
1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
class SegmentTree:
    seg_len = 1
    node = []
    def __init__(self, n):
        while self.seg_len < n:
            self.seg_len <<= 1
        self.node = [ 0 for _ in range(self.seg_len*2) ]

    def add(self, l, r, x):
        l += self.seg_len
        r += self.seg_len
        while l < r:
            if l & 1 == 1:
                self.node[l] += x
                l += 1
            if r & 1 == 1:
                self.node[r-1] += x
                r -= 1
            l >>= 1; r >>= 1;

    def get(self, idx):
        idx += self.seg_len
        ret = self.node[idx]
        while True:
            idx >>= 1
            if idx == 0:
                break
            ret += self.node[idx]
        return ret

n, q = map(int, input().split())
seg_tree = SegmentTree(n)

for _ in range(q):
    query = [ int(x) for x in input().split() ]
    if len(query) == 4:
        _, l, r, x = query
        l -= 1; r -= 1
        seg_tree.add(l, r+1, x)
    if len(query) == 2:
        _, i = query
        i -= 1;
        print(seg_tree.get(i))
```