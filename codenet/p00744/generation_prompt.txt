Voici un énoncé de problème :

Problem E:
Cards
There are many blue cards and red cards on the table.
For each card, an integer number greater than 1 is printed on its face.
The same number may be printed on several cards.
A blue card and a red card can be paired when both of the numbers
printed on them have a common divisor greater than 1.
There may be more than one red card that can be paired with one blue card.
Also, there may be more than one blue card that can be paired with one red card.
When a blue card and a red card are chosen and paired,
these two cards are removed from the whole cards on the table.
Figure E-1: Four blue cards and three red cards
For example, in Figure E-1,
there are four blue cards and three red cards.
Numbers 2, 6, 6 and 15 are printed on the faces of the four blue cards,
and 2, 3 and 35 are printed on those of the three red cards.
Here, you can make pairs of blue cards and red cards as follows.
First,
the blue card with number 2 on it and the red card with 2 are paired and removed.
Second,
one of the two blue cards with 6 and the red card with 3 are paired and removed.
Finally,
the blue card with 15 and the red card with 35 are paired and removed.
Thus the number of removed pairs is three.
Note that the total number of the pairs depends on
the way of choosing cards to be paired.
The blue card with 15 and the red card with 3 might be paired
and removed at the beginning.
In this case, there are only one more pair that can be removed
and the total number of the removed pairs is two.
Your job is to find the largest number of pairs that can be removed from the given set of cards on the table.
Input
The input is a sequence of datasets.
The number of the datasets is less than or equal to 100.
Each dataset is formatted as follows.
m
n
b
1
...
b
k
...
b
m
r
1
...
r
k
...
r
n
The integers
m
and
n
are the number of blue cards
and that of red cards, respectively.
You may assume 1 ≤
m
≤ 500 and 1≤
n
≤ 500.
b
k
(1 ≤
k
≤
m
) and
r
k
(1 ≤
k
≤
n
) are
numbers printed on the blue cards and the red cards respectively,
that are integers greater than or equal to 2 and less than
10000000 (=10
7
).
The input integers are separated by a space or a newline.
Each of
b
m
and
r
n
is
followed by a newline.
There are no other characters in the dataset.
The end of the input is indicated by a line containing two zeros
separated by a space.
Output
For each dataset, output a line containing an integer that indicates
the maximum of the number of the pairs.
Sample Input
4 3
2 6 6 15
2 3 5
2 3
4 9
8 16 32
4 2
4 9 11 13
5 7
5 5
2 3 5 1001 1001
7 11 13 30 30
10 10
2 3 5 7 9 11 13 15 17 29
4 6 10 14 18 22 26 30 34 38
20 20
195 144 903 63 137 513 44 626 75 473
876 421 568 519 755 840 374 368 570 872
363 650 155 265 64 26 426 391 15 421
373 984 564 54 823 477 565 866 879 638
100 100
195 144 903 63 137 513 44 626 75 473
876 421 568 519 755 840 374 368 570 872
363 650 155 265 64 26 426 391 15 421
373 984 564 54 823 477 565 866 879 638
117 755 835 683 52 369 302 424 513 870
75 874 299 228 140 361 30 342 750 819
761 123 804 325 952 405 578 517 49 457
932 941 988 767 624 41 912 702 241 426
351 92 300 648 318 216 785 347 556 535
166 318 434 746 419 386 928 996 680 975
231 390 916 220 933 319 37 846 797 54
272 924 145 348 350 239 563 135 362 119
446 305 213 879 51 631 43 755 405 499
509 412 887 203 408 821 298 443 445 96
274 715 796 417 839 147 654 402 280 17
298 725 98 287 382 923 694 201 679 99
699 188 288 364 389 694 185 464 138 406
558 188 897 354 603 737 277 35 139 556
826 213 59 922 499 217 846 193 416 525
69 115 489 355 256 654 49 439 118 961
0 0
Output for the Sample Input
3
1
0
4
9
18
85


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import collections
import fractions

class Dinic:
    """Dinic Algorithm: find max-flow
       complexity: O(EV^2)
       used in GRL6A(AOJ)
    """
    class edge:
        def __init__(self, to, cap, rev):
            self.to, self.cap, self.rev = to, cap, rev

    def __init__(self, V, E, source, sink):
        """ V: the number of vertexes
            E: adjacency list
            source: start point
            sink: goal point
        """
        self.V = V
        self.E = [[] for _ in range(V)]
        for fr in range(V):
            for to, cap in E[fr]:
                self.E[fr].append(self.edge(to, cap, len(self.E[to])))
                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))
        self.maxflow = self.dinic(source, sink)

    def dinic(self, source, sink):
        """find max-flow"""
        INF = float('inf')
        maxflow = 0
        while True:
            self.bfs(source)
            if self.level[sink] < 0:
                return maxflow
            self.itr = [0] * self.V
            while True:
                flow = self.dfs(source, sink, INF)
                if flow > 0:
                    maxflow += flow
                else:
                    break

    def dfs(self, vertex, sink, flow):
        """find augmenting path"""
        if vertex == sink:
            return flow
        for i in range(self.itr[vertex], len(self.E[vertex])):
            self.itr[vertex] = i
            e = self.E[vertex][i]
            if e.cap > 0 and self.level[vertex] < self.level[e.to]:
                d = self.dfs(e.to, sink, min(flow, e.cap))
                if d > 0:
                    e.cap -= d
                    self.E[e.to][e.rev].cap += d
                    return d
        return 0

    def bfs(self, start):
        """find shortest path from start"""
        que = collections.deque()
        self.level = [-1] * self.V
        que.append(start)
        self.level[start] = 0

        while que:
            fr = que.popleft()
            for e in self.E[fr]:
                if e.cap > 0 and self.level[e.to] < 0:
                    self.level[e.to] = self.level[fr] + 1
                    que.append(e.to)

while True:
    M, N = map(int, input().split())
    if M == 0 and N == 0:
        break
    blue, red = [], []
    while True:
        for x in input().split():
            blue.append(int(x))
        if len(blue) == M:
            break
    while True:
        for x in input().split():
            red.append(int(x))
        if len(red) == N:
            break
    V = M + N + 2
    edge = [[] for _ in range(V)]
    for i, b in enumerate(blue):
        for j, r in enumerate(red):
            if fractions.gcd(b, r) != 1:
                edge[i].append((M+j, 1))
    for i in range(M):
        edge[M+N].append((i, 1))
    for j in range(N):
        edge[M+j].append((M+N+1, 1))
    print(Dinic(V, edge, M+N, M+N+1).maxflow)
```