Voici un énoncé de problème :

D: パスワード
問題
AOR イカちゃんは英小文字のみからなる強力なパスワードを作りたいと思っています。
友達から $N$ 個の危険なパスワードの例を教えてもらった AOR イカちゃんは、
以下の条件を全て満たすようなパスワードを作ることにしました。
長さは1文字以上である。
どの危険なパスワードの、どの連続した部分文字列とも異なる。
1, 2 の条件を満たした中で、最も短い文字列である。
1,2,3の条件を満たした中で、辞書順に並べたとき先頭に来る文字列である。
AOR イカちゃんに代わって強力なパスワードを生成するプログラムを書いてください。
入力
入力は以下の形式で標準入力から与えられる。
$N$
$S_1$
$\vdots$
$S_N$
1 行目には、文字列の数を表す整数 $N$ が与えられる。
2 行目からの $N$ 行には、文字列 $S_i$ が与えられる。
$|S_i|$ とは文字列の長さであり、1 文字以上である。
$1 \le N \le 100,000$ を満たす。
$1 \le \sum_{1\le i \le N} |S_i| \le 400,000$ を満たす。
文字列は英小文字のみを含む。
出力
答えを 1 行で出力せよ。また、末尾に改行も出力せよ。
サンプル
サンプル入力 1
5
password
login
admin
root
master
サンプル出力 1
b
サンプル入力 2
3
abcdefghijklmnopqrstuvwxy
qwertyuiopasdfghjklxcvbnm
qawsxedcrfvtgbyhnujmikolp
サンプル出力 2
z
サンプル入力 3
1
abcdefghijklmnopqrstuvwxyz
サンプル出力 3
aa


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def make_alphabet(now_alphabet, alphabet):
    next_alphabet = []
    for n_al in now_alphabet:
        for al in alphabet:
            next_alphabet.append(n_al+al)
    return next_alphabet

a = int(input())
b = []
for a in range(a):
    b.append(input())
alphabet = [chr(ch) for ch in range(97,123)]
now_alphabet = alphabet
count=0
flag=0

while flag==0:
    letter = []
    for word in b:
        for i in range(len(word)-count):
            letter.append(word[i:i+1+count])
    rem = list(set(now_alphabet) - set(letter))
    if rem!=[]:
        print(sorted(rem)[0])
        flag=1
    count+=1
    now_alphabet = make_alphabet(now_alphabet, alphabet)
```