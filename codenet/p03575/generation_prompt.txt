Voici un énoncé de problème :

Score :
300
points
Problem Statement
You are given an undirected connected graph with
N
vertices and
M
edges that does not contain self-loops and double edges.
The
i
-th edge
(1 \leq i \leq M)
connects Vertex
a_i
and Vertex
b_i
.
An edge whose removal disconnects the graph is called a
bridge
.
Find the number of the edges that are bridges among the
M
edges.
Notes
A
self-loop
is an edge
i
such that
a_i=b_i
(1 \leq i \leq M)
.
Double edges
are a pair of edges
i,j
such that
a_i=a_j
and
b_i=b_j
(1 \leq i<j \leq M)
.
An undirected graph is said to be
connected
when there exists a path between every pair of vertices.
Constraints
2 \leq N \leq 50
N-1 \leq M \leq min(N(N−1)⁄2,50)
1 \leq a_i<b_i \leq N
The given graph does not contain self-loops and double edges.
The given graph is connected.
Input
Input is given from Standard Input in the following format:
N
M
a_1
b_1
a_2
b_2
:
a_M
b_M
Output
Print the number of the edges that are bridges among the
M
edges.
Sample Input 1
7 7
1 3
2 7
3 4
4 5
4 6
5 6
6 7
Sample Output 1
4
The figure below shows the given graph:
The edges shown in red are bridges. There are four of them.
Sample Input 2
3 3
1 2
1 3
2 3
Sample Output 2
0
It is possible that there is no bridge.
Sample Input 3
6 5
1 2
2 3
3 4
4 5
5 6
Sample Output 3
5
It is possible that every edge is a bridge.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import copy

def main():
    """
    自己ループを含まない
    二重辺を含まない: 点AからBへの辺は１つ(以下)
    連結グラフ：任意の点から任意の点に移動できる

    ある辺を取り除くと非連結になる場合、その辺を橋という
    →橋がなくなるとたどり着けない

    N: <=50
    M: <= 50

    ある辺を取り除いてすべてのノードにたどり着けるか
    すべてのノードを列挙する
    ノードを辿ってみる（探索アルゴリズム）
    たどれたらたどれたノードをため込む
    終わったら列挙したノードと比較して同じならOK
    """
    N, M = map(int, input().split())
    e = set()
    for _ in range(M):
        a, b = map(int, input().split())
        e.add((a, b))

    ans = 0
    for k in e:
        searched = set()
        e_copy = copy.deepcopy(e)
        e_copy.remove(k)

        def dfs(v1):
            searched.add(v1)
            for v2 in range(1, N + 1):
                if v2 in searched:
                    continue
                if (v1, v2) in e_copy or \
                        (v2, v1) in e_copy:
                    dfs(v2)

        dfs(1)
        if len(searched) < N:
            ans += 1

    print(ans)

if __name__ == '__main__':
    main()
```