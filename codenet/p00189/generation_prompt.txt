En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
import math
import fractions
import itertools
from collections import deque
import copy
import bisect
import heapq

MOD = float('inf')
INF = 10 ** 18 + 7
input = lambda: sys.stdin.readline().strip()

def warshall_floyd(d):
    """
    d[i][l]がi→lへのコストを示す隣接行列
    結果としてd[i][l]はi→lへの最短コストになる。
    """
    for i in range(len(d)):
        for l in range(len(d)):
            for k in range(len(d)):
                d[l][k] = min(d[l][k], d[l][i] + d[i][k])
    return d

while True:
    n = int(input())
    if n == 0:
        break
    else:
        abc = [list(map(int, input().split())) for _ in range(n)]
        info = [[INF for _ in range(10)] for _ in range(10)]
        for i in range(10):
            info[i][i] = 0
        for i in abc:
            info[i[0]][i[1]] = i[2]
            info[i[1]][i[0]] = i[2]
        result = warshall_floyd(info)
        ans = []
        for i in result:
            for l in range(len(i)):
                if i[l] == INF:
                    i[l] = 0
        for i in range(10):
            if sum(result[i]) != 0:
                ans.append([sum(result[i]), i])
        ans.sort()
        print(ans[0][1], ans[0][0])
```