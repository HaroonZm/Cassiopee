Voici un énoncé de problème :

Problem C:
Brave Princess Revisited
ある貧乏な国のおてんばで勇敢なお姫様が，政略結婚のため別の国に嫁ぐことになった．ところがお姫様を亡き者としようとしている悪漢が嫁ぎ先への道の途中で刺客を放っている．
お姫様を無事に相手国に送り届けるため，あなたは安全な経路を既に決定していたのだが，お姫様の今までに通ったことのない道を通ってみたいという
わがままな
たっての願いで別の道を通ることとなった．そこであなたは地図を見ながらお姫様が通る道を決めなおすことにした．
全ての道は，宿場同士をつなぐ街道である．便宜上，出発地点及び目的地点も宿場とする．ところが，新しい道は治安の問題を抱えていた．盗賊やお姫様を亡き者にしようとする刺客が襲いかかってくる可能性が高いのである．
そのような危険な道を通るには護衛を雇うことが望ましい．護衛は宿場で雇うことができ，道単位で姫を守らせることができる．護衛が守っている間は盗賊や刺客に襲われることはないが，距離 1 につき金 1 がかかる．そのため，護衛を雇うためには所持金よりも次の宿場までの距離が長くないことが条件となる．
いま，与えられた予算
L
のもとで，姫が無事に目的地に着くまでに襲いかかってくる盗賊や刺客の人数を最小化することを考える．あなたの仕事は，その最小化された人数を求めることである．なお，宿場にいる間に襲われることはないものとする．
Input
入力は複数のデータセットからなる．各データセットは次の形式をしている．
N
M
L
A
1
B
1
D
1
E
1
A
2
B
2
D
2
E
2
...
A
M
B
M
D
M
E
M
最初の行には 3 つの非負の整数
N
(2 ≤
N
≤ 100)，
M
，
L
(0 ≤
L
≤ 100) が与えられる．これらの整数は，宿場の数，道の数，護衛を雇うための予算を表す．宿場には 1 から
N
までの番号が割り振られており，出発地には 1 ，目的地には
N
の番号がそれぞれ割り振られている．
続く
M
行では道の情報が各行に 1 つずつ与えられる．道の情報は 4 つの整数
A
i
，
B
i
(1 ≤
A
i
<
B
i
≤ N)，
D
i
(1 ≤
D
i
≤ 100)
E
i
(0 ≤
E
i
≤ 10000) で与えられる．これらはそれぞれ，道の始点と終点の宿場の番号，道の距離，盗賊や刺客に襲われる人数を表す．
道は双方向に通行可能であり，かつある宿場の組に対しては高々 1 つの道しか存在しない．また，出発地から目的地には必ず移動可能であることが保証されている．
入力の終わりは，空白で区切られた 3 つの 0 を含む 1 行で示される．
Output
各データセットについて，盗賊や刺客に襲われる人数の最小値を各行に出力せよ．出力に余計な空白や改行を含めてはならない．
Sample Input
3 2 10
1 2 8 6
2 3 10 3
3 2 10
1 2 3 8
2 3 7 7
3 3 10
1 3 17 6
1 2 2 4
2 3 9 13
4 4 5
1 3 9 3
1 4 7 25
2 3 8 2
2 4 9 3
0 0 0
Output for the Sample Input
3
0
4
8


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq
while True:
  n,m,l=map(int,raw_input().split())
  if n==0: break
  v={}
  for i in xrange(n):
    v[i] = []                                                                                                                                    # count attacked
  cost=[[10**9]*(l+1) for _ in xrange(n)]
  cost[0][l] = 0
  for _ in xrange(m):
    a,b,d,e=map(int,raw_input().split())
    a-=1
    b-=1
    v[a].append((b,d,e))
    v[b].append((a,d,e))
  q=[]
  heapq.heappush(q,(0,l))
  while len(q)>0:
    t = heapq.heappop(q)
    for x in v[t[0]]:
      # hit
      if cost[x[0]][t[1]] > cost[t[0]][t[1]]+x[2]:
        cost[x[0]][t[1]] = cost[t[0]][t[1]]+x[2]
        q.append((x[0], t[1]))
      # guard
      if t[1]-x[1]>=0 and cost[x[0]][t[1]-x[1]] > cost[t[0]][t[1]]:
        cost[x[0]][t[1]-x[1]] = cost[t[0]][t[1]]
        q.append((x[0], t[1]-x[1]))
  print min(cost[n-1])
```