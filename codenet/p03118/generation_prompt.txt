Voici un énoncé de problème :

Score :
2718
points
Problem Statement
There is a very long bench.
The bench is divided into
M
sections, where
M
is a very large integer.
Initially, the bench is vacant.
Then,
M
people come to the bench one by one, and perform the following action:
We call a section
comfortable
if the section is currently unoccupied and is not adjacent to any occupied sections.
If there is no comfortable section, the person leaves the bench.
Otherwise, the person chooses one of comfortable sections uniformly at random, and sits there.
(The choices are independent from each other).
After all
M
people perform actions, Snuke chooses an interval of
N
consecutive sections uniformly at random (from
M-N+1
possible intervals), and takes a photo.
His photo can be described by a string of length
N
consisting of
X
and
-
: the
i
-th character of the string is
X
if the
i
-th section from the left in the interval is occupied, and
-
otherwise.
Note that the photo is directed.
For example,
-X--X
and
X--X-
are different photos.
What is the probability that the photo matches a given string
s
?
This probability depends on
M
.
You need to compute the limit of this probability when
M
goes infinity.
Here, we can prove that the limit can be uniquely written in the following format using three
rational
numbers
p, q, r
and
e = 2.718 \ldots
(the base of natural logarithm):
p + \frac{q}{e} + \frac{r}{e^2}
Your task is to compute these three rational numbers, and print them modulo
10^9 + 7
, as described in Notes section.
Notes
When you print a rational number, first write it as a fraction
\frac{y}{x}
, where
x, y
are integers and
x
is not divisible by
10^9 + 7
(under the constraints of the problem, such representation is always possible).
Then, you need to print the only integer
z
between
0
and
10^9 + 6
, inclusive, that satisfies
xz \equiv y \pmod{10^9 + 7}
.
Constraints
1 \leq N \leq 1000
|s| = N
s
consists of
X
and
-
.
Input
Input is given from Standard Input in the following format:
N
s
Output
Print three rational numbers
p, q, r
, separated by spaces.
Sample Input 1
1
X
Sample Output 1
500000004 0 500000003
The probability that a randomly chosen section is occupied converge to
\frac{1}{2} - \frac{1}{2e^2}
.
Sample Input 2
3
---
Sample Output 2
0 0 0
After the actions, no three consecutive unoccupied sections can be left.
Sample Input 3
5
X--X-
Sample Output 3
0 0 1
The limit is
\frac{1}{e^2}
.
Sample Input 4
5
X-X-X
Sample Output 4
500000004 0 833333337
The limit is
\frac{1}{2} - \frac{13}{6e^2}
.
Sample Input 5
20
-X--X--X-X--X--X-X-X
Sample Output 5
0 0 183703705
The limit is
\frac{7}{675e^2}
.
Sample Input 6
100
X-X-X-X-X-X-X-X-X-X--X-X-X-X-X-X-X-X-X-X-X-X-X-X-X--X--X-X-X-X--X--X-X-X--X-X-X--X-X--X--X-X--X-X-X-
Sample Output 6
0 0 435664291


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python3
from collections import defaultdict,deque
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
import sys, random, itertools, math
sys.setrecursionlimit(10**5)
input = sys.stdin.readline
sqrt = math.sqrt
def LI(): return list(map(int, input().split()))
def LF(): return list(map(float, input().split()))
def LI_(): return list(map(lambda x: int(x)-1, input().split()))
def II(): return int(input())
def IF(): return float(input())
def LS(): return list(map(list, input().split()))
def S(): return input().rstrip()
def IR(n): return [II() for _ in range(n)]
def LIR(n): return [LI() for _ in range(n)]
def FR(n): return [IF() for _ in range(n)]
def LFR(n): return [LI() for _ in range(n)]
def LIR_(n): return [LI_() for _ in range(n)]
def SR(n): return [S() for _ in range(n)]
def LSR(n): return [LS() for _ in range(n)]
mod = 1000000007
inf = 1e10
fc = [1] * 1010
ifc = [1] * 1010
Bn = [0] * 1010

def ad(x, y=0):
    return (x + y) % mod

def mlt(x, y=1):
    return (x * y) % mod
    
def pwr(x, y):
    return pow(x, y, mod)

def inv(x):
    return pwr(x, mod - 2)

def bn(x):
    if x > 0 and Bn[x] == 0: Bn[x] = ad(1, mlt(x, bn(x - 1)))
    return Bn[x]

#solve
def solve():
    for i in range(1, 1010): fc[i] = fc[i - 1] * i
    for i in range(1010): ifc[i] = inv(fc[i])
    num = 1
    dp = [[[0] * 1010 for _ in range(2)] for k in range(1010)]
    dpc = [0] * 1010
    f = [False] * 1010
    n = II()
    s = S()
    if n == 1 and s == "-":
        print("{} 0 {}".format((mod + 1) // 2, (mod + 1) // 2))
        return
    q = 0
    r = n
    n = -1
    if s[q] == "-":
        q += 1
    if s[q] == "-":
        q += 1
        n += 1
        num += 1
    if s[q] == "-":
        print("0 0 0")
        return
    for i in range(q, r):
        if s[i] == "X":
            if num == 0:
                print("0 0 0")
                return
            if n >= 0:
                f[n] = num - 1
            n += 1
            num = 0
        else:
            if num > 1:
                print("0 0 0")
                return
            num += 1
    if num == 2:
        f[n] = 1
        n += 1
    dpc[0] = 1
    for i in range(n):
        if f[i]:
            for j in range(2):
                for k in range(2 * n + 2):
                    kari = inv(k * k + 3 * k + 2)
                    dp[i + 1][j][0] = ad(dp[i + 1][j][0], mlt(dp[i][j][k], kari))
                    dp[i + 1][j][1] = ad(dp[i + 1][j][1], mlt(dp[i][j][k], mod - kari))
            dp[i + 1][1][0] = ad(dp[i + 1][1][0], dpc[i])
            dp[i + 1][1][1] = ad(dp[i + 1][1][1], mod - dpc[i])
        else:
            for j in range(2):
                for k in range(2 * n + 2):
                    kari = inv(k + 1)
                    dp[i + 1][j][0] = ad(dp[i + 1][j][0], mlt(dp[i][j][k], kari))
                    dp[i + 1][j][1] = ad(dp[i + 1][j][1], mlt(dp[i][j][k], mod - kari))
                    dp[i + 1][j][k + 2] = ad(dp[i + 1][j][k + 2], mlt(dp[i][j][k], inv(k * k + 3 * k + 2)))
            dp[i + 1][1][1] = ad(dp[i + 1][1][1], dpc[i])
            dp[i + 1][1][0] = ad(dp[i + 1][1][0], mod - dpc[i])
            dpc[i + 1] = ad(dpc[i + 1], dpc[i])
    ans = [0] * 3
    for j in range(2):
        for k in range(2 * n + 2):
            ans[j] = ad(ans[j], mlt(dp[n][j][k], fc[k]))
            ans[j + 1] = ad(ans[j + 1], mlt(dp[n][j][k], mod - ad(fc[k], bn(k))))
    kari = (mod + 1) // 2
    ans[0] = ad(ans[0], mlt(dpc[n], kari))
    ans[2] = ad(ans[2], mlt(dpc[n], mod - kari))
    print("{} {} {}".format(ans[0], ans[1], ans[2]))
    return

#main
if __name__ == '__main__':
    solve()
```