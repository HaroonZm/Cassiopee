Voici un énoncé de problème :

Score :
500
points
Problem Statement
You have a string
A = A_1 A_2 ... A_n
consisting of lowercase English letters.
You can choose any two indices
i
and
j
such that
1 \leq i \leq j \leq n
and reverse substring
A_i A_{i+1} ... A_j
.
You can perform this operation at most once.
How many different strings can you obtain?
Constraints
1 \leq |A| \leq 200,000
A
consists of lowercase English letters.
Input
Input is given from Standard Input in the following format:
A
Output
Print the number of different strings you can obtain by reversing any substring in
A
at most once.
Sample Input 1
aatt
Sample Output 1
5
You can obtain
aatt
(don't do anything),
atat
(reverse
A[2..3]
),
atta
(reverse
A[2..4]
),
ttaa
(reverse
A[1..4]
) and
taat
(reverse
A[1..3]
).
Sample Input 2
xxxxxxxxxx
Sample Output 2
1
Whatever substring you reverse, you'll always get
xxxxxxxxxx
.
Sample Input 3
abracadabra
Sample Output 3
44


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import bisect
import collections
import copy
import functools
import heapq
import math
import sys
from collections import deque
from collections import defaultdict
input = sys.stdin.readline
sys.setrecursionlimit(10**9)
MOD = 10**9+7

A = input().rstrip()
d = defaultdict(int)
for i in range(len(A)):
    d[A[i]] += 1
    
s = 0
for k in d.keys():
    s += d[k]

ans = 0
for k in d.keys():
    s -= d[k]
    ans += d[k]*s
print(ans+1)
```