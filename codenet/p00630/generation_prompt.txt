Voici un énoncé de problème :

Problem P04:
CamelCase
プログラミングにおける識別子（変数や関数）の命名では、
単語を連結した複合語が使われる。
しかし、そのまま連結すると単語の区切りがわからなくなるため、
一般的に以下の命名規則の中から統一するものを選び適用する：
Upper CamelCase　にする
単語を直接連結し複合語とし、各単語の先頭文字のみを大文字にする。
例： GetUserName
Lower CamelCase　にする
単語を直接連結し複合語とし、各単語の先頭文字のみを大文字にする。ただし、複合語の先頭文字は小文字にする。
例： getUserName
アンダースコアで繋ぐ
単語をアンダースコアで連結し複合語とする。単語の文字はすべて小文字にする。
例： get_user_name
与えられた識別子を、指定された命名規則を適用して出力するプログラムを作成せよ。
与えられる識別子は、上記の命名規則のいづれかが既に適用されているものとする。
Input
入力として複数のデータセットが与えられる。各データセットは以下の形式で与えられる：
name
type
（識別子、命名規則：　空白区切りの文字列と文字）
type
は命名規則を示す文字であり、以下の表の通りとする：
type
命名規則
U
Upper CamelCase にする
L
Lower CamelCase にする
D
アンダースコアで繋ぐ
与えられる識別子の文字数は 1 以上 100 以下である。
type
が '
X
' のとき入力の終わりとする。この入力に対する出力を行ってはならない。
Output
各データセットについて、命名規則を適用した識別子を1行に出力せよ。
Sample Input
get_user_name L
getUserName U
GetUserName D
EndOfInput X
Output for the Sample Input
getUserName
GetUserName
get_user_name


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
while True:
    s, cc = input().split()
    if cc == "X":break
    if "_" in s:
        t = s.split("_")
    else:
        t = []
        j = 0
        for i in range(1, len(s)):
            if s[i].isupper():
                t.append(s[j:i])
                j = i
        t.append(s[j:])
    if cc == "U":
        for i in range(len(t)):t[i] = t[i][0].upper() + t[i][1:]
        print("".join(t))
    elif cc == "L":
        t[0] = t[0].lower()
        for i in range(1, len(t)):t[i] = t[i][0].upper() + t[i][1:]
        print("".join(t))
    else:
        for i in range(len(t)):t[i] = t[i].lower()
        print("_".join(t))
```