Voici un énoncé de problème :

E: 卒業式
背景
ある日 Y さんはプログラミングコンテストに参加するため，会場がある大学に向かいました．
ところが大学に着くと人がたくさん！なんと今日は卒業式だったのです．
会場に向かおうにも人に押し流されてしまい，自分の進みたい方向に進むことすらできません．
人混みから抜け出すために，Y さんは今いる場所から少しでも遠くに行きたいと考えました．
そこで Y さんは状況を以下のような問題として定式化し，競技プログラミングを役に立てることにしました．
なお，以下の問題文では Y さんは点 $P$ としてモデル化されています．
問題
座標平面上の原点に点 $P$ が置かれている．
点 $P$ を動かし，できるだけ原点からのマンハッタン距離が遠い位置に移動させたい．
はじめに，文字列 $S = s_1s_2 \cdots s_{|S|}$ ($|S|$ は $S$ の文字数) が与えられる．
点 $P$ の移動は，文字列 $S$ の先頭から文字を 1 文字ずつ読み込むことで行う．
文字列 $S$ は文字 'U', 'L', 'D', 'R' からなる．
それぞれの文字を読み込んだとき，点 $P$ の移動前の座標を $(x, y)$ とすると，
移動後の点 $P$ の座標はそれぞれ $(x, y+1),\ (x-1, y),\ (x, y-1),\ (x+1, y)$ となる．
各文字を読み込む直前に，魔法をかけるか否かを選択することができる．
魔法には魔法 1 と魔法 2 の二種類がある．文字列 $S$ の $i$ 番目の文字を $s_i$ とすると，
$s_i$ を読み込む直前に魔法をかけたときの変化は以下の通りである．
魔法 1 をかけたとき: 全ての $s_j \ (i \le j \le |S|)$ に対し，'U' を 'D' に，'D' を 'U' に置換する．
魔法 2 をかけたとき: 全ての $s_j \ (i \le j \le |S|)$ に対し，'L' を 'R' に，'R' を 'L' に置換する．
直感的には，魔法 1 ではその後の上下の扱いを反転させることができ，魔法 2 では左右の扱いを反転させることができる．
ある文字を読み込む前にかける魔法の回数は複数回でも構わない．また，両方の魔法を続けてかけてもかまわない．
ただし，文字列 $S$ の文字をすべて読み終えるまでに魔法をかけられる回数は，合計 $K$ 回までである．
詳細はサンプルを参照されたい．
文字列 $S$ の文字をすべて読み終えた後の点 $P$ の座標を $(x',y')$ とするとき，$|x'| + |y'|$
の最大値を求めよ．
制約
$1 \le |S| \le 2000$
$1 \le K \le 2000$
入力
入力は以下の形式で標準入力から与えられる．
$S$
$K$
出力
$|x'| + |y'|$ の最大値を 1 行で出力せよ．また、末尾に改行も出力せよ.
サンプル
サンプル入力 1
RRLUDDD
2
サンプル出力 1
7
3 文字目を読み込む直前に魔法 2 をかけると，文字列 $S$ は "RRRUDDD" となる．
続いて 5 文字目を読み込む直前に魔法 1 をかけると，文字列 $S$ は "RRRUUUU" となる．
すべての文字を読み終えた後の点 $P$ の座標は $(3, 4)$ となり，
原点からのマンハッタン距離は 7 である．これはこの例の最大値である．
サンプル入力 2
LULLLUULLU
1984
サンプル出力 2
10
1 回も魔法をかけなかった場合，$x’ = -6, \ y’ = 4$ となり，$|x’| + |y’| = 10$ である．
サンプル入力 3
DRDLUDD
1
サンプル出力 3
5
サンプル入力 4
LURRRLUDLL
1
サンプル出力 4
6


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def main():
  s = input()
  k = int(input())
  lrs = []
  uds = []
  for c in s:
    if c == "R":
      lrs.append(1)
    if c == "L":
      lrs.append(-1)
    if c == "U":
      uds.append(-1)
    if c == "D":
      uds.append(1)
  lr_length = len(lrs)
  ud_length = len(uds)
  
  lr_dp1 = [0] * (lr_length + 1)
  lr_dp2 = [0] * (lr_length + 1)
  for i in lrs:
    for j in range(lr_length, 0, -1):
      lr_dp1[j] = max(lr_dp1[j], lr_dp1[j - 1]) + i * (-1) ** j
      lr_dp2[j] = min(lr_dp2[j], lr_dp2[j - 1]) + i * (-1) ** j
    lr_dp1[0] += i
    lr_dp2[0] += i
  
  ud_dp1 = [0] * (ud_length + 1)
  ud_dp2 = [0] * (ud_length + 1)
  for i in uds:
    for j in range(ud_length, 0, -1):
      ud_dp1[j] = max(ud_dp1[j], ud_dp1[j - 1]) + i * (-1) ** j
      ud_dp2[j] = min(ud_dp2[j], ud_dp2[j - 1]) + i * (-1) ** j
    ud_dp1[0] += i
    ud_dp2[0] += i
  
  lr_acc = [abs(lr_dp1[0])]
  for i in range(1, lr_length + 1):
    lr_acc.append(max(lr_acc[-1], abs(lr_dp1[i]), abs(lr_dp2[i])))
  
  ud_acc = [abs(ud_dp1[0])]
  for i in range(1, ud_length + 1):
    ud_acc.append(max(ud_acc[-1], abs(ud_dp1[i]), abs(ud_dp2[i])))
  
  ans = 0
  for i in range(min(k + 1, lr_length + 1)):
    ans = max(ans, lr_acc[i] + ud_acc[min(k - i, ud_length)])
  print(ans)

main()
```