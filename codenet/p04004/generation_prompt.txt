Voici un énoncé de problème :

Score :
1100
points
Problem Statement
Alice, Bob and Charlie are playing
Card Game for Three
, as below:
At first, each of the three players has a deck consisting of some number of cards. Alice's deck has
N
cards, Bob's deck has
M
cards, and Charlie's deck has
K
cards. Each card has a letter
a
,
b
or
c
written on it. The orders of the cards in the decks cannot be rearranged.
The players take turns. Alice goes first.
If the current player's deck contains at least one card, discard the top card in the deck. Then, the player whose name begins with the letter on the discarded card, takes the next turn. (For example, if the card says
a
, Alice takes the next turn.)
If the current player's deck is empty, the game ends and the current player wins the game.
There are
3^{N+M+K}
possible patters of the three player's initial decks. Among these patterns, how many will lead to Alice's victory?
Since the answer can be large, print the count modulo
1\,000\,000\,007 (=10^9+7)
.
Constraints
1 \leq N \leq 3×10^5
1 \leq M \leq 3×10^5
1 \leq K \leq 3×10^5
Partial Scores
500
points will be awarded for passing the test set satisfying the following:
1 \leq N \leq 1000
,
1 \leq M \leq 1000
,
1 \leq K \leq 1000
.
Input
The input is given from Standard Input in the following format:
N
M
K
Output
Print the answer modulo
1\,000\,000\,007 (=10^9+7)
.
Sample Input 1
1 1 1
Sample Output 1
17
If Alice's card is
a
, then Alice will win regardless of Bob's and Charlie's card. There are
3×3=9
such patterns.
If Alice's card is
b
, Alice will only win when Bob's card is
a
, or when Bob's card is
c
and Charlie's card is
a
. There are
3+1=4
such patterns.
If Alice's card is
c
, Alice will only win when Charlie's card is
a
, or when Charlie's card is
b
and Bob's card is
a
. There are
3+1=4
such patterns.
Thus, there are total of
9+4+4=17
patterns that will lead to Alice's victory.
Sample Input 2
4 2 2
Sample Output 2
1227
Sample Input 3
1000 1000 1000
Sample Output 3
261790852


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

import numpy as np

N,M,K = map(int,read().split())

MOD = 10 ** 9 + 7

def cumprod(arr,MOD):
    L = len(arr); Lsq = int(L**.5+1)
    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)
    for n in range(1,Lsq):
        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD
    for n in range(1,Lsq):
        arr[n] *= arr[n-1,-1]; arr[n] %= MOD
    return arr.ravel()[:L]

def make_fact(U,MOD):
    x = np.arange(U,dtype=np.int64); x[0] = 1
    fact = cumprod(x,MOD)
    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)
    fact_inv = cumprod(x,MOD)[::-1]
    return fact,fact_inv

def make_power(a,L,MOD):
    B = L.bit_length()
    x = np.empty(1 + (1<<B),np.int64)
    x[0] = 1; x[1] = a
    for n in range(B):
        x[1<<n:1<<(n+1)] = x[:1<<n] * (a * x[(1<<n)-1] % MOD) % MOD
    return x[:L]

U = 10 ** 6
power2 = make_power(2,U,MOD)
power2_inv = make_power(pow(2,MOD-2,MOD),U,MOD)
power3 = make_power(3,U,MOD)
power3_inv = make_power(pow(3,MOD-2,MOD),U,MOD)
fact,fact_inv = make_fact(U,MOD)

x = np.zeros(N+M,np.int64)
x[1:] = (-1) * power2[:N+M-1] * power3_inv[K+1:N+M+K] % MOD
x[1:] *= fact[K+1:N+M+K] * fact_inv[K] % MOD * fact_inv[1:N+M] % MOD
x %= MOD
x[0] = 3 * (1 - power3_inv[K+1]) % MOD * power2_inv[1] % MOD
np.cumsum(x, out=x); x %= MOD
x *= power3[:N+M] * power2_inv[:N+M] % MOD; x %= MOD

coef = fact[N-1:N+M] * fact_inv[:M+1] % MOD * fact_inv[N-1] % MOD
coef *= power3[K:K+M+1][::-1]; coef %= MOD
answer = (coef * x[N-1:N+M] % MOD).sum() % MOD
print(answer)
```