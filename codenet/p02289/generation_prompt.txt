Voici un énoncé de problème :

Priority Queue
A priority queue is a data structure which maintains a set $S$ of elements, each of with an associated value (key), and supports the following operations:
$insert(S, k)$: insert an element $k$ into the set $S$
$extractMax(S)$: remove and return the element of $S$ with the largest key
Write a program which performs the $insert(S, k)$ and $extractMax(S)$ operations to a priority queue $S$.
The priority queue manages a set of integers, which are also keys for the priority.
Input
Multiple operations to the priority queue $S$ are given. Each operation is given by "
insert
$k$", "
extract
" or "
end
" in a line. Here, $k$ represents an integer element to be inserted to the priority queue.
The input ends with "
end
" operation.
Output
For each "
extract
" operation, print the element extracted from the priority queue $S$ in a line.
Constraints
The number of operations $\leq 2,000,000$
$0 \leq k \leq 2,000,000,000$
Sample Input 1
insert 8
insert 2
extract
insert 10
extract
insert 11
extract
extract
end
Sample Output 1
8
10
11
2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array

# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall
# from decimal import Decimal
# from collections import defaultdict, deque

sys.setrecursionlimit(10000000)

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)

MOD = 10 ** 9 + 7
MAX = float('inf')

def main():
    if os.getenv("LOCAL"):
        sys.stdin = open("input.txt", "r")

    heap = []
    heapq.heapify(heap)

    while True:
        que = sl()
        if que[0] == 'end':
            break
        elif que[0] == 'insert':
            heapq.heappush(heap, int(que[1]) * (-1))
        elif que[0] == 'extract':
            print(heapq.heappop(heap) * (-1))

if __name__ == '__main__':
    main()
```