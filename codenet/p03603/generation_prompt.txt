Voici un énoncé de problème :

Score :
700
points
Problem Statement
We have a tree with
N
vertices. Vertex
1
is the root of the tree, and the parent of Vertex
i
(
2 \leq i \leq N
) is Vertex
P_i
.
To each vertex in the tree, Snuke will allocate a color, either black or white, and a non-negative integer weight.
Snuke has a favorite integer sequence,
X_1, X_2, ..., X_N
, so he wants to allocate colors and weights so that the following condition is satisfied for all
v
.
The total weight of the vertices with the same color as
v
among the vertices contained in the subtree whose root is
v
, is
X_v
.
Here,
the subtree whose root is
v
is the tree consisting of Vertex
v
and all of its descendants.
Determine whether it is possible to allocate colors and weights in this way.
Constraints
1 \leq N \leq 1
000
1 \leq P_i \leq i - 1
0 \leq X_i \leq 5
000
Inputs
Input is given from Standard Input in the following format:
N
P_2
P_3
...
P_N
X_1
X_2
...
X_N
Outputs
If it is possible to allocate colors and weights to the vertices so that the condition is satisfied, print
POSSIBLE
; otherwise, print
IMPOSSIBLE
.
Sample Input 1
3
1 1
4 3 2
Sample Output 1
POSSIBLE
For example, the following allocation satisfies the condition:
Set the color of Vertex
1
to white and its weight to
2
.
Set the color of Vertex
2
to black and its weight to
3
.
Set the color of Vertex
3
to white and its weight to
2
.
There are also other possible allocations.
Sample Input 2
3
1 2
1 2 3
Sample Output 2
IMPOSSIBLE
If the same color is allocated to Vertex
2
and Vertex
3
, Vertex
2
cannot be allocated a non-negative weight.
If different colors are allocated to Vertex
2
and
3
, no matter which color is allocated to Vertex
1
, it cannot be allocated a non-negative weight.
Thus, there exists no allocation of colors and weights that satisfies the condition.
Sample Input 3
8
1 1 1 3 4 5 5
4 1 6 2 2 1 3 3
Sample Output 3
POSSIBLE
Sample Input 4
1
0
Sample Output 4
POSSIBLE


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n = int(input())
P = list(map(int, input().split()))
X = list(map(int, input().split()))

dp = [0]*n
child = [[] for i in range(n)]
for i in range(n-1):
    child[P[i]-1].append(i+1)

for i in range(n-1, -1, -1):
    if not child[i]:
        dp[i] = 0
    else:
        su = 0
        re = 0
        for c in child[i]:
            z = min(X[c], dp[c])
            su += z
        if su > X[i]:
            print("IMPOSSIBLE")
            exit(0)
        can = X[i] - su
        ss = set([0])
        for c in child[i]:
            z = min(X[c], dp[c])
            rest = max(X[c], dp[c]) - z
            re += rest
            pp = set(ss)
            for s in ss:
                if s + rest <= can:
                    pp.add(s + rest)
            ss = pp
        dp[i] = su + re - max(ss)
print("POSSIBLE")
```