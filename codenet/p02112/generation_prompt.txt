Voici un énoncé de problème :

Problem B: Hating Crowd
Problem
ニート君は1年12ヶ月毎月30日まで計360日の世界線で暮らしています。その世界では毎年同じ日程の
N
個の連休が世界中の人に適用されていました。連休
i
は
M
i
月
D
i
日から始まる連続した
V
i
日間です。
ニート君はNEETなので連休に関係なく毎日休みです。ある日ニート君は珍しく出かけようと思いましたが、人混みが嫌いなので、連休の影響で混雑する日はなるべく外に出たくありません。そこで、ニート君は以下の方法で各日の混雑度を計算し、混雑度が一番小さい日を探そうとしています。
ある日付
x
が、連休
i
によって受ける影響の度合を表す数値は、日付
x
が連休
i
の中に含まれていれば
S
i
であり、そうでなければ、
max
( 0,
S
i
− min
(
x
から連休
i
の初日までの日数 , 連休
i
の最終日から
x
までの日数 ) )である
ある日付
x
の混雑度は、
N
個の連休から受ける影響の度合の中で、最も大きく受ける影響の度合となる
1年の中で一番小さい混雑度を出力してください。 ただし、連休
i
は年を跨ぐ事があります。また、連休の日程は重複する事があります。
Input
入力は以下の形式で与えられる。
N
M
1
D
1
V
1
S
1
M
2
D
2
V
2
S
2
...
M
N
D
N
V
N
S
N
1行目に整数
N
が与えられる。
2行目から
N
+1行目に整数
M
i
,
D
i
,
V
i
,
S
i
が空白区切りで与えられる。（1 ≤
i
≤
N
）
Constraints
入力は以下の条件を満たす。
1 ≤
N
≤ 100
1 ≤
M
i
≤ 12
1 ≤
D
i
≤ 30
1 ≤
V
i
,
S
i
≤ 360
Output
一番小さい混雑度を1行に出力する。
Sample Input 1
1
1 1 359 1
Sample Output 1
0
Sample Input 2
2
2 4 25 306
1 9 7 321
Sample Output 2
158
Sample Input 3
8
2 9 297 297
8 6 359 211
8 16 28 288
7 9 113 143
3 18 315 190
10 18 277 300
9 5 276 88
3 5 322 40
Sample Output 3
297


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
N = input()
N = int(N)+1
X = [0]
C = [0]*360

for i in range(1,N):
    x = input()
    X.append(x.split())
    i_start = (int(X[i][0])-1)*30+int(X[i][1])-1
    i_end = i_start+int(X[i][2])-1

    for j in range(i_start,i_end+1):
        C[j%360] = max(C[j%360],int(X[i][3]))

    for k in range(1,int(X[i][3])+1):
        C[(i_start-k+360)%360] = max(C[(i_start-k+360)%360],int(X[i][3])-k)
        C[(i_end+k)%360] = max(C[(i_end+k)%360],int(X[i][3])-k)

print(min(C))
```