Voici un énoncé de problème :

Score :
800
points
Problem Statement
In Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between
1
and
N
(inclusive) consisting of integers between
1
and
K
(inclusive) are listed.
Let the total number of sequences listed in FEIS be
X
. Among those sequences, find the
(X/2)
-th (rounded up to the nearest integer) lexicographically smallest one.
Constraints
1 \leq N,K \leq 3 × 10^5
N
and
K
are integers.
Input
Input is given from Standard Input in the following format:
K
N
Output
Print the
(X/2)
-th (rounded up to the nearest integer) lexicographically smallest sequence listed in FEIS, with spaces in between, where
X
is the total number of sequences listed in FEIS.
Sample Input 1
3 2
Sample Output 1
2 1
There are
12
sequences listed in FEIS:
(1),(1,1),(1,2),(1,3),(2),(2,1),(2,2),(2,3),(3),(3,1),(3,2),(3,3)
.
The
(12/2 = 6)
-th lexicographically smallest one among them is
(2,1)
.
Sample Input 2
2 4
Sample Output 2
1 2 2 2
Sample Input 3
5 14
Sample Output 3
3 3 3 3 3 3 3 3 3 3 3 3 2 2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def brute(k,n):
	def gen(k,p):
		ret = []
		if p==0:
			return [()]
		for seq in gen(k,p-1):
			for i in xrange(1,k+1):
				ret.append(seq+(i,))
		return ret
	seqs = []
	for i in xrange(1,n+1):
		seqs += gen(k,i)
	X = len(seqs)
	Y = (X-1)/2
	seqs.sort()
	#if len(seqs)<100:print seqs
	return seqs[Y]

def down_onestep(seq,k,n):
	if seq[-1]==1:
		seq.pop()
		return
	seq[-1]-=1
	while len(seq)<n:
		seq.append(k)

def f(k,n):
	if k%2==0:
		return (k/2,)+(k,)*(n-1)
	if k==1:
		return (1,)*((n+1)/2)
	else:
		seq = [(k+1)/2]*n
		for i in xrange( (n)/2 ):
			down_onestep(seq, k, n)
		return tuple(seq)
	return None

def test():
	for k in xrange(1,6):
		for n in xrange(1,8):
			if f(k,n)==brute(k,n):continue
			print k,n
			print brute(k,n)
			print f(k,n)
			print

def main():
	k,n = map(int, raw_input().split())
	print " ".join(map(str, f(k,n) ))

main()
```