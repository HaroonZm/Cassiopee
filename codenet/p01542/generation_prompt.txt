Voici un énoncé de problème :

失われし数
時は3xxx年、高度に発達した文明は停滞期を迎えていた。歴史家たちはこの状況を打開しようと過去の叡智を学ぶことにした。注目したのはコンピュータ創世期の天才が残した資料である。この資料には計算式が書かれておりその計算結果が知りたいのだが、残念ながらその一部の文字が薄れて読めなくなっている。仕方がないので計算結果としてありえる最も大きい数を求めることにした。
計算式は2進数で書かれており、演算は足し算・引き算・掛け算の3種類である。括弧も用いられているが括弧内が数字のみであることはない。正確には以下のBNFで定義された文法を満たしている必要がある。
<expression> ::= <number> | <expression> <operation> <expression>
| ( <expression> <operation> <expression> )
<number> ::= <digit> | <number> <digit>
<operation> ::= + | - | *
<digit> ::= 0 | 1
当時のコンピュータの計算能力の限界により、数字は0以上
2
10
未満の整数であり計算中もこの範囲を出ることはない。ただし計算は括弧内を先に行い、掛け算は足し算・引き算より先に行う。それ以外の場合は左から順に計算する。
Input
入力は1行からなり、解読すべき数式が1つ与えられる。数式は1文字以上100文字以下である。1つの数式について最大5文字が読めなくなっていて、「.」で表現されている。与えられる数式に含まれる文字は01+-*().のいずれかである。
Constraints
数式は1文字以上100文字以下
改行を除くすべての文字は01+-*().のいずれか
.の個数は5個以下
Output
元の数式として考えられるものの内、計算結果が最大となるものを求め、計算結果を10進法で出力せよ。読めなくなっている文字をどのように埋めても元の数式と考えられるものを作れないときは-1を出力せよ。
Sample Input 1
000
Output for the Sample Input 1
0
Sample Input 2
0.0
Output for the Sample Input 2
2
Sample Input 3
...
Output for the Sample Input 3
7
Sample Input 4
(1.1)
Output for the Sample Input 4
2
Sample Input 5
0-1.
Output for the Sample Input 5
-1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    rr = []

    def f(s):
        ca = '01+-*()'
        sa = s.split('.')
        r = -1
        sl = len(sa)

        fm = {}
        def _f(s):
            if s in fm:
                return fm[s]
            if ')' in s:
                ri = s.index(')')
                if len(s) > ri+1 and s[ri+1] in '01':
                    fm[s] = -1
                    return -1
                li = -1
                for i in range(ri-1,-1,-1):
                    if s[i] == '(':
                        li = i
                        break
                if li < 0 or li > 0 and s[li-1] in '01':
                    fm[s] = -1
                    return -1
                ts = s[li+1:ri]
                if '+' not in ts and '-' not in ts and '*' not in ts:
                    fm[s] = -1
                    return -1
                tr = _f(ts)
                if tr == -1:
                    fm[s] = -1
                    return -1
                fm[s] = _f(s[:li] + tr + s[ri+1:])
                return fm[s]
            if '(' in s:
                fm[s] = -1
                return -1

            l = len(s)
            if '*' in s:
                oi = s.index('*')
                li = oi
                for i in range(oi-1,-1,-1):
                    if s[i] not in '01':
                        break
                    li = i
                ri = oi
                for i in range(oi+1,l):
                    if s[i] not in '01':
                        break
                    ri = i
                if li == oi or ri == oi:
                    fm[s] = -1
                    return -1
                t = int(s[li:oi], 2)
                u = int(s[oi+1:ri+1], 2)
                tu = t * u
                if t < 0 or t >= 1024 or u < 0 or u >= 1024 or tu < 0 or tu >= 1024:
                    fm[s] = -1
                    return -1
                ts = bin(tu)[2:]
                fm[s] = _f(s[:li] + ts + s[ri+1:])
                return fm[s]
            pi = inf
            mi = inf
            if '+' in s:
                pi = s.index('+')
            if '-' in s:
                mi = s.index('-')
            if pi == inf and mi == inf:
                t = int(s, 2)
                fm[s] = s
                if t < 0 or t >= 1024:
                    fm[s] = -1
                return fm[s]
            oi = min(pi, mi)
            li = oi
            for i in range(oi-1,-1,-1):
                if s[i] not in '01':
                    break
                li = i
            ri = oi
            for i in range(oi+1,l):
                if s[i] not in '01':
                    break
                ri = i
            if li == oi or ri == oi:
                fm[s] = -1
                return -1
            t = int(s[li:oi], 2)
            t = int(s[li:oi], 2)
            u = int(s[oi+1:ri+1], 2)
            tu = t + u
            if oi == mi:
                tu = t - u
            if t < 0 or t >= 1024 or u < 0 or u >= 1024 or tu < 0 or tu >= 1024:
                fm[s] = -1
                return -1
            ts = bin(tu)[2:]
            fm[s] = _f(s[:li] + ts + s[ri+1:])
            return fm[s]

        for ci in itertools.product(ca, repeat=sl-1):
            t = ''
            for i in range(len(ci)):
                t += sa[i]
                t += ci[i]
            t += sa[-1]
            tr = _f(t)
            if tr != -1:
                tr = int(tr, 2)
                if tr >= 1024 or tr < 0:
                    tr = -1
            if r < tr:
                r = tr
        # for k in sorted(fm.keys()):
        #     if fm[k] == -1:
        #         continue
        #     print(k, fm[k])
        return r

    while 1:
        n = S()
        if n == 0:
            break
        rr.append(f(n))
        break

    return '\n'.join(map(str, rr))

print(main())
```