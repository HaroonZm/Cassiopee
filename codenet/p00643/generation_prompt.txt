En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop
while True:
  h, w = map(int, input().split())
  if h == 0:
    break
  mp = [[-1] + list(map(int, input().split())) +[-1] for _ in range(h)]
  mp.insert(0, [-1] * (w + 2))
  mp.append([-1] * (w + 2))
  sy, sx = map(int, input().split())
  gy, gx = map(int, input().split())
  sy += 1
  sx += 1
  gy += 1
  gx += 1
  que = []
  heappush(que, (0, sx, sy, 1, 2, 3))
  dic = {}
  dic[(sx, sy, 1, 2, 3)] = 0
  vec = ((1, 0), (0, -1), (-1, 0), (0, 1))
  def spin(top, south, east, direct):
    if direct == (1, 0):
      return 7 - east, south, top
    if direct == (0, -1):
      return south, 7 - top, east
    if direct == (-1, 0):
      return east, south, 7 - top
    if direct == (0, 1):
      return 7 - south, top, east
  while que:
    pena, x, y, top, south, east = heappop(que)
    if (x, y) == (gx, gy):
      print(pena)
      break
    for dx, dy in vec:
      nx, ny = x + dx, y + dy
      if mp[ny][nx] == -1:
        continue
      new_top, new_south, new_east = spin(top, south, east, (dx, dy))
      new_pena = pena + (7 - new_top) * mp[ny][nx]
      if (nx, ny, new_top, new_south, new_east) not in dic:
        dic[(nx, ny, new_top, new_south, new_east)] = new_pena
        heappush(que, (new_pena, nx, ny, new_top, new_south, new_east))
```