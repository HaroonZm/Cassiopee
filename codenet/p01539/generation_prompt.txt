Voici un énoncé de problème :

全探索お姉さんの休日
全探索お姉さんはとても優秀な女性である。
お姉さんは格子状の道の経路の数え上げを数千程度なら簡単に数え上げてしまう。
あなたと全探索お姉さんは今、六角形のタイルが敷き詰められた部屋にいる。
お姉さんは初めて見る六角形にとても興奮している様子である。
六角形の並びを座標に表すことに不慣れなお姉さんは図1のような座標系で部屋を表した。
図1
あなたはこの座標系上である地点からある地点まで移動したい。
しかし、お姉さんは 1 分ごとに動きたい方向をあなたに指示する。
いつものお姉さんなら同じ座標の場所を通らないようにあなたに移動の指示を出すだろう。
しかし、この座標系に不慣れなお姉さんは
|x×y×t|
(
x
：
x
座標、
y
：
y
座標、
t
:最初の指示からの経過時間[分])を 6 で割った余り
に対応する方向（図で示す番号と対応）を指示するだけで、まったくのでたらめな方向にあなたを誘導する。
図2
お姉さんを傷つけたくないあなたは、お姉さんの指示をできるだけ守りつつ目的地までたどり着きたい。
あなたは許された行動は下の 7 つの行動である。
方向 0 へ 1 タイル移動
方向 1 へ 1 タイル移動
方向 2 へ 1 タイル移動
方向 3 へ 1 タイル移動
方向 4 へ 1 タイル移動
方向 5 へ 1 タイル移動
その場に留まる
お姉さんが指示を出した直後にあなたはこれら行動のうちの必ず1つを行う。
部屋には家具があり家具が配置されているタイルの中に移動することはできない。
また、
y
座標の絶対値が
ly
を超えたり
x
座標の絶対値が
lx
を超えるような移動は許されていない。
しかし、お姉さんはそのような移動を指示することがある。
指示を無視するとはお姉さんが示した方向と異なる方向へ移動するか、
もしくは、その場に留まることである。
目的地にたどり着くために最小で何度指示を無視すれば良いかを出力せよ。
目的地にたどり着くことが不可能な場合は -1 を出力せよ。
Input
入力は以下の形式で与えられる。
sx
sy
gx
gy
n
x
1
y
1
...
x
i
y
i
...
x
n
y
n
lx
ly
ここで、
sx
,
sy
は出発地点の座標
gx
,
gy
は目的地の座標
n
は部屋に配置されている家具の数
x
i
,
y
i
は家具があるタイルの座標
lx
,
ly
は移動できる
X
,
Y
それぞれの座標の絶対値の上限
である。
Constraints
入力はすべて整数
-lx ≤ sx
,
gx ≤ lx
-ly ≤ sy
,
gy ≤ ly
(sx, sy) ≠ (gx, gy)
(xi, yi) ≠ (sx, sy)(1≤i≤n)
(xi, yi) ≠ (gx, gy)(1≤i≤n)
(xi, yi) ≠ (xj, yj)(i ≠ j)
0≤ n ≤ 1000
-lx ≤ xi ≤ lx (1≤i≤n)
-ly ≤ yi ≤ ly (1≤i≤n)
0 < lx, ly ≤ 100
Output
出力は1つの整数を含む1行で出力せよ。
目的地にたどり着ける場合は、最小の指示を無視する回数を出力せよ。
目的地にたどり着くことが不可能な場合は-1を出力せよ。
Sample Input 1
0 0 0 2
0
2 2
Output for the Sample Input 1
0
Sample Input 2
0 0 0 2
6
0 1
1 0
1 -1
0 -1
-1 -1
-1 0
2 2
Output for the Sample Input 2
-1
Sample Input 3
0 0 0 2
1
0 1
2 2
Output for the Sample Input 3
1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop
dd = [
    [(0, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (0, 0)],
    [(0, 1), (1, 1), (1,  0), (0, -1), (-1,  0), (-1, 1), (0, 0)]
]
sx, sy, gx, gy = map(int, raw_input().split())
n = input()
P = {tuple(map(int, raw_input().split())) for i in xrange(n)}
lx, ly = map(int, raw_input().split())

INF = 10**18

dist = {(0, sx, sy): 0}
que = [(0, 0, sx, sy)]
while que:
    co, t, x, y = heappop(que)
    if dist.get((t, x, y), INF) < co:
        continue
    ox, oy = dd[x%2][abs(x*y*t) % 6]
    if (x+ox, y+oy) not in P and abs(x+ox) <= lx and abs(y+oy) <= ly:
        if co < dist.get(((t+1)%6, x+ox, y+oy), INF):
            dist[(t+1)%6, x+ox, y+oy] = co
            heappush(que, (co, (t+1)%6, x+ox, y+oy))
    for dx, dy in dd[x%2]:
        if dx == ox and dy == oy:
            continue
        nx = x+dx; ny = y+dy
        if (nx, ny) in P or abs(nx)>lx or abs(ny)>ly:
            continue
        if co+1 < dist.get(((t+1)%6, nx, ny), INF):
            dist[(t+1)%6, nx, ny] = co+1
            heappush(que, (co+1, (t+1)%6, nx, ny))
v = min(dist.get((t, gx, gy), INF) for t in xrange(6))
print -1 if v == INF else v
```