Voici un énoncé de problème :

On or Off
Saving electricity is very important!
You are in the office represented as
R \times C
grid that consists of walls and rooms.
It is guaranteed that, for any pair of rooms in the office, there exists exactly one route between the two rooms.
It takes 1 unit of time for you to move to the next room (that is, the grid adjacent to the current room).
Rooms are so dark that you need to switch on a light when you enter a room.
When you leave the room, you can either leave the light on, or
of course you can switch off the light. Each room keeps consuming electric power while the light is on.
Today you have a lot of tasks across the office.
Tasks are given as a list of coordinates, and they need to be done in the specified order.
To save electricity, you want to finish all the tasks with the minimal amount of electric power.
The problem is not so easy though, because you will consume electricity not only when light is on, but also when you switch on/off the light.
Luckily, you know the cost of power consumption per unit time and also the cost to switch on/off the light for all the rooms in the office.
Besides, you are so smart that you don't need any time to do the tasks themselves.
So please figure out the optimal strategy to minimize the amount of electric power consumed.
After you finished all the tasks, please DO NOT leave the light on at any room.
It's obviously wasting!
Input
The first line of the input contains three positive integers
R
(
0 \lt R \leq 50
),
C
(
0 \lt C \leq 50
) and
M
(
2 \leq M \leq 1000
).
The following
R
lines, which contain
C
characters each, describe the layout of the office.
'.' describes a room and '#' describes a wall.
This is followed by three matrices with
R
rows,
C
columns each.
Every elements of the matrices are positive integers.
The
(r, c)
element in the first matrix describes the power consumption per unit of time for the room at the coordinate
(r, c)
.
The
(r, c)
element in the second matrix and the third matrix describe the cost to turn on the light and the cost to turn off the light, respectively, in the room at the coordinate
(r, c)
.
Each of the last
M
lines contains two positive integers, which describe the coodinates of the room for you to do the task.
Note that you cannot do the
i
-th task if any of the
j
-th task (
0 \leq j \leq i
) is left undone.
Output
Print one integer that describes the minimal amount of electric power consumed when you finished all the tasks.
Sample Input 1
1 3 2
...
1 1 1
1 2 1
1 1 1
0 0
0 2
Output for the Sample Input 1
7
Sample Input 2
3 3 5
...
.##
..#
1 1 1
1 0 0
1 1 0
3 3 3
3 0 0
3 3 0
5 4 5
4 0 0
5 4 0
1 0
2 1
0 2
2 0
0 0
Output for the Sample Input 2
77
Sample Input 3
5 5 10
#.###
#....
###.#
..#.#
#....
0 12 0 0 0
0 4 3 2 10
0 0 0 99 0
11 13 0 2 0
0 1 1 2 1
0 4 0 0 0
0 13 8 2 4
0 0 0 16 0
1 1 0 2 0
0 2 3 1 99
0 2 0 0 0
0 12 2 12 2
0 0 0 3 0
4 14 0 16 0
0 2 14 2 90
0 1
3 0
4 4
1 4
1 1
4 4
1 1
4 3
3 0
1 4
Output for the Sample Input 3
777


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    rr = []

    def f():
        r,c,m = LI()
        a = [[1] * (c+2)] + [[1] + [None if c == '.' else 1 for c in S()] + [1] for _ in range(r)] + [[1] * (c+2)]
        cost = [[1] * (c+2)] + [[1] + LI() + [1] for _ in range(r)] + [[1] * (c+2)]
        on = [[1] * (c+2)] + [[1] + LI() + [1] for _ in range(r)] + [[1] * (c+2)]
        off = [[1] * (c+2)] + [[1] + LI() + [1] for _ in range(r)] + [[1] * (c+2)]
        ms = [tuple(map(lambda x: x+1, LI())) for _ in range(m)]
        e = collections.defaultdict(list)
        for i in range(1,r+1):
            for j in range(1,c+1):
                if a[i][j]:
                    continue
                for di,dj in dd:
                    if a[i+di][j+dj]:
                        continue
                    e[(i,j)].append(((i+di,j+dj), 1))

        def search(s):
            d = collections.defaultdict(lambda: inf)
            d[s] = 0
            q = []
            heapq.heappush(q, (0, s))
            v = collections.defaultdict(bool)
            while len(q):
                k, u = heapq.heappop(q)
                if v[u]:
                    continue
                v[u] = True

                for uv, ud in e[u]:
                    if v[uv]:
                        continue
                    vd = k + ud
                    if d[uv] > vd:
                        d[uv] = vd
                        heapq.heappush(q, (vd, uv))

            return d

        ad = {}
        for k in ms:
            if k in ad:
                continue
            ad[k] = search(k)
        ti = 0
        td = collections.defaultdict(list)
        c = ms[0]
        td[c].append(0)
        for t in ms[1:]:
            while c != t:
                cc = ad[t][c]
                for di,dj in dd:
                    ni = c[0] + di
                    nj = c[1] + dj
                    n = (ni, nj)
                    if ad[t][n] == cc - 1:
                        ti += 1
                        td[n].append(ti)
                        c = n
                        break

        r = 0
        for k,v in sorted(td.items()):
            i = k[0]
            j = k[1]
            cs = cost[i][j]
            onf = on[i][j] + off[i][j]
            tr = onf
            for vi in range(len(v)-1):
                sa = v[vi+1] - v[vi]
                tr += min(cs * sa, onf)
            r += tr

        return r

    while True:
        rr.append(f())
        break

    return '\n'.join(map(str,rr))

print(main())
```