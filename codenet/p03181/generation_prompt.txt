Voici un énoncé de problème :

Score :
100
points
Problem Statement
There is a tree with
N
vertices, numbered
1, 2, \ldots, N
.
For each
i
(
1 \leq i \leq N - 1
), the
i
-th edge connects Vertex
x_i
and
y_i
.
Taro has decided to paint each vertex in white or black, so that any black vertex can be reached from any other black vertex by passing through only black vertices.
You are given a positive integer
M
.
For each
v
(
1 \leq v \leq N
), answer the following question:
Assuming that Vertex
v
has to be black, find the number of ways in which the vertices can be painted, modulo
M
.
Constraints
All values in input are integers.
1 \leq N \leq 10^5
2 \leq M \leq 10^9
1 \leq x_i, y_i \leq N
The given graph is a tree.
Input
Input is given from Standard Input in the following format:
N
M
x_1
y_1
x_2
y_2
:
x_{N - 1}
y_{N - 1}
Output
Print
N
lines.
The
v
-th (
1 \leq v \leq N
) line should contain the answer to the following question:
Assuming that Vertex
v
has to be black, find the number of ways in which the vertices can be painted, modulo
M
.
Sample Input 1
3 100
1 2
2 3
Sample Output 1
3
4
3
There are seven ways to paint the vertices, as shown in the figure below.
Among them, there are three ways such that Vertex
1
is black, four ways such that Vertex
2
is black and three ways such that Vertex
3
is black.
Sample Input 2
4 100
1 2
1 3
1 4
Sample Output 2
8
5
5
5
Sample Input 3
1 100
Sample Output 3
1
Sample Input 4
10 2
8 5
10 8
6 5
1 5
4 8
2 10
3 6
9 2
1 7
Sample Output 4
0
0
1
1
1
0
1
0
1
1
Be sure to print the answers modulo
M
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)

def dfs(v, p = -1):
    deg[v] = len(U[v])
    dp[v] = [0] * deg[v]
    ans = 1
    for i in range(deg[v]):
        u = U[v][i]
        if u == p:
            par[v] = i
            continue
        dp[v][i] = dfs(u, v)
        ans *= dp[v][i] + 1
        ans %= M
    return(ans)

def bfs(v, ans_p = 0, p = -1):
    if p != -1:
        dp[v][par[v]] = ans_p
    lmul = [1] * (deg[v] + 1)
    rmul = [1] * (deg[v] + 1)
    for i in range(1, deg[v] + 1):
        lmul[i] = lmul[i - 1] * (dp[v][i - 1] + 1) % M
        rmul[-i - 1] = rmul[-i] * (dp[v][-i] + 1) % M
    ans[v] = rmul[0]
    for i in range(deg[v]):
        u = U[v][i]
        if u == p:
            continue
        bfs(u, lmul[i] * rmul[i + 1] % M, v)

N, M = map(int, input().split()) # 1 <= N <= 10^5, 2 <= M <= 10^9
U = [list() for _ in range(N)]
for x, y in [map(int, input().split()) for _ in range(N - 1)]:
    U[x - 1].append(y - 1)
    U[y - 1].append(x - 1)
deg = [0] * N
par = [0] * N
dp = [None] * N
ans = [0] * N
dfs(0)
bfs(0)
print("\n".join([str(x) for x in ans]))
```