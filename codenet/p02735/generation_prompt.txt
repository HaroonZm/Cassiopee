En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import numpy as np
from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson
from scipy.sparse import csr_matrix, lil_matrix

H, W = map(int, input().split())
# H, W = 2, 2
s = []
for _ in range(H):
    s.append(input())
# s = [func() for _ in range(H)]
# print('\n'.join(s))

def co_num(h, w):
    return h * W + w

row = []
col = []
dist = []
for h in range(H):
    for w in range(W):
#         if h != 0:
#             row.append(co_num(h, w))
#             col.append(co_num(h-1, w))
#             dist.append(0 if s[h-1][w] == s[h][w] else 1)
#         if w != 0:
#             row.append(co_num(h, w))
#             col.append(co_num(h, w-1))
#             dist.append(0 if s[h][w-1] == s[h][w] else 1)
        if h != H-1:
            row.append(co_num(h, w))
            col.append(co_num(h+1, w))
            dist.append(0 if s[h+1][w] == s[h][w] else 1)
        if w != W-1:
            row.append(co_num(h, w))
            col.append(co_num(h, w+1))
            dist.append(0 if s[h][w+1] == s[h][w] else 1)

d = int(dijkstra(csr_matrix((dist, (row, col)), shape=[H*W, H*W]), directed=True, indices=0)[H*W-1])

if s[0][0] == '.' and s[-1][-1] == '.':
    print(d // 2)
elif s[0][0] == '#' and s[-1][-1] == '#':
    print(d // 2 + 1)
else:
    print(d // 2 + 1)
```