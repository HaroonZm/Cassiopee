Voici un énoncé de problème :

Breadth First Search
Write a program which reads an directed graph $G = (V, E)$, and finds the shortest distance from vertex $1$ to each vertex (the number of edges in the shortest path). Vertices are identified by IDs $1, 2, ... n$.
Input
In the first line, an integer $n$ denoting the number of vertices, is given. In the next $n$ lines, adjacent lists of vertex $u$ are given in the following format:
$u$ $k$ $v_1$ $v_2$ ... $v_k$
$u$ is ID of the vertex and $k$ denotes its degree.$v_i$ are IDs of vertices adjacent to $u$.
Constraints
$1 \leq n \leq 100$
Output
For each vertex $u$, print $id$ and $d$ in a line. $id$ is ID of vertex $u$ and $d$ is the distance from vertex $1$ to vertex $u$. If there are no path from vertex $1$ to vertex $u$, print -1 as the shortest distance. Print in order of IDs.
Sample Input 1
4
1 2 2 4
2 1 4
3 0
4 1 3
Sample Output 1
1 0
2 1
3 2
4 1
Reference
Introduction to Algorithms, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. The MIT Press.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n=int(input())
G=[[] for i in range(n)]
#G=[]
Q=[1]
d=[-1]*n
d[0]=0
visited=[False]*n
visited[0]=True

for i in range(n):
    arr=[int(x) for x in input().split()[2:]]
    for l in arr:
        G[i].append(l)
        #G[l-1].append(i+1)
    

kyori=0
while len(Q)!=0:
    
    #print(Q)
    #print(visited)
    v=Q.pop(0)
    
    for j in G[v-1]:
        if visited[j-1]:#次に行くところがすでに踏破済みだったら
            continue#更新しない
        else:
            d[j-1]=d[v-1]+1
            Q.append(j)
            visited[j-1]=True
for a in range(n):
    print(a+1,d[a])
```