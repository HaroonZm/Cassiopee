Voici un énoncé de problème :

かくれんぼう
たろう君はかくれんぼうが苦手です。隠れるとすぐ見つかっちゃうし、隠れている子をなかなか見つけることができません。見かねたお父さんは、超高性能位置探索システムを作ってくれました。これを使うと自分の位置を含めて、友達の位置を正確に知ることができます。鬼になったら、隠れている子を探すことが簡単にできるようになりました。
たろう君はさらにこのシステムを進化させ、鬼から自分が見えるか否かを判定する機能を付加することを思いつきました。これができれば、「もういいかい」と言われても、見える位置にいれば「まあだだよ」だし、見えない位置にいれば「もういいよ」ですね。いつも遊んでいる公園には大小さまざまな円筒形の壁があります。この壁は外からは中は見えないし、中から外も見えません。鬼と一緒に中に入ると別の壁がなければ見えちゃいます。
たろう君はアイデアはいいのですが、ソフトを作るのが苦手です。そこで親友のあなたはたろう君に代わって、「鬼から見えないこと確認システム」のソフトウェアを作ることになりました。公園の壁は固定されていますが、たろう君と鬼のいろいろな位置情報に対して見えるか否かを判定する必要があります。
公園にある壁の情報(中心の座標 (
wx
,
wy
) と 半径
r
) とたろう君と鬼の位置情報(たろう君の位置の座標 (
tx
,
ty
) と鬼の位置の座標 (
sx
,
sy
) ) を入力とし、その位置で鬼からたろう君が見えるか否かを判定するプログラムを作成してください。
なお、鬼からたろう君が見える場合には Danger、見えない場合には Safe と出力してください。鬼とたろう君の位置を結んだ線分上に壁がある場合には見えないものとし、鬼もたろう君も壁の上にはいないものとします。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
n
wx
1
wy
1
r
1
wx
2
wy
2
r
2
:
wx
n
wy
n
r
n
m
tx
1
ty
1
sx
1
sy
1
tx
2
ty
2
sx
2
sy
2
:
tx
m
ty
m
sx
m
sy
m
1 行目に円筒形の壁の数
n
(0 ≤
n
≤ 100)、続く
n
行に壁
i
の中心の座標を表す整数
wx
i
,
wy
i
(0 ≤
wx
i
,
wy
i
≤ 255) と半径を表す整数
r
i
(1 ≤
r
i
≤ 255) が与えられます。
続く行にたろう君と鬼の位置情報の個数
m
(m ≤ 100)、続く
m
行に位置情報
i
のたろう君の位置の座標を表す整数
tx
i
,
ty
i
(0 ≤
tx
i
,
ty
i
≤ 255) と鬼の位置の座標を表す整数
sx
i
,
sy
i
(0 ≤
sx
i
,
sy
i
≤ 255) が与えられます。
また、円筒形の壁の一部だけが公園にあるということはなく、全ての壁は円筒として、公園の内部に入っています。
n
が 0 のとき入力の終わりを示します。データセットの数は 20 を超えません。
Output
各データセットについて、位置情報
i
の判定結果 Danger または Safe を
i
行目に出力してください。
Sample Input
3
6 6 3
19 7 4
21 8 1
6
5 4 2 11
12 4 2 11
11 9 2 11
14 3 20 5
17 9 20 5
20 10 20 5
0
Output for the Sample Input
Safe
Safe
Danger
Safe
Danger
Safe


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math as M
def R(A): return (A[0]**2+A[1]**2)**.5
def I(i): return [map(int,raw_input().split()) for _ in [0]*i]
def C(a,b): return a>b or abs(a-b)<1e-6
def f(e1):
  tx,ty,sx,sy=e1
  x=[]
  for e2 in WP:
    wx,wy,r=e2
    wt=[tx-wx,ty-wy]; rwt=R(wt)
    sw=[wx-sx,wy-sy]; rsw=R(sw)
    st=[tx-sx,ty-sy]; rst=R(st)
    F=[rwt<r,rsw<r]
    if rst==0: c=1
    elif F==[1,1]: c=1
    elif F==[1,0] or F==[0,1]: c=0
    elif F==[0,0]:
      a=M.pi/2-M.acos(r/rsw)
      b=M.acos(round((sw[0]*st[0]+sw[1]*st[1])/rsw/rst,4))
      if C(a,b) and C(rst**2,rsw**2-r**2): c=0
      else: c=1
    x.append(c)
  return all(x)

while 1:
  n=input()
  if n==0: break
  WP=I(n)
  P=I(input())
  for e in P: print ["Safe","Danger"][f(e)]
```