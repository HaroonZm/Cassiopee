Voici un énoncé de problème :

Problem E: 街を駆ける道
ネーヴァ王国には、トタタ族とツテテ族、２種類の民族が暮らしている。トタタ族の最大の特徴は、
酢豚にパイナップルを入れて食べることである。だがツテテ族は、パイナップルに酢豚を入れて食べ
る。こんな２つの民族がお互いに仲良くやっていけるはずもなく、トタタ族とツテテ族は、何百年も
の昔からずっといがみ合いを続けてきた。
そんなある日、ネーヴァ王のもとに、２つの民族から嘆願書が届いた。それによるとトタタ族は、自
分たちが暮らす街Ａと街Ｂのあいだを結ぶ道を建設してほしいらしい。一方でツテテ族も、自分たち
が暮らす街Ｃと街Ｄのあいだを結ぶ道を建設してほしいらしい。
２つの民族が衝突するのを防ぐため、トタタ族が通る道とツテテ族が通る道を交差させることはでき
ない。また、技術的な制約により、２つの街のあいだを一直線に結ぶような道しか建設することはで
きない。つまり、必要ならば街Ａと街Ｂを直接道で結ばずに、いくつかのトタタ族の街を経由して街
Ａと街Ｂを間接的に結ぶことになるだろう（もちろん、ツテテ族の街を経由してはならない）。その
際、トタタ族の街を結ぶ道どうしは交差していてもよい。街Ｃと街Ｄについても同様である。
道を建設するには、その長さに比例したコストがかかる。なので、条件をみたしつつ、できるだけ建
設する道の長さの合計が短くなるようにしたい。さて、長さの最小値はいくつになるだろうか。
Input
N
A
N
B
x
A
,1
y
A
,1
x
A
,2
y
A
,2
.
.
.
x
A
,
N
A
y
A
,
N
A
x
B
,1
y
B
,1
x
B
,2
y
B
,2
.
.
.
x
B
,
N
B
y
B
,
N
B
入力の１行目には、整数
N
A
（2 ≤
N
A
≤ 1,000）と整数
N
B
（2 ≤
N
B
≤ 1,000）が、空白区切りで書かれている。これは、ネーヴァ王国にはトタタ族が暮らす街がNA 個、ツテテ族が暮らす街がNB 個あることをあらわす。初期状態では、どこにも道は建設されていない。
続く
N
A
行には、整数
x
A,i
（-10,000 ≤
x
A,i
≤ 10,000）と整数
y
A,i
（-10,000 ≤
y
A,i
≤ 10,000）が、空白区切りで書かれている。ネーヴァ王国の地理は２次元直交座標平面であらわされ、１＋ i 行目に書かれた整数
x
A,i
と
y
A,i
は、トタタ族が暮らすi 番目の街の位置座標が(
x
A,i
,
y
A,i
) であることをあらわす。(
x
A,1
,
y
A,1
) と(
x
A,2
,
y
A,2
) が、結ぶべき２つの街の座標である。
続く
N
B
行には、整数
x
B,i
（-10,000 ≤
x
B,i
≤ 10,000）と整数
y
B,i
（-10,000 ≤
y
B,i
≤ 10,000）が、空白区切りで書かれている。１＋
N
A
＋ i 行目に書かれた整数
x
B,i
と
y
B,i
は、ツテテ族が暮らすi 番目の街の位置座標が(
x
B,i
,
y
B,i
) であることをあらわす。(
x
B,1
,
y
B,1
) と(
x
B,2
,
y
B,2
) が、結ぶべき２つの街の座標である。
どの２つの街の座標も異なっており、どの３つの街も同一直線上にないと仮定してよい。
Output
問題文の条件をみたすように道を建設したとき、道の長さの合計の最小値を出力せよ。ここで言う
「長さ」とは、ユークリッド距離のことである。ただし、どうやっても条件をみたす道を建設できな
いときは、代わりに-1 を出力せよ。出力は誤差を含んでいてもよいが、真の値との相対誤差が10
-9
未満でなければならない。
Sample Input 1
2 2
0 0
1 1
2 0
2 -1
Sample Output 1
2.414213562373
Sample Input 2
2 3
4 0
0 0
2 3
2 -2
3 1
Sample Output 2
-1
Sample Input 3
5 2
-2 1
1 2
-1 3
-1 5
1 4
0 4
0 0
Sample Output 3
12.359173603117


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop
from math import sqrt
import sys
readline = sys.stdin.buffer.readline
write = sys.stdout.write
N, M = map(int, readline().split())
PS = [list(map(int, readline().split())) for i in range(N)]
QS = [list(map(int, readline().split())) for i in range(M)]

def dot3(O, A, B):
    ox, oy = O; ax, ay = A; bx, by = B
    return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)
def cross3(O, A, B):
    ox, oy = O; ax, ay = A; bx, by = B
    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)
def dist2(A, B):
    ax, ay = A; bx, by = B
    return (ax - bx) ** 2 + (ay - by) ** 2
def is_intersection(P0, P1, Q0, Q1):
    C0 = cross3(P0, P1, Q0)
    C1 = cross3(P0, P1, Q1)
    D0 = cross3(Q0, Q1, P0)
    D1 = cross3(Q0, Q1, P1)
    if C0 == C1 == 0:
        E0 = dot3(P0, P1, Q0)
        E1 = dot3(P0, P1, Q1)
        if not E0 < E1:
            E0, E1 = E1, E0
        return E0 <= dist2(P0, P1) and 0 <= E1
    return C0 * C1 <= 0 and D0 * D1 <= 0

def solve(N, PS, q0, q1):
    yield 10**18
    p0 = PS[0]; p1 = PS[1]
    if not is_intersection(p0, p1, q0, q1):
        yield sqrt(dist2(p0, p1))
        return
    V0 = [i for i in range(2, N) if not is_intersection(p0, PS[i], q0, q1)]
    V1 = [i for i in range(2, N) if not is_intersection(p1, PS[i], q0, q1)]
    D0 = [sqrt(dist2(p0, p)) for p in PS]
    D1 = [sqrt(dist2(p1, p)) for p in PS]
    for v0 in V0:
        for v1 in V1:
            if v0 != v1:
                if is_intersection(PS[v0], PS[v1], q0, q1):
                    continue
                yield D0[v0] + D1[v1] + sqrt(dist2(PS[v0], PS[v1]))
            else:
                yield D0[v0] + D1[v1]

ans = min(
        sqrt(dist2(QS[0], QS[1])) + min(solve(N, PS, QS[0], QS[1])),
        sqrt(dist2(PS[0], PS[1])) + min(solve(M, QS, PS[0], PS[1]))
        )
if ans < 10**9:
    write("%.16f\n" % ans)
else:
    write("-1\n")
```