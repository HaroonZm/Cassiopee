En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def GCD(x, y):
    if y == 0:
        return x
    return GCD(y, x % y)

def CountBitFlag(T):
    T = (T & 0x55555555) + ((T >> 1) & 0x55555555)
    T = (T & 0x33333333) + ((T >> 2) & 0x33333333)
    T = (T & 0x0F0F0F0F) + ((T >> 4) & 0x0F0F0F0F)
    T = (T & 0x00FF00FF) + ((T >> 8) & 0x00FF00FF)
    T = (T & 0x0000FFFF) + ((T >> 16) & 0x0000FFFF)
    return T

N, M = map(int, input().split())
A = tuple(map(int, input().split()))
P = tuple(map(int, input().split()))

Prob = [1.0] * (1 << N)
LCM = [1] * (1 << N)
ans = 0

for bit in range(1, 1 << N):
    top = (bit & -bit).bit_length() - 1
    l = bit & (bit - 1)
    Prob[bit] = Prob[l] * P[top] / 100
    LCM[bit] = LCM[l] // GCD(LCM[l], A[top]) * A[top]
    if CountBitFlag(bit) % 2 == 1:
        ans += M // LCM[bit] * Prob[bit]
    else:
        ans -= M // LCM[bit] * Prob[bit]

print("{:.8f}".format(ans))
```