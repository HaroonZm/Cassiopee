Voici un énoncé de problème :

Problem B:
Red and Black
There is a rectangular room, covered with square tiles. Each tile is
colored either red or black. A man is standing on a black tile.
From a tile, he can move to one of four adjacent tiles. But he can't
move on red tiles, he can move only on black tiles.
Write a program to count the number of black tiles which he can reach
by repeating the moves described above.
Input
The input consists of multiple data sets.
A data set starts with a line containing two positive integers
W
and
H
;
W
and
H
are the numbers of tiles in the
x
-
and
y
- directions, respectively.
W
and
H
are
not more than 20.
There are
H
more lines in the data set, each of which
includes
W
characters. Each character represents the color of a
tile as follows.
'.' - a black tile
'#' - a red tile
'@' - a man on a black tile(appears exactly once in a data set)
The end of the input is indicated by a line consisting of two zeros.
Output
For each data set, your program
should output a line which contains the number of
tiles he can reach from the initial tile (including itself).
Sample Input
6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
11 6
..#..#..#..
..#..#..#..
..#..#..###
..#..#..#@.
..#..#..#..
..#..#..#..
7 7
..#.#..
..#.#..
###.###
...@...
###.###
..#.#..
..#.#..
0 0
Output for the Sample Input
45
59
6
13


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
delta = ((1, 0), (0, 1), (-1, 0), (0, -1))
def ds(here, lb, ub, field):
	if field[here[1]][here[0]] == "#":
		return 0
	result = 1
	field[here[1]][here[0]] = "#"
	for dx, dy in delta:
		next = (here[0]+dx,here[1]+dy)
		if lb[0] <= next[0] < ub[0] and lb[1] <= next[1] < ub[1]:
			result += ds(next, lb, ub, field)
	return result
while 1:
	W, H = map(int,raw_input().split(" "))
	if W == H == 0:
		break
	floor = [list(raw_input()) for i in range(H)]
	start = None
	for i in range(H):
		for j in range(W):
			if floor[i][j] == "@":
				start = (j,i)
				break
		if start is not None:
			break
	print ds(start,(0,0),(W,H),floor)
```