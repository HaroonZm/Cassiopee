En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from bisect import bisect_right as br
def main():
  while True:
    n, m = map(int, input().split())
    if n == 0:break
    ofuton = list(map(int, input().split()))
    dlst = sorted(map(int, input().split()))
    
    INF = 10 ** 20
    end = 2 ** n - 1
    dic = {}
    def min_score(stat, power, index):
      if stat in dic:return dic[stat]
      if stat == end:return 0
      
      mask = 1
      ret = INF
      for i in range(n):
        if mask & stat:
          mask <<= 1
          continue
        new_power = power + ofuton[i]
        new_stat = stat | mask
        new_index = br(dlst, new_power) - 1
        add = (m - new_index - 1) * ofuton[i]
        for j in range(index + 1, new_index + 1):
          if new_power - dlst[j] < dlst[j] - power:
            add += (dlst[j] - power) - (new_power - dlst[j])
        ret = min(ret, -add + min_score(new_stat, new_power, new_index))
        mask <<= 1
      dic[stat] = ret
      return ret
    
    print(sum(dlst) + min_score(0, 0, -1))

main()
```