Voici un énoncé de problème :

Score :
800
points
Problem Statement
Snuke found a record of a tree with
N
vertices in ancient ruins.
The findings are as follows:
The vertices of the tree were numbered
1,2,...,N
, and the edges were numbered
1,2,...,N-1
.
Edge
i
connected Vertex
a_i
and
b_i
.
The length of each edge was an integer between
1
and
10^{18}
(inclusive).
The sum of the shortest distances from Vertex
i
to Vertex
1,...,N
was
s_i
.
From the information above, restore the length of each edge.
The input guarantees that it is possible to determine the lengths of the edges consistently with the record.
Furthermore, it can be proved that the length of each edge is uniquely determined in such a case.
Constraints
2 \leq N \leq 10^{5}
1 \leq a_i,b_i \leq N
1 \leq s_i \leq 10^{18}
The given graph is a tree.
All input values are integers.
It is possible to consistently restore the lengths of the edges.
In the restored graph, the length of each edge is an integer between
1
and
10^{18}
(inclusive).
Partial Scores
In the test set worth
300
points,
a_i = i, b_i = i+1
.
In the test set worth
200
points,
N \geq 3, a_i = 1, b_i = i+1
.
Input
Input is given from Standard Input in the following format:
N
a_1
b_1
:
a_{N-1}
b_{N-1}
s_1
s_2
...
s_{N}
Output
Print
N-1
lines. The
i
-th line must contain the length of Edge
i
.
Sample Input 1
4
1 2
2 3
3 4
8 6 6 8
Sample Output 1
1
2
1
The given record corresponds to the tree shown below:
Sample Input 2
5
1 2
1 3
1 4
1 5
10 13 16 19 22
Sample Output 2
1
2
3
4
The given record corresponds to the tree shown below:
Sample Input 3
15
9 10
9 15
15 4
4 13
13 2
13 11
2 14
13 6
11 1
1 12
12 3
12 7
2 5
14 8
1154 890 2240 883 2047 2076 1590 1104 1726 1791 1091 1226 841 1000 901
Sample Output 3
5
75
2
6
7
50
10
95
9
8
78
28
89
8


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N = int(readline())
data = list(map(int,read().split()))
A = data[:N+N-2:2]
B = data[1:N+N-2:2]
INF = 10 ** 18 + 100
S = [INF] + data[-N:]

graph = [[] for _ in range(N+1)]
for a,b in zip(A,B):
    graph[a].append(b)
    graph[b].append(a)

root = S.index(min(S))
parent = [0] * (N+1)
order = []
stack = [root]
while stack:
    x = stack.pop()
    order.append(x)
    for y in graph[x]:
        if y == parent[x]:
            continue
        parent[y] = x
        stack.append(y)

subtree_size = [1] * (N+1)
for v in reversed(order):
    subtree_size[parent[v]] += subtree_size[v]

length = [0] * (N+1)
for v,p in zip(A,B):
    if parent[p] == v:
        v,p = p,v
    s = subtree_size[v]
    d = N - s - s
    length[v] = 0 if d == 0 else(S[v] - S[p]) // d

# 重心間以外は決まった。いったん、重心間を 0 として計算

dist = [0] * (N+1)
for v in order[1:]:
    p = parent[v]
    dist[v] = dist[p] + length[v]

d_root = sum(dist)
x = (S[root] - d_root) * 2 // N
answer = []
for v,p in zip(A,B):
    if parent[p] == v:
        v,p = p,v
    if length[v] == 0:
        length[v] = x
    answer.append(length[v])

print('\n'.join(map(str,answer)))
```