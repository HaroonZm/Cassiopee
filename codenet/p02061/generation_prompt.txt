Voici un énoncé de problème :

B: 自身の 2 倍
問題
クエリが
Q
個与えられます。1 個のクエリにつき、 1 つの正の整数
N
が与えられるので、次の 2 つの条件を満たす正の整数
M
の個数を求めてください。
2 \leq M \leq N
を満たす
M
の約数のうち、
M
を除いたものの総積が
M
の
2
倍以上になる
入力形式
入力は以下の形式で与えられます。
Q
N_1
N_2
:
N_Q
1
行目では、クエリ数
Q
が与えられます。
2
行目から
N+1
行目では、各クエリについて与えられる 1 つの正の整数
N
が与えられます。
制約
1 \leq Q \leq 10^5
2 \leq N_i \leq 10^5
(1 \leq i \leq Q)
出力形式
上記の 2 つの条件を満たす正の整数の個数を、各
N_i
に対して、改行区切りで出力してください。
入力例
3
43
9
24
出力例
11
0
5
N=24
の時、
M
として考えられるのは
12
,
16
,
18
,
20
,
24
の
5
種類である。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from itertools import product, accumulate
from math import gcd
from bisect import bisect
import sys
from sys import setrecursionlimit
setrecursionlimit(10**9)
input = sys.stdin.readline
def inpl(): return list(map(int, input().split()))

def primes(N):
    sieve = [1]*(N+1)
    sieve[:2] = [0, 0]
    P = []
    for i in range(2, N+1):
        if sieve[i]:
            P.append(i)
            for j in range(2*i, N+1, i):
                sieve[j] = 0
    return P

C = [1]*(10**5+1)
C[0] = 0
C[1] = 0
P = primes(10**5)

for p in P:
    C[p] = 0

for p in P:
    if p**3 > 100000:
        break
    C[p**3] = 0

for i in range(len(P)):
    for j in range(i, bisect(P, 10**5//P[i])):
        C[P[i] * P[j]] = 0

S = list(accumulate(C))
for _ in range(int(input())):
    print(S[int(input())])
```