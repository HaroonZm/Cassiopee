Voici un énoncé de problème :

C : Pruning / 枝刈り
Problem
とにかくあつい。あづい君の住んでいる地域は今年猛暑であった。 さらに、家の庭には 1 本の木が生えており、毎日やかましく鳴く蝉が暑さを増幅させているような気がする。
庭の木は、まさにグラフ理論でいうところの木のような形をしており、この木にはたくさんの蝉が止まっている。
蝉は、必ず枝の先端(葉)または枝の分かれ目(頂点)に止まる習性がある。 ただし、木の根には 1 匹も止まることはない。
この木のある枝(辺)を切ると、それより空側(根と反対側)にいる蝉を全て駆除することができる。
ただし、枝を切るためには、その枝に応じた労力が必要となる。
(注 : 括弧内の言葉はグラフ理論の言葉で置き換えたものである。以降は全てグラフ理論の言葉で表現することにする。)
高度情報化社会となった現代においては、 部屋に居ながらにして頂点に何匹の蝉がいるか、 そして各辺を切るのに要する労力を調べることが出来る。
あづい君はその情報を用いて、 木に止まっている全ての蝉を駆除するのに必要な最小の労力を調べるプログラムを書くことにした。
Input
入力は次のような形式で与えられる．
N
C
1
...
C
N-1
u
0
v
0
p
0
...
u
N-2
v
N-2
p
N-2
N
は木に含まれる頂点の数である。 各頂点には 0 ...
N
- 1 の番号が振られ、0番目の頂点を根とする。
C
1
...
C
N-1
は、各頂点に止まっている蝉の数であり、
C
i
が
i
番目の頂点に止まっている蝉の数である。 根には、蝉は1匹も止まっていない。 2 +
i
行目の
u
i
,
v
i
,
p
i
は、木に含まれる辺の情報である。
u
i
,
v
i
は辺が結ぶ 2 頂点の番号であり、
p
i
はこの辺を切るのに必要な労力である。
Constraints
入力は全て整数である。
与えられるグラフは木である。
2 ≦
N
≦ 1,000
0 ≦
C
i
≦ 1,000
0 ≦
u
i
,
v
i
<
N
1 ≦
p
i
≦ 1,000
Output
蝉を全て駆除するために必要な最小の労力を 1 行で出力せよ。
Samples
Sample Input 1
5
2 2 2 2
0 1 4
1 2 1
1 3 1
1 4 1
Sample Output 1
4
頂点 0 と 1 をつなぐ辺を切れば、全ての蝉を駆除することができる。
Sample Input 2
5
0 2 2 2
0 1 4
1 2 1
1 3 1
1 4 1
Sample Output 2
3
頂点 1 と 2 、 1 と 3 、 1 と 4 をつなぐ辺の3本を切れば最小の労力で蝉を駆除することができる。 なお、頂点 0 と 1 をつなぐ辺を切ることで全ての蝉を駆除することができるが、これにはコストが 4 かかってしまう。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque
import bisect

INF = float("inf")

N = int(input())
C = list(map(int, input().split()))
uvp = [list(map(int, input().split())) for i in range(N-1)]

edge = [[0]*(N+1) for i in range(N+1)]
utov = [[] for i in range(N+1)]

for u, v, p in uvp:
    edge[u][v] = edge[v][u] = p
    utov[u].append(v)
    utov[v].append(u)

for i in range(1, N):
    if (C[i-1] > 0):
        edge[i][N] = INF
        utov[i].append(N)
        utov[N].append(i)

def bfs(s, g, n):
    bfs_map = [-1]*n
    bfs_map[s] = 0
    q = deque()
    q.append(s)

    while q:
        u = q.popleft()
        for v in utov[u]:
            if (edge[u][v] > 0) and (bfs_map[v] < 0):
                bfs_map[v] = bfs_map[u] + 1
                q.append(v)

    return bfs_map

def update(s, g, bfs_map):
    f = INF
    distance = bfs_map[g]
    p = [[None, None] for i in range(distance)]
    y = g
    for i in range(distance)[::-1]:
        p[i][1] = y
        for x in utov[y]:
            if (edge[x][y] > 0) and (bfs_map[x] == i):
                if (edge[x][y] < f):
                    f = edge[x][y]
                y = x
                p[i][0] = x
                break
        else:
            return 0
    for x,y in p:
        edge[x][y] -= f
        edge[y][x] += f
    return f

def dinic(s, g, n):
    max_flow = 0
    while True:
        bfs_map = bfs(s, g, n)
        if (bfs_map[g] < 0):
            return max_flow
        cap = update(s, g, bfs_map)
        while (cap > 0):
            max_flow += cap
            cap = update(s, g, bfs_map)

print(dinic(0, N, N+1))
```