Voici un énoncé de problème :

Problem A:
Alien's Counting
Natsuki and her friends were taken to the space by an alien and made friends with a lot of aliens. During the space travel, she discovered that aliens’ hands were often very different from humans’. Generally speaking, in a kind of aliens, there are
N
fingers and
M
bend rules on a hand. Each bend rule describes that a finger A always bends when a finger B bends. However, this rule does not always imply that the finger B bends when the finger A bends.
When she were counting numbers with the fingers, she was anxious how many numbers her alien friends can count with the fingers. However, because some friends had too complicated rule sets, she could not calculate those. Would you write a program for her?
Input
N M
S
1
D
1
S
2
D
2
.
.
.
S
M
D
M
The first line contains two integers
N
and
M
(1 ≤
N
≤ 1000, 0 ≤
M
≤ 1000) in this order. The following
M
lines mean bend rules. Each line contains two integers
S
i
and
D
i
in this order, which mean that the finger
D
i
always bends when the finger
S
i
bends. Any finger appears at most once in
S
.
Output
Calculate how many numbers her alien friends can count with the fingers. Print the answer modulo 1000000007 in a line.
Sample Input 1
5 4
2 3
3 4
4 3
5 4
Output for the Sample Input 1
10
Sample Input 2
5 5
1 2
2 3
3 4
4 5
5 1
Output for the Sample Input 2
2
Sample Input 3
5 0
Output for the Sample Input 3
32


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys

def func(d, S, D):
    if S[d] == []:
        return 2, [d]
    else:
        tmp = 1
        used=[d]
        for k in S[d]:
            ret = func(k,S,D)
            tmp *= ret[0]
            used += ret[1]
        return tmp+1 , used

sys.setrecursionlimit(100000)
N,M=map(int,raw_input().split())
S=[[] for i in range(N)]
D=[-1 for i in range(N)]
for i in range(M):
    s,d=map(lambda x: int(x)-1 ,raw_input().split())
    D[s] = d
    S[d].append(s)

unevaled=range(N)
bans=[]
while(len(unevaled)>0):
    #find root
    tmp=unevaled[0]
    T=[tmp]
    while (1):
        if D[tmp]==-1:
            root=tmp
            break
        elif D[tmp] in T:
            root=D[tmp]
            D[root]=-1
            rebase=T[ T.index(root) : ]
            Stmp=[]
            for r in rebase:
                for rs in S[r]:
                    if rs not in rebase:
                        D[rs]=root
                        Stmp.append(rs)
                if r!=root:
                    unevaled.remove(r)
            S[root]=Stmp[:]
            break
        else:
            tmp=D[tmp]
            T.append(tmp)
    b = func(root, S, D)
    bans.append(b[0])
    for r in b[1]:
        unevaled.remove(r)
ans = reduce(lambda x,y: x*y, bans)
print ans%1000000007
```