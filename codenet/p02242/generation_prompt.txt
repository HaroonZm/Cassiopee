En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq
from collections import deque
from enum import Enum
import sys
import math
from _heapq import heappush, heappop

#------------------------------------------#

BIG_NUM = 2000000000
HUGE_NUM = 9999999999999999
MOD = 1000000007
EPS = 0.000000001

#------------------------------------------#

class Edge:
    def __init__(self,arg_to,arg_cost):
        self.to = arg_to
        self.cost = arg_cost

class Info:
    def __init__(self,arg_node_id,arg_sum_cost):
        self.node_id = arg_node_id
        self.sum_cost = arg_sum_cost

    def __lt__(self,arg):
        return self.sum_cost < arg.sum_cost

V = int(input())
min_dist = [BIG_NUM]*V
G = [[] for i in range(V)]

for loop in range(V):
    node_id,tmp_num,*table = list(map(int,input().split()))
    for i in range(0,len(table),2):
        G[node_id].append(Edge(table[i],table[i+1]))

min_dist[0] = 0
Q = []

heappush(Q, Info(0,0))

while len(Q) > 0:
    info = heappop(Q)
    if info.sum_cost > min_dist[info.node_id]:
        continue
    for edge in G[info.node_id]:
        if min_dist[edge.to] > info.sum_cost+edge.cost:
            min_dist[edge.to] = info.sum_cost+edge.cost
            heappush(Q, Info(edge.to,min_dist[edge.to]))

for i in range(V):
    print("%d %d"%(i,min_dist[i]))
```