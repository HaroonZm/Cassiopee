Voici un énoncé de problème :

Single Source Shortest Path
For a given weighted graph $G = (V, E)$, find the shortest path from a source to each vertex. For each vertex $u$, print the total weight of edges on the shortest path from vertex $0$ to $u$.
Input
In the first line, an integer $n$ denoting the number of vertices in $G$ is given. In the following $n$ lines, adjacency lists for each vertex $u$ are respectively given in the following format:
$u$ $k$ $v_1$ $c_1$ $v_2$ $c_2$ ... $v_k$ $c_k$
Vertices in $G$ are named with IDs $0, 1, ..., n-1$. $u$ is ID of the target vertex and $k$ denotes its degree. $v_i (i = 1, 2, ... k)$ denote IDs of vertices adjacent to $u$ and $c_i$ denotes the weight of a directed edge connecting $u$ and $v_i$ (from $u$ to $v_i$).
Output
For each vertex, print its ID and the distance separated by a space character in a line respectively. Print in order of vertex IDs.
Constraints
$1 \leq n \leq 100$
$0 \leq c_i \leq 100,000$
$|E| \leq 10,000$
All vertices are reachable from vertex $0$
Sample Input 1
5
0 3 2 3 3 1 1 2
1 2 0 2 3 4
2 3 0 3 3 1 4 1
3 4 2 1 0 1 1 4 4 3
4 2 2 1 3 3
Sample Output 1
0 0
1 2
2 2
3 1
4 3
Reference
Introduction to Algorithms, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. The MIT Press.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq
from collections import deque
from enum import Enum
import sys
import math
from _heapq import heappush, heappop

#------------------------------------------#

BIG_NUM = 2000000000
HUGE_NUM = 9999999999999999
MOD = 1000000007
EPS = 0.000000001

#------------------------------------------#

class Edge:
    def __init__(self,arg_to,arg_cost):
        self.to = arg_to
        self.cost = arg_cost

class Info:
    def __init__(self,arg_node_id,arg_sum_cost):
        self.node_id = arg_node_id
        self.sum_cost = arg_sum_cost

    def __lt__(self,arg):
        return self.sum_cost < arg.sum_cost

V = int(input())
min_dist = [BIG_NUM]*V
G = [[] for i in range(V)]

for loop in range(V):
    node_id,tmp_num,*table = list(map(int,input().split()))
    for i in range(0,len(table),2):
        G[node_id].append(Edge(table[i],table[i+1]))

min_dist[0] = 0
Q = []

heappush(Q, Info(0,0))

while len(Q) > 0:
    info = heappop(Q)
    if info.sum_cost > min_dist[info.node_id]:
        continue
    for edge in G[info.node_id]:
        if min_dist[edge.to] > info.sum_cost+edge.cost:
            min_dist[edge.to] = info.sum_cost+edge.cost
            heappush(Q, Info(edge.to,min_dist[edge.to]))

for i in range(V):
    print("%d %d"%(i,min_dist[i]))
```