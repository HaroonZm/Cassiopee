Voici un énoncé de problème :

Anchored Balloon
A balloon placed on the ground is connected to one or more anchors on the ground with ropes.
Each rope is long enough to connect the balloon and the anchor.
No two ropes cross each other.
Figure E-1 shows such a situation.
Figure E-1: A balloon and ropes on the ground
Now the balloon takes off, and your task is to find how high
the balloon can go up with keeping the rope connections.
The positions of the anchors are fixed.
The lengths of the ropes and the positions of the anchors are given.
You may assume that these ropes have no weight and
thus can be straightened up when pulled to
whichever directions.
Figure E-2 shows the highest position of the balloon for
the situation shown in Figure E-1.
Figure E-2: The highest position of the balloon
Input
The input consists of multiple datasets, each in the following format.
n
x
1
y
1
l
1
...
x
n
y
n
l
n
The first line of a dataset contains an integer
n
(1 ≤
n
≤ 10) representing the number of the ropes.
Each of the following
n
lines contains three integers,
x
i
,
y
i
, and
l
i
, separated by a single space.
P
i
=
(
x
i
,
y
i
) represents
the position of the anchor connecting the
i
-th rope,
and
l
i
represents the length of the rope.
You can assume that
−100 ≤
x
i
≤ 100,
−100 ≤
y
i
≤ 100, and
1 ≤
l
i
≤ 300.
The balloon is initially placed at (0, 0) on the ground.
You can ignore the size of the balloon and the anchors.
You can assume that
P
i
and
P
j
represent different positions if
i
≠
j
.
You can also assume that the distance between
P
i
and (0, 0) is less than or equal to
l
i
−1.
This means that the balloon can go up at least 1 unit high.
Figures E-1 and E-2 correspond to the first dataset of Sample Input below.
The end of the input is indicated by a line containing a zero.
Output
For each dataset,
output a single line containing the maximum height that the balloon can go up.
The error of the value should be no greater than 0.00001.
No extra characters should appear in the output.
Sample Input
3
10 10 20
10 -10 20
-10 10 120
1
10 10 16
2
10 10 20
10 -10 20
2
100 0 101
-90 0 91
2
0 0 53
30 40 102
3
10 10 20
10 -10 20
-10 -10 20
3
1 5 13
5 -3 13
-3 -3 13
3
98 97 168
-82 -80 193
-99 -96 211
4
90 -100 160
-80 -80 150
90 80 150
80 80 245
4
85 -90 290
-80 -80 220
-85 90 145
85 90 170
5
0 0 4
3 0 5
-3 0 5
0 3 5
0 -3 5
10
95 -93 260
-86 96 211
91 90 177
-81 -80 124
-91 91 144
97 94 165
-90 -86 194
89 85 167
-93 -80 222
92 -84 218
0
Output for the Sample Input
17.3205081
16.0000000
17.3205081
13.8011200
53.0000000
14.1421356
12.0000000
128.3928757
94.1879092
131.1240816
4.0000000
72.2251798


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
"""http://mayokoex.hatenablog.com/entry/2015/06/11/124120を参照しました"""
"""三分探索、賢い"""
import sys
MI = 1e-6
def calc(x,y,b):
    res = 90000
    for bx,by,l in b:
        d = l**2-(x-bx)**2-(y-by)**2
        if d < res:
            res = d
    return res

def search_y(x,b):
    p = [-100,-33,33,100]
    for t in range(100):
        if abs(p[0]-p[3]) < MI:
            return (calc(x,p[0],b)+calc(x,p[3],b))/2
        l = calc(x,p[1],b)
        r = calc(x,p[2],b)
        if l < r:
            p[0] = p[1]
        else:
            p[3] = p[2]
        p[1] = (2*p[0]+p[3])/3
        p[2] = (p[0]+2*p[3])/3
    return (calc(x,p[0],b)+calc(x,p[3],b))/2

def search(b):
    p = [-100,-33,33,100]
    for t in range(100):
        if abs(p[0]-p[3]) < MI:
            return (search_y(p[0],b)+search_y(p[3],b))/2
        l = search_y(p[1],b)
        r = search_y(p[2],b)
        if l < r:
            p[0] = p[1]
        else:
            p[3] = p[2]
        p[1] = (2*p[0]+p[3])/3
        p[2] = (p[0]+2*p[3])/3
    return (search_y(p[0],b)+search_y(p[3],b))/2

def solve(n):
    b = [[int(x) for x in sys.stdin.readline().split()] for i in range(n)]
    ans = 0
    print(search(b)**0.5)

while 1:
    n = int(sys.stdin.readline())
    if n == 0:
        break
    solve(n)
```