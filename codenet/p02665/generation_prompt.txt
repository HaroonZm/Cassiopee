Voici un énoncé de problème :

Score :
600
points
Problem Statement
Given is an integer sequence of length
N+1
:
A_0, A_1, A_2, \ldots, A_N
. Is there a binary tree of depth
N
such that, for each
d = 0, 1, \ldots, N
, there are exactly
A_d
leaves at depth
d
? If such a tree exists, print the maximum possible number of vertices in such a tree; otherwise, print
-1
.
Notes
A binary tree is a rooted tree such that each vertex has at most two direct children.
A leaf in a binary tree is a vertex with zero children.
The depth of a vertex
v
in a binary tree is the distance from the tree's root to
v
. (The root has the depth of
0
.)
The depth of a binary tree is the maximum depth of a vertex in the tree.
Constraints
0 \leq N \leq 10^5
0 \leq A_i \leq 10^{8}
(
0 \leq i \leq N
)
A_N \geq 1
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
A_0
A_1
A_2
\cdots
A_N
Output
Print the answer as an integer.
Sample Input 1
3
0 1 1 2
Sample Output 1
7
Below is the tree with the maximum possible number of vertices. It has seven vertices, so we should print
7
.
Sample Input 2
4
0 0 1 0 2
Sample Output 2
10
Sample Input 3
2
0 3 1
Sample Output 3
-1
Sample Input 4
1
1 1
Sample Output 4
-1
Sample Input 5
10
0 0 1 1 2 3 5 8 13 21 34
Sample Output 5
264


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# 深さdの上限を先に決める
N = int(input())
# Aは，葉として残す必要があるものの数
A = list(map(int, input().split()))

# 深さdのノード数の上限
limit = [1]
for i in range(1, N+1):
    if i == N:  # 一番深いところの上限はA[N]
        limit.append(A[i])
    else:
        limit.append((limit[-1]-A[i-1])*2)
        if limit[-1] < 0:
            print(-1)
            exit()

# Nが0の時の処理
if N == 0:
    if A[0] != 1:
        print(-1)
        exit()

# 一番深いところから構築して最後にsumをとる
ans = [A[-1]]
now_leaf = A[-1]  # 一番深いところから構築しており，今現在の葉の数
for i in range(N-1, -1, -1):
    # print(A[i])
    ans.append(min(now_leaf+A[i], limit[i]))
    now_leaf = ans[-1]
# 構築したものに対してジャッジする, 葉を確保できているかどうか
for i in range(N):
    # ans[N-i]とすることで，今は一番浅いところから見ている
    if (ans[N-i]-A[i])*2 < A[i+1]:  # 葉が確保できているか
        print(-1)
        exit()
print(sum(ans))
```