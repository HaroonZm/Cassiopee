Voici un énoncé de problème :

Score :
1200
points
Problem Statement
One day Mr. Takahashi picked up a dictionary containing all of the
N
! permutations of integers
1
through
N
.
The dictionary has
N
! pages, and page
i
(
1 ≤ i ≤ N!
) contains the
i
-th permutation in the lexicographical order.
Mr. Takahashi wanted to look up a certain permutation of length
N
in this dictionary, but he forgot some part of it.
His memory of the permutation is described by a sequence
P_1, P_2, ..., P_N
.
If
P_i = 0
, it means that he forgot the
i
-th element of the permutation; otherwise, it means that he remembered the
i
-th element of the permutation and it is
P_i
.
He decided to look up all the possible permutations in the dictionary.
Compute the sum of the page numbers of the pages he has to check, modulo
10^9 + 7
.
Constraints
1 ≤ N ≤ 500000
0 ≤ P_i ≤ N
P_i ≠ P_j
if
i ≠ j
(
1 ≤ i, j ≤ N
),
P_i ≠ 0
and
P_j ≠ 0
.
Partial Score
In test cases worth
500
points,
1 ≤ N ≤ 3000
.
Input
The input is given from Standard Input in the following format:
N
P_1
P_2
...
P_N
Output
Print the sum of the page numbers of the pages he has to check, as modulo
10^9 + 7
.
Sample Input 1
4
0 2 3 0
Sample Output 1
23
The possible permutations are [
1
,
2
,
3
,
4
] and [
4
,
2
,
3
,
1
].
Since the former is on page
1
and the latter is on page
22
, the answer is
23
.
Sample Input 2
3
0 0 0
Sample Output 2
21
Since all permutations of length
3
are possible, the answer is
1 + 2 + 3 + 4 + 5 + 6 = 21
.
Sample Input 3
5
1 2 3 5 4
Sample Output 3
2
Mr. Takahashi remembered all the elements of the permutation.
Sample Input 4
1
0
Sample Output 4
1
The dictionary consists of one page.
Sample Input 5
10
0 3 0 0 1 0 4 0 0 0
Sample Output 5
953330050


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+"\n")

M = 10**9+7
n = int(input())
p = list(map(int, input().split()))
g1 = [None]*(n+10)
v = 1
g1[0] = 1
for i in range(1,len(g1)):
    v *= i
    v %= M
    g1[i] = v
    
def init(bit, values):
    for i,v in enumerate(values):
        add(bit,i+1,v)
#a1 ~ aiまでの和 O(logn)
def query(bit,i):
    res = 0
    while i > 0:
        res += bit[i]
        i -= i&(-i)
    return res

#ai += x(logN)
def add(bit,i,x):
    if i==0:
        raise RuntimeError
    while i <= len(bit)-1:
        bit[i] += x
        i += i&(-i)
    return

index = [i for i,num in enumerate(p) if num==0]
used = [False]*n
for i in range(n):
    if p[i]>0:
        used[p[i]-1] = True
nl = []
for i in range(n):
    if not used[i]:
        nl.append(i+1)
nl.sort()
scores = [0]*(n+1) # scores[i]: nlのうちiより大きいものの個数
v = len(nl)
cur = 0
for i in range(1,n+1):
    if nl and cur<len(nl) and nl[cur]<i:
#     if nl and nl[cur]<i:
        cur += 1
        v -= 1
    scores[i] = v
ans = 0
bit = [0]*(n+1)
s = set(index)
val = 0
pp = len(index) # 欠損の個数
ss = sum(nl)
num = 0
inv2 = pow(2, M-2, M)
for i in range(n):
    if i in s:
        ans += (g1[pp-1] * (ss - pp - val - pp*(num)*inv2)) * g1[n-i-1]
        num += 1
    else:
        ans += (g1[pp] * (p[i]-query(bit, p[i])-1) - g1[pp-1]*num*(len(nl)-scores[p[i]])) * g1[n-i-1]
        add(bit, p[i], 1)
        val += scores[p[i]]
    ans %= M
#     print(ans, val)
print((ans + g1[pp])%M)
```