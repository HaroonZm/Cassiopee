Voici un énoncé de problème :

Score :
100
points
Problem Statement
You are given a binary array
A=(A_1,A_2,\cdots,A_N)
of length
N
.
Process
Q
queries of the following types. The
i
-th query is represented by three integers
T_i,L_i,R_i
.
T_i=1
: Replace the value of
A_j
with
1-A_j
for each
L_i \leq j \leq R_i
.
T_i=2
: Calculate the inversion(*) of the array
A_{L_i},A_{L_i+1},\cdots,A_{R_i}
．
Note：The inversion of the array
x_1,x_2,\cdots,x_k
is the number of the pair of integers
i,j
with
1 \leq i < j \leq k, x_i > x_j
.
Constraints
1 \leq N \leq 2 \times 10^5
0 \leq A_i \leq 1
1 \leq Q \leq 2 \times 10^5
1 \leq T_i \leq 2
1 \leq L_i \leq R_i \leq N
All values in Input are integer.
Input
Input is given from Standard Input in the following format:
N
Q
A_1
A_2
\cdots
A_N
T_1
L_1
R_1
T_2
L_2
R_2
\vdots
T_Q
L_Q
R_Q
Output
For each query with
T_i=2
, print the answer.
Sample Input 1
5 5
0 1 0 0 1
2 1 5
1 3 4
2 2 5
1 1 3
2 1 2
Sample Output 1
2
0
1
First query: Print
2
, which is the inversion of
(A_1,A_2,A_3,A_4,A_5)=(0,1,0,0,1)
.
Second query: Replace the value of
A_3
and
A_4
with
1
and
1
, respectively.
Third query: Print
0
, which is the inversion of
(A_2,A_3,A_4,A_5)=(1,1,1,1)
.
Fourth query: Replace the value of
A_1
,
A_2
and
A_4
with
1
,
0
and
0
, respectively.
Fifth query: Print
1
, which is the inversion of
(A_1,A_2)=(1,0)
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
input = lambda: sys.stdin.readline().rstrip()
 
class LazySegmentTree():
    def __init__(self, init, unitX, unitA, f, g, h):
        self.f = f # (X, X) -> X
        self.g = g # (X, A, size) -> X
        self.h = h # (A, A) -> A
        self.unitX = unitX
        self.unitA = unitA
        self.f = f
        if type(init) == int:
            self.n = init
            # self.n = 1 << (self.n - 1).bit_length()
            self.X = [unitX] * (self.n * 2)
            self.size = [1] * (self.n * 2)
        else:
            self.n = len(init)
            # self.n = 1 << (self.n - 1).bit_length()
            self.X = [unitX] * self.n + init + [unitX] * (self.n - len(init))
            self.size = [0] * self.n + [1] * len(init) + [0] * (self.n - len(init))
            for i in range(self.n-1, 0, -1):
                self.X[i] = self.f(self.X[i*2], self.X[i*2|1])
    
        for i in range(self.n - 1, 0, -1):
            self.size[i] = self.size[i*2] + self.size[i*2|1]
        
        self.A = [unitA] * (self.n * 2)
        
    def update(self, i, x):
        i += self.n
        self.X[i] = x
        i >>= 1
        while i:
            self.X[i] = self.f(self.X[i*2], self.X[i*2|1])
            i >>= 1
    
    def calc(self, i):
        return self.g(self.X[i], self.A[i], self.size[i])
    
    def calc_above(self, i):
        i >>= 1
        while i:
            self.X[i] = self.f(self.calc(i*2), self.calc(i*2|1))
            i >>= 1
    
    def propagate(self, i):
        self.X[i] = self.g(self.X[i], self.A[i], self.size[i])
        self.A[i*2] = self.h(self.A[i*2], self.A[i])
        self.A[i*2|1] = self.h(self.A[i*2|1], self.A[i])
        self.A[i] = self.unitA
        
    def propagate_above(self, i):
        H = i.bit_length()
        for h in range(H, 0, -1):
            self.propagate(i >> h)
    
    def propagate_all(self):
        for i in range(1, self.n):
            self.propagate(i)
    
    def getrange(self, l, r):
        l += self.n
        r += self.n
        l0, r0 = l // (l & -l), r // (r & -r) - 1
        self.propagate_above(l0)
        self.propagate_above(r0)
        
        al = self.unitX
        ar = self.unitX
        while l < r:
            if l & 1:
                al = self.f(al, self.calc(l))
                l += 1
            if r & 1:
                r -= 1
                ar = self.f(self.calc(r), ar)
            l >>= 1
            r >>= 1
        return self.f(al, ar)
    
    def getvalue(self, i):
        i += self.n
        self.propagate_above(i)
        return self.calc(i)
    
    def operate_range(self, l, r, a):
        l += self.n
        r += self.n
        l0, r0 = l // (l & -l), r // (r & -r) - 1
        self.propagate_above(l0)
        self.propagate_above(r0)
        while l < r:
            if l & 1:
                self.A[l] = self.h(self.A[l], a)
                l += 1
            if r & 1:
                r -= 1
                self.A[r] = self.h(self.A[r], a)
            l >>= 1
            r >>= 1
        
        self.calc_above(l0)
        self.calc_above(r0)
    
    # Find r s.t. calc(l, ..., r-1) = True and calc(l, ..., r) = False
    def max_right(self, l, z):
        if l >= self.n: return self.n
        l += self.n
        s = self.unitX
        while 1:
            while l % 2 == 0:
                l >>= 1
            if not z(self.f(s, self.calc(l))):
                while l < self.n:
                    l *= 2
                    if z(self.f(s, self.calc(l))):
                        s = self.f(s, self.calc(l))
                        l += 1
                return l - self.n
            s = self.f(s, self.calc(l))
            l += 1
            if l & -l == l: break
        return self.n
    
    # Find l s.t. calc(l, ..., r-1) = True and calc(l-1, ..., r-1) = False
    def min_left(self, r, z):
        if r <= 0: return 0
        r += self.n
        s = self.unitX
        while 1:
            r -= 1
            while r > 1 and r % 2:
                r >>= 1
            if not z(self.f(self.calc(r), s)):
                while r < self.n:
                    r = r * 2 + 1
                    if z(self.f(self.calc(r), s)):
                        s = self.f(self.calc(r), s)
                        r -= 1
                return r + 1 - self.n
            s = self.f(self.calc(r), s)
            if r & -r == r: break
        return 0
    
    def debug(self):
        X = self.X
        print("X =", [self.calc(i) for i in range(self.n, self.n * 2)])

if False:
    f = lambda x, y: (x[0] + y[0] + x[2] * y[1], x[1] + y[1], x[2] + y[2])
    g = lambda x, a, s: (x[1] * x[2] - x[0], x[2], x[1]) if a else x
    h = lambda a, b: a ^ b
    unitX = (0, 0, 0)
    unitA = 0

# (inversion, number of zeros, number of ones)
mm = 262143
def f(x, y):
    x0, x1, x2 = x >> 36, (x >> 18) & mm, x & mm
    y0, y1, y2 = y >> 36, (y >> 18) & mm, y & mm
    return (x0 + y0 + x2 * y1 << 36) + (x1 + y1 << 18) + (x2 + y2)
def g(x, a, s):
    x0, x1, x2 = x >> 36, (x >> 18) & mm, x & mm
    return (x1 * x2 - x0 << 36) + (x2 << 18) + x1 if a else x
def h(a, b):
    return a ^ b
unitX = 0
unitA = 0

N, Q = map(int, input().split())
A = [(1 << 18) if int(a) == 0 else 1 for a in input().split()]
st = LazySegmentTree(A, unitX, unitA, f, g, h)

for _ in range(Q):
    t, l, r = map(int, input().split())
    if t == 1:
        st.operate_range(l - 1, r, 1)
    else:
        print(st.getrange(l - 1, r) >> 36)
```