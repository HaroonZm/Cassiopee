Voici un énoncé de problème :

Single Source Shortest Path II
For a given weighted graph $G = (V, E)$, find the shortest path from a source to each vertex. For each vertex $u$, print the total weight of edges on the shortest path from vertex $0$ to $u$.
Input
In the first line, an integer $n$ denoting the number of vertices in $G$ is given. In the following $n$ lines, adjacency lists for each vertex $u$ are respectively given in the following format:
$u$ $k$ $v_1$ $c_1$ $v_2$ $c_2$ ... $v_k$ $c_k$
Vertices in $G$ are named with IDs $0, 1, ..., n-1$. $u$ is ID of the target vertex and $k$ denotes its degree. $v_i (i = 1, 2, ... k)$ denote IDs of vertices adjacent to $u$ and $c_i$ denotes the weight of a directed edge connecting $u$ and $v_i$ (from $u$ to $v_i$).
Output
For each vertex, print its ID and the distance separated by a space character in a line respectively. Print in order of vertex IDs.
Constraints
$1 \leq n \leq 10,000$
$0 \leq c_i \leq 100,000$
$|E| < 500,000$
All vertices are reachable from vertex $0$
Sample Input 1
5
0 3 2 3 3 1 1 2
1 2 0 2 3 4
2 3 0 3 3 1 4 1
3 4 2 1 0 1 1 4 4 3
4 2 2 1 3 3
Sample Output 1
0 0
1 2
2 2
3 1
4 3
Reference
Introduction to Algorithms, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. The MIT Press.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq

INFINITY = 10 ** 10
WHITE = 0
GRAY = 1
BLACK = 2

n = int(input())
dict_adjacency = {}

for _ in range(n):
    u, k, *list_num = map(int, input().split())

    list_temp = []

    dict_adjacency[str(u)] = {}

    for i in range(0, k * 2, 2):
        dict_adjacency[str(u)][str(list_num[i])] = list_num[i + 1]

d = [INFINITY] * n

def dijkstra(top_start):
    color = [WHITE] * n

    d[top_start] = 0
    h = []

    heapq.heappush(h, (d[top_start], top_start))

    while len(h) >= 1:
        cost_now, top_now = heapq.heappop(h)

        color[top_now] = BLACK

        if d[top_now] < cost_now:
            continue

        for top_next in dict_adjacency[str(top_now)].keys():
            top_next = int(top_next)
            if color[top_next] == BLACK:
                continue

            cost_next = d[top_now] + dict_adjacency[str(top_now)][str(top_next)]
            if cost_next < d[top_next]:
                d[top_next] = cost_next
                color[top_next] = GRAY
                heapq.heappush(h, (d[top_next], top_next))

dijkstra(top_start = 0)

for i, cost in enumerate(d):
    print(i, cost)
```