En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from itertools import accumulate
INF = 10 ** 20
n = int(input())
c_lst = []
w_lst = []
for _ in range(n):
  c, w = map(int, input().split())
  c_lst.append(c)
  w_lst.append(w)
w_acc = [0] + list(accumulate(w_lst))
connect = [[None] * n for _ in range(n)]
for i in range(n):
  connect[i][i] = True

def can_connect(left, right):
  if connect[left][right] != None:
    return connect[left][right]
  connect[left][right] = \
     ((c_lst[left] >= w_acc[right + 1] - w_acc[left + 1]) and can_connect(left + 1, right)) or \
     ((c_lst[right] >= w_acc[right] - w_acc[left]) and can_connect(left, right - 1))
  return connect[left][right]

for i in range(n):
  for j in range(i + 1, n):
    can_connect(i, j)

dp = [INF] * (n + 1)
dp[0] = 0
for i in range(n):
  for j in range(i, n):
    if connect[i][j]:
      dp[j + 1] = min(dp[j + 1], dp[i] + 1)
    else:
      break
print(dp[n])
```