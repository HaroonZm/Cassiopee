Voici un énoncé de problème :

Problem E: Rabbit Plays Games!
うさぎがとあるロールプレイングゲームで遊んでいる. 城に入る直前で, 敵に待ち伏せされていた！
うさぎが操作する主人公1 人と,
n
体の敵との戦闘となった. 各キャラクターには4 つの能力値, 体力
h
i
, 攻撃力
a
i
, 防御力
d
i
, 敏捷
s
i
が定められている.
i
= 0 は主人公の情報, 1 ≤
i
≤
n
は各敵の情報を表す.
戦闘はターン制である. 各ターン, 生き残っているキャラクターが, 敏捷の値が高い順に攻撃を行う. 敵は必ず主人公を攻撃する. 主人公は敵1 体を攻撃するが, どの敵を攻撃するかは毎ターンごとに主人公が選べる.攻撃力
a
のキャラクターが防御力
d
のキャラクターに攻撃するとき, max{
a
−
d
, 0} のダメージが与えられる. 受けたダメージの合計が体力の値以上になったキャラクターは直ちに戦闘不能になってしまう. 主人公が戦闘不能になったとき, あるいは敵がすべて戦闘不能になったとき, 戦闘は終了する.
Input
1 ≤
n
≤ 40 000
1 ≤
h
i
,
a
i
,
d
i
,
s
i
≤ 1 000 000 000 (整数)
s
i
はすべて異なる.
Output
主人公が必ず戦闘不能になってしまうとき, −1 を出力せよ. そうでないとき, 主人公が受けるダメージの合計の最小値を一行に出力せよ.
Sample Input 1
2
10 3 1 2
2 4 1 3
2 2 1 1
Sample Output 1
4
Sample Input 2
1
1 1 1 1
10000 10000 10000 10000
Sample Output 2
-1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python

from collections import deque
import itertools as it
import sys
import math

sys.setrecursionlimit(10000000)

n = input()
H, A, D, S = map(int, raw_input().split())
ans = 0
flag = False
ls = []
for i in range(n):
    h, a, d, s = map(int, raw_input().split())
    a -= D
    if s < S:
        ans -= max(0, a)
    if A <= d and a > 0:
        flag = True
    elif a > 0:
        turn = h / (A - d)
        if h % (A - d) != 0:
            turn += 1
        ls.append((turn / float(a), turn, a))
if flag:
    print -1
    exit()
ls.sort()
S = 0
for p in ls:
    S += p[1]
    ans += S * p[2]
if ans < H:
    print ans
else:
    print -1
```