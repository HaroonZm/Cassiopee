En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop, heapify
from collections import defaultdict
import sys
readline = sys.stdin.readline
write = sys.stdout.write
def solve(q):
    N, M = map(int, readline().split())
    if N == M == 0:
        return False
    if q:
        write("\n")
    INF = 10**18
    G = [[] for i in range(N)]
    E = [[INF]*N for i in range(N)]
    for i in range(M):
        a, b, c = map(int, readline().split())
        G[a-1].append((b-1, c))
        G[b-1].append((a-1, c))
        E[a-1][b-1] = E[b-1][a-1] = c
    prv = [-1]*N
    L = int(readline())
    P = []; R = []; I = [0]*L
    B = [0]*L
    que = []
    for i in range(L):
        a, b, c, s = readline().strip().split()
        P.append(s)
        a = int(a)-1; b = int(b)-1; c = int(c)
        dist = [INF] * N
        dist[b] = 0
        que1 = [(0, b)]
        while que1:
            cost, v = heappop(que1)
            if dist[v] < cost:
                continue
            for w, d in G[v]:
                r = cost + d
                if r < dist[w]:
                    dist[w] = r
                    prv[w] = v
                    heappush(que1, (r, w))
                elif r == dist[w]:
                    prv[w] = min(prv[w], v)
        rt = []
        B[i] = b
        v = a
        while v != b:
            rt.append(v)
            v = prv[v]
        rt.append(b)
        R.append(rt)
        que.append((c, 1, i))
    heapify(que)
    res = [0]*L
    QS = [[] for i in range(N)]; rest = L
    D = [defaultdict(list) for i in range(N)]
    F = [{} for i in range(N)]
    U = [1]*N
    while rest:
        t = que[0][0]
        while que and que[0][0] == t:
            _, p, i = heappop(que)
            if p:
                v = R[i][I[i]]
                I[i] += 1
                if B[i] == v:
                    rest -= 1
                    res[i] = t
                else:
                    w = R[i][I[i]]
                    heappush(QS[v], (t, w, i))
                    D[v][w].append(i)
                    F[v][i] = 0
            else:
                U[i] = 1
        for v in range(N):
            if QS[v]:
                qv = QS[v]
                while qv and F[v][qv[0][2]]:
                    heappop(qv)
            if not U[v] or not QS[v]:
                continue
            _, w, k = heappop(QS[v])
            d = E[v][w]
            for k0 in D[v][w]:
                F[v][k0] = 1
                heappush(que, (t+d, 1, k0))
            D[v][w] = []
            heappush(que, (t+d+d, 0, v))
            U[v] = 0
    ans = []
    for i in range(L):
        ans.append((res[i], P[i]))
    ans.sort()
    for e, s in ans:
        write("%s %d\n" % (s, e))
    return True
q = 0
while solve(q):
    q += 1
```