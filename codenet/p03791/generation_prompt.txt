Voici un énoncé de problème :

Score :
900
points
Problem Statement
You are developing frog-shaped robots, and decided to race them against each other.
First, you placed
N
robots onto a number line.
These robots are numbered
1
through
N
.
The current coordinate of robot
i
is
x_i
.
Here, all
x_i
are integers, and
0 < x_1 < x_2 < ... < x_N
.
You will repeatedly perform the following operation:
Select a robot on the number line. Let the coordinate of the robot be
x
. Select the destination coordinate, either
x-1
or
x-2
, that is not occupied by another robot. The robot now jumps to the selected coordinate.
When the coordinate of a robot becomes
0
or less, the robot is considered finished and will be removed from the number line immediately.
You will repeat the operation until all the robots finish the race.
Depending on your choice in the operation, the
N
robots can finish the race in different orders.
In how many different orders can the
N
robots finish the race?
Find the answer modulo
10^9+7
.
Constraints
2 ≤ N ≤ 10^5
x_i
is an integer.
0 < x_1 < x_2 < ... < x_N ≤ 10^9
Partial Score
In a test set worth
500
points,
N ≤ 8
.
Input
The input is given from Standard Input in the following format:
N
x_1
x_2
...
x_N
Output
Print the number of the different orders in which the
N
robots can finish the race, modulo
10^9+7
.
Sample Input 1
3
1 2 3
Sample Output 1
4
There are four different orders in which the three robots can finish the race:
(
Robot
1 →
Robot
2 →
Robot
3)
(
Robot
1 →
Robot
3 →
Robot
2)
(
Robot
2 →
Robot
1 →
Robot
3)
(
Robot
2 →
Robot
3 →
Robot
1)
Sample Input 2
3
2 3 4
Sample Output 2
6
There are six different orders in which the three robots can finish the race:
(
Robot
1 →
Robot
2 →
Robot
3)
(
Robot
1 →
Robot
3 →
Robot
2)
(
Robot
2 →
Robot
1 →
Robot
3)
(
Robot
2 →
Robot
3 →
Robot
1)
(
Robot
3 →
Robot
1 →
Robot
2)
(
Robot
3 →
Robot
2 →
Robot
1)
For example, the order
(
Robot
3 →
Robot
2 →
Robot
1)
can be achieved as shown in the figure below:
Sample Input 3
8
1 2 3 5 7 11 13 17
Sample Output 3
10080
Sample Input 4
13
4 6 8 9 10 12 14 15 16 18 20 21 22
Sample Output 4
311014372
Remember to print the answer modulo
10^9+7
.
This case is not included in the test set for the partial score.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce

sys.setrecursionlimit(2147483647)
INF = 10 ** 13
def LI(): return list(map(int, sys.stdin.readline().split()))
def I(): return int(sys.stdin.readline())
def LS(): return sys.stdin.readline().rstrip().split()
def S(): return sys.stdin.readline().rstrip()
def IR(n): return [I() for i in range(n)]
def LIR(n): return [LI() for i in range(n)]
def SR(n): return [S() for i in range(n)]
def LSR(n): return [LS() for i in range(n)]
def SRL(n): return [list(S()) for i in range(n)]
def MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]
mod = 10 ** 9 + 7

n = I()
X = LI()
D = [0] * n
r = X[0]
ans = 1
for i in range(1, n):
    if r:
        D[i] = D[i - 1] + 1
        r -= 1
    else:
        D[i] = D[i - 1]
        r += 1
    r += X[i] - X[i - 1] - 1

ans = 1
for i in range(n):
    ans = ans * (D[i] + 1) % mod

print(ans)
```