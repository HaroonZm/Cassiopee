Voici un énoncé de problème :

Score :
600
points
Problem Statement
There is a game that involves three variables, denoted
A
,
B
, and
C
.
As the game progresses, there will be
N
events where you are asked to make a choice.
Each of these choices is represented by a string
s_i
. If
s_i
is
AB
, you must add
1
to
A
or
B
then subtract
1
from the other; if
s_i
is
AC
, you must add
1
to
A
or
C
then subtract
1
from the other; if
s_i
is
BC
, you must add
1
to
B
or
C
then subtract
1
from the other.
After each choice, none of
A
,
B
, and
C
should be negative.
Determine whether it is possible to make
N
choices under this condition. If it is possible, also give one such way to make the choices.
Constraints
1 \leq N \leq 10^5
0 \leq A,B,C \leq 10^9
N, A, B, C
are integers.
s_i
is
AB
,
AC
, or
BC
.
Input
Input is given from Standard Input in the following format:
N
A
B
C
s_1
s_2
:
s_N
Output
If it is possible to make
N
choices under the condition, print
Yes
; otherwise, print
No
.
Also, in the former case, show one such way to make the choices in the subsequent
N
lines. The
(i+1)
-th line should contain the name of the variable (
A
,
B
, or
C
) to which you add
1
in the
i
-th choice.
Sample Input 1
2 1 3 0
AB
AC
Sample Output 1
Yes
A
C
You can successfully make two choices, as follows:
In the first choice, add
1
to
A
and subtract
1
from
B
.
A
becomes
2
, and
B
becomes
2
.
In the second choice, add
1
to
C
and subtract
1
from
A
.
C
becomes
1
, and
A
becomes
1
.
Sample Input 2
3 1 0 0
AB
BC
AB
Sample Output 2
No
Sample Input 3
1 0 9 0
AC
Sample Output 3
No
Sample Input 4
8 6 9 1
AC
BC
AB
BC
AC
BC
AB
AB
Sample Output 4
Yes
C
B
B
C
C
B
A
A


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python

import sys
sys.setrecursionlimit(10**7)
from pprint import pprint as pp
from pprint import pformat as pf

import math
#from sortedcontainers import SortedList, SortedDict, SortedSet # no in atcoder
import bisect

class Player():

    A = 0
    B = 1
    C = 2

    def __init__(self, data, op_list):
        self.data = data
        self.op_list = op_list
        self.move_history = ["X"] * len(self.op_list)
        self.key = 0
        self.ans = "Yes" # "Yes" or "No"
        self.flg_out = False
        self.flg_foresight = False
        s = sum(data)
        if s == 2:
            self.flg_foresight = True
        elif s == 0:
            self.ans = "No"
            self.flg_out = True

    def has_next_op(self):
        if self.key + 1 < len(self.op_list):
            return True
        else:
            return False

    def play(self):
        for key, op in enumerate(op_list):
            #print('self.data') 
            if self.flg_out:
                break
            self.key = key
            self.read_op(op)

    def read_op(self, op):
        if op == "AB":
            self.do(self.A, self.B)
        if op == "AC":
            self.do(self.A, self.C)
        if op == "BC":
            self.do(self.B, self.C)

    def do(self, x, y):
        if self.data[x] < self.data[y]:
            self.move(y, x)
        elif self.data[x] > self.data[y]:
            self.move(x, y)
        else: # same
            if self.flg_foresight:
                if self.is_next_used(x):
                    self.move(y, x)
                else:
                    self.move(x, y)
            else:
                self.move(x, y) # which is ok

    def move(self, frm, to):
        self.move_history[self.key] = self.num_to_char(to)
        self.data[frm] -= 1
        self.data[to] += 1
        if self.data[frm] < 0:
            self.ans = "No"
            self.flg_out = True

    @staticmethod
    def num_to_char(z):
        chars = ['A', 'B', 'C']
        return chars[z]

    def is_next_used(self, z):
        if not self.has_next_op():
            return False
        next_op = self.op_list[self.key + 1]
        if self.num_to_char(z) in next_op:
            return True
        else:
            return False

    def print_ans(self):
        print(self.ans)
        if self.ans == "No":
            return
        for h in self.move_history:
            print(h)

if __name__ == '__main__':
    n, a, b, c = list(map(int, input().split()))
    data = [a, b, c]
    #print('data') 
    op_list = [""] * n
    for i in range(n):
        op_list[i] = input()
    #print('op_list') 

    p = Player(data, op_list)
    p.play()
    p.print_ans()

    #print('\33[32m' + 'end' + '\033[0m')
```