Voici un énoncé de problème :

Score :
1200
points
Problem Statement
We have
N
lamps numbered
1
to
N
, and
N
buttons numbered
1
to
N
.
Initially, Lamp
1, 2, \cdots, A
are on, and the other lamps are off.
Snuke and Ringo will play the following game.
First, Ringo generates a permutation
(p_1,p_2,\cdots,p_N)
of
(1,2,\cdots,N)
.
The permutation is chosen from all
N!
possible permutations with equal probability, without being informed to Snuke.
Then, Snuke does the following operation any number of times he likes:
Choose a lamp that is on at the moment. (The operation cannot be done if there is no such lamp.)
Let Lamp
i
be the chosen lamp.
Press Button
i
, which switches the state of Lamp
p_i
. That is, Lamp
p_i
will be turned off if it is on, and vice versa.
At every moment, Snuke knows which lamps are on.
Snuke wins if all the lamps are on, and he will surrender when it turns out that he cannot win.
What is the probability of winning when Snuke plays optimally?
Let
w
be the probability of winning. Then,
w \times N!
will be an integer.
Compute
w \times N!
modulo
(10^9+7)
.
Constraints
2 \leq N \leq 10^7
1 \leq A \leq \min(N-1,5000)
Input
Input is given from Standard Input in the following format:
N
A
Output
Print
w \times N!
modulo
(10^9+7)
, where
w
is the probability of Snuke's winning.
Sample Input 1
3 1
Sample Output 1
2
First, Snuke will press Button
1
.
If Lamp
1
turns off, he loses.
Otherwise, he will press the button that he can now press.
If the remaining lamp turns on, he wins; if Lamp
1
turns off, he loses.
The probability of winning in this game is
1/3
, so we should print
(1/3)\times 3!=2
.
Sample Input 2
3 2
Sample Output 2
3
Sample Input 3
8 4
Sample Output 3
16776
Sample Input 4
9999999 4999
Sample Output 4
90395416


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from numba import njit
import numpy as np

@njit('i8(i8, i8, i8)', cache=True)
def mod_pow(x, a, MOD):
    # Numbaではmod付き累乗が使えなかった...
    ret = 1
    cur = x
    while a:
        if a & 1:
            ret = ret * cur % MOD
        cur = cur * cur % MOD
        a >>= 1
    return ret

@njit('UniTuple(i8[:], 2)(i8, i8)', cache=True)
def prepare(n, MOD):
    factorials = np.ones(n + 1, dtype=np.int64)
    for i in range(2, n + 1):
        factorials[i] = factorials[i - 1] * i % MOD
    finvs = np.ones(n + 1, dtype=np.int64)
    finvs[n] = mod_pow(factorials[n], MOD - 2, MOD)
    for i in range(n, 1, -1):
        finvs[i - 1] = finvs[i] * i % MOD
    return factorials, finvs

@njit('i8(i8, i8)', cache=True)
def solve(n, a):
    MOD = 10 ** 9 + 7
    facts, finvs = prepare(n, MOD)
    invs = [facts[i - 1] * finvs[i] % MOD for i in range(n + 1)]  # invs[0]: undefined
    r = n - a

    ans = 0
    # a個がいずれも自己ループを持たないパターン
    for l in range(a):
        tmp1 = facts[a] * finvs[l] % MOD * finvs[a - l] % MOD
        tmp2 = facts[n - l - 1] * (a - l) % MOD
        ans = (ans + (-1) ** (l & 1) * tmp1 * tmp2) % MOD

    # a個中k+1個目ではじめて自己ループを持つが、それまでのk個で全点灯できるパターン
    for k in range(1, a):
        for l in range(k):
            tmp1 = facts[k] * finvs[l] % MOD * finvs[k - l] % MOD
            tmp2 = facts[n - l - 1] * (k - l) % MOD * invs[r + k - l] % MOD
            ans = (ans + (-1) ** (l & 1) * tmp1 * tmp2) % MOD

    return ans

n, a = map(int, input().split())
print(solve(n, a))
```