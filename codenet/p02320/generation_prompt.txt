Voici un énoncé de problème :

Knapsack Problem with Limitations
You have
N
items that you want to put them into a knapsack. Item
i
has value
v
i
, weight
w
i
and limitation
m
i
.
You want to find a subset of items to put such that:
The total value of the items is as large as possible.
The items have combined weight at most
W
, that is capacity of the knapsack.
You can select at most
m
i
items for
i
th item.
Find the maximum total value of items in the knapsack.
Input
N
W
v
1
w
1
m
1
v
2
w
2
m
2
:
v
N
w
N
m
N
The first line consists of the integers
N
and
W
. In the following
N
lines, the value, weight and limitation of the
i
-th item are given.
Output
Print the maximum total values of the items in a line.
Constraints
1 ≤
N
≤ 100
1 ≤
v
i
≤ 1,000
1 ≤
w
i
≤ 1,000
1 ≤
m
i
≤ 10,000
1 ≤
W
≤ 10,000
Sample Input 1
4 8
4 3 2
2 1 1
1 2 4
3 2 2
Sample Output 1
12
Sample Input 2
2 100
1 1 100
2 1 50
Sample Output 2
150


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!python3

iim = lambda: map(int, input().rstrip().split())

def resolve():
    N, W = iim()
    S = [list(iim()) for i in range(N)]

    dp = [0] * (W + 1)

    def f1(s):
        v, w, m = s
        mm = []
        i = 1
        while i <= m:
            mm.append(i)
            m -= i
            i <<= 1

        if m:
            mm.append(m)
        return (v, w, mm)

    SS = map(f1, S)

    for v, w, m in SS:
        for k in m:
            v1, w1 = v * k, w * k
            for i in range(W, w1-1, -1):
                j = i - w1
                v2 = dp[j] + v1
                if dp[i] < v2:
                    dp[i] = v2
    print(dp[W])

if __name__ == "__main__":
    resolve()
```