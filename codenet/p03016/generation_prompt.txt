Voici un énoncé de problème :

Score :
600
points
Problem Statement
There is an arithmetic progression with
L
terms:
s_0, s_1, s_2, ... , s_{L-1}
.
The initial term is
A
, and the common difference is
B
. That is,
s_i = A + B \times i
holds.
Consider the integer obtained by concatenating the terms written in base ten without leading zeros. For example, the sequence
3, 7, 11, 15, 19
would be concatenated into
37111519
. What is the remainder when that integer is divided by
M
?
Constraints
All values in input are integers.
1 \leq L, A, B < 10^{18}
2 \leq M \leq 10^9
All terms in the arithmetic progression are less than
10^{18}
.
Input
Input is given from Standard Input in the following format:
L
A
B
M
Output
Print the remainder when the integer obtained by concatenating the terms is divided by
M
.
Sample Input 1
5 3 4 10007
Sample Output 1
5563
Our arithmetic progression is
3, 7, 11, 15, 19
, so the answer is
37111519
mod
10007
, that is,
5563
.
Sample Input 2
4 8 1 1000000
Sample Output 2
891011
Sample Input 3
107 10000000000007 1000000000000007 998244353
Sample Output 3
39122908


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
L, A, B, M = map(int, input().split())

def mat_pow(x, n) :
    y = [[0] * 3 for _ in range(3)]
        
    for i in range(3) :
        y[i][i] = 1
        
    while n > 0 :
        if n & 1 :
            y = mat_mul(x, y)
        x = mat_mul(x, x)
        n >>= 1
        
    return y
    
def mat_mul(a, b) :
    I, J, K = len(a), len(b[0]), len(b)
    c = [[0] * J for _ in range(I)]
    for i in range(I) :
        for j in range(J) :
            for k in range(K) :
                c[i][j] += a[i][k] * b[k][j]
            c[i][j] %= M
    return c

n0 = -(-(10 ** 0 - A) // B)
n1 = -(-(10 ** 1 - A) // B)

ret = [[0], [A], [1]]

for d in range(1, 19) :
    mat = [[10**d, 1, 0], [0, 1, B], [0, 0, 1]]
    if n0 < 0 and 0 < n1 :
        n0 = 0
        
    if 0 <= n0 < n1 :
        ret = mat_mul(mat_pow(mat, n1 - n0), ret)
    n0, n1 = n1, min(-(-(10 ** (d + 1) - A) // B), L)

print(ret[0][0])
```