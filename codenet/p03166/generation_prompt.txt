Voici un énoncé de problème :

Score :
100
points
Problem Statement
There is a directed graph
G
with
N
vertices and
M
edges.
The vertices are numbered
1, 2, \ldots, N
, and for each
i
(
1 \leq i \leq M
), the
i
-th directed edge goes from Vertex
x_i
to
y_i
.
G
does not contain directed cycles
.
Find the length of the longest directed path in
G
.
Here, the length of a directed path is the number of edges in it.
Constraints
All values in input are integers.
2 \leq N \leq 10^5
1 \leq M \leq 10^5
1 \leq x_i, y_i \leq N
All pairs
(x_i, y_i)
are distinct.
G
does not contain directed cycles
.
Input
Input is given from Standard Input in the following format:
N
M
x_1
y_1
x_2
y_2
:
x_M
y_M
Output
Print the length of the longest directed path in
G
.
Sample Input 1
4 5
1 2
1 3
3 2
2 4
3 4
Sample Output 1
3
The red directed path in the following figure is the longest:
Sample Input 2
6 3
2 3
4 5
5 6
Sample Output 2
2
The red directed path in the following figure is the longest:
Sample Input 3
5 8
5 3
2 3
2 4
5 2
5 1
1 4
4 3
1 3
Sample Output 3
3
The red directed path in the following figure is one of the longest:


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import numpy as np
import sys
sys.setrecursionlimit(100000)
N,M=map(int,input().split())
d=[[] for i in range(N)]
for i in range(M):
    x,y=map(int,input().split())
    d[x-1].append(y-1)
dp=[0 for i in range(N)]

def depth(now,score,d):
    global dp
    if dp[now]==0 or not(dp[now]):
        if d[now]:
            _score=[]
            for i in d[now]:
                _score.append(depth(i,score+1,d)-score)
            dp[now]=max(_score)
        else:
            return score

        return dp[now]+score

    else:
        return dp[now]+score

Max=0
for i in range(N):
    m=depth(i,0,d)
    if  m>Max:            
        Max=m
print(Max)
```