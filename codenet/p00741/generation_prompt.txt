Voici un énoncé de problème :

Problem B:
How Many Islands?
You are given a marine area map that is a mesh of squares, each
representing either a land or sea area.
Figure B-1 is an example of a map.
Figure B-1: A marine area map
You can walk from a square land area to another if they are horizontally,
vertically, or diagonally adjacent to each other on the map.
Two areas are on the same island if and only if you can
walk from one to the other possibly through other land areas.
The marine area on the map is surrounded by the sea and therefore you
cannot go outside of the area on foot.
You are requested to write a program that reads the map and counts the
number of islands on it.
For instance, the map in Figure B-1 includes three islands.
Input
The input consists of a series of datasets, each being in the following format.
w h
c
1,1
c
1,2
...
c
1,
w
c
2,1
c
2,2
...
c
2,
w
...
c
h
,1
c
h
,2
...
c
h
,
w
w
and
h
are positive integers no more than 50 that
represent the width and the height of the given map, respectively.
In other words, the map consists of
w
×
h
squares of the same size.
w
and
h
are separated by a single space.
c
i
,
j
is either 0 or 1 and delimited by a single space.
If
c
i
,
j
= 0, the square that is the
i
-th from
the left and
j
-th from the top on the map represents a sea
area.
Otherwise, that is, if c
i
,
j
= 1, it represents a land area.
The end of the input is indicated by a line containing two zeros
separated by a single space.
Output
For each dataset, output the number of the islands in a line.
No extra characters should occur in the output.
Sample Input
1 1
0
2 2
0 1
1 0
3 2
1 1 1
1 1 1
5 4
1 0 1 0 0
1 0 0 0 0
1 0 1 0 1
1 0 0 1 0
5 4
1 1 1 0 1
1 0 1 0 1
1 0 1 0 1
1 0 1 1 1
5 5
1 0 1 0 1
0 0 0 0 0
1 0 1 0 1
0 0 0 0 0
1 0 1 0 1
0 0
Output for the Sample Input
0
1
1
3
1
9


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#template
def inputlist(): return [int(j) for j in input().split()]
#template
dx = [1,1,0,-1,-1,-1,0,1]
dy = [0,1,1,1,0,-1,-1,-1]
from collections import deque
def dfs(x,y,w,h,lis,flag):
    if lis[x][y] == 1:
        flag = 1
        lis[x][y] = 0
        stack = deque([])
        l = [x,y]
        stack.appendleft(l)
        while len(stack) != 0:
            li = stack.popleft()
            xa = li[0]
            ya = li[1]
            for i in range(8):
                nx = xa + dx[i]
                ny = ya + dy[i]
                if nx < 0 or ny < 0 or nx > h-1 or ny > w-1:
                    continue
                if lis[nx][ny] == 0:
                    continue
                stack.appendleft([nx,ny])
                lis[nx][ny] = 0
    if flag:
        return 1
    else:
        return 0

while True:
    w,h = inputlist()
    if w == 0 and h == 0:
        break
    maze = [[0] for _ in range(h)]
    for i in range(h):
        maze[i] = inputlist()
    ans = 0
    for x in range(h):
        for y in range(w):
            ans += dfs(x,y,w,h,maze,0)
    print(ans)
```