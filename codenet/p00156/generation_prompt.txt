Voici un énoncé de problème :

城の堀
いま、忍者が城外から天守閣に忍び入ろうと計画を立てています。この忍者は地面を走ったり、堀の中を泳いだりすることは難なくできますが、堀から這い上がることはとても苦手なので、忍者は堀に入る回数をできるだけ少なくしたいと考えています。
お城の見取図を入力とし、城外から天守閣に至るまでに、堀から這い上がらなくてはならない最小回数を出力するプログラムを作成して下さい。お城の見取図は二次元格子として与えられます。見取り図に描かれた記号には、天守閣の位置を示す「&」と堀の位置を示す「#」の位置が記され、そのほかの地点には「.」（半角ピリオド）が記されています。なお、お城には天守閣は一つだけあるものとし、忍者は走ったり泳いだりして移動するときに東西南北方向に1マスずつ移動するものとし、斜めには移動しません。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロ２つの行で示されます。各データセットは以下の形式で与えられます。
n
m
c
1,1
c
1,2
...
c
1,n
c
2,1
c
2,2
...
c
2,n
:
c
m,1
c
m,2
...
c
m,n
１行目に見取図の東西の幅
n
と 南北の幅
m
(1 ≤
n
,
m
≤ 100) が与えられる。続く
m
行に見取り図の
i
行目の情報が与えられる。各情報は記号「&」、「#」、「.」からなる長さ
n
の文字列である。
データセットの数は 50 を越えない。
Output
データセットごとに堀から這い上がらなくてはならない最小回数（整数）を１行に出力します。
Sample Input
5 5
.###.
#...#
#.&.#
#...#
.###.
18 15
..####....####....
####..####....####
#...............##
.#.############.##
#..#..........#.##
.#.#.########.#.##
#..#.#......#.#.##
.#.#....&...#.#.##
#..#........#.#.##
.#.#.########.#.##
#..#..........#.##
.#.############.##
#...............##
.#################
##################
9 10
#########
........#
#######.#
#.....#.#
#.###.#.#
#.#&#.#.#
#.#...#.#
#.#####.#
#.......#
#########
9 3
###...###
#.#.&.#.#
###...###
0 0
</pre>
<H2>Output for the Sample Input</H2>
<pre>
1
2
0
0
</pre>


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop, heapify
from itertools import product

def solve():
    hq = [(0, y, x) for y, x in product(xrange(m), xrange(n)) 
          if not(0 < y < m - 1 and 0 < x < n - 1)]
    heapify(hq)
    while len(hq) != 0:
        cost, cy, cx = heappop(hq)
        if field[cy][cx] == "&":
            return cost
        if memo[cy][cx] <= cost:
            continue
        memo[cy][cx] = cost
        for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
            ny, nx = cy + dy, cx + dx
            if 0 <= ny < m and 0 <= nx < n:
                if field[ny][nx] != "#" and field[cy][cx] == "#": 
                    heappush(hq, (cost + 1, ny, nx))
                else:
                    heappush(hq, (cost, ny, nx))

while True:
    n, m = map(int, raw_input().split())
    if n | m == 0:
        break
    memo = [[1 << 20] * n for _ in xrange(m)]
    field = [raw_input() for _ in xrange(m)]    
    print solve()
```