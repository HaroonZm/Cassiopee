Voici un énoncé de problème :

Score :
900
points
Problem Statement
In "Takahashi-ya", a ramen restaurant, basically they have one menu: "ramen", but
N
kinds of toppings are also offered. When a customer orders a bowl of ramen, for each kind of topping, he/she can choose whether to put it on top of his/her ramen or not. There is no limit on the number of toppings, and it is allowed to have all kinds of toppings or no topping at all. That is, considering the combination of the toppings,
2^N
types of ramen can be ordered.
Akaki entered Takahashi-ya. She is thinking of ordering some bowls of ramen that satisfy both of the following two conditions:
Do not order multiple bowls of ramen with the exactly same set of toppings.
Each of the
N
kinds of toppings is on two or more bowls of ramen ordered.
You are given
N
and a prime number
M
. Find the number of the sets of bowls of ramen that satisfy these conditions, disregarding order, modulo
M
. Since she is in extreme hunger, ordering any number of bowls of ramen is fine.
Constraints
2 \leq N \leq 3000
10^8 \leq M \leq 10^9 + 9
N
is an integer.
M
is a prime number.
Subscores
600
points will be awarded for passing the test set satisfying
N ≤ 50
.
Input
Input is given from Standard Input in the following format:
N
M
Output
Print the number of the sets of bowls of ramen that satisfy the conditions, disregarding order, modulo
M
.
Sample Input 1
2 1000000007
Sample Output 1
2
Let the two kinds of toppings be A and B. Four types of ramen can be ordered: "no toppings", "with A", "with B" and "with A, B". There are two sets of ramen that satisfy the conditions:
The following three ramen: "with A", "with B", "with A, B".
Four ramen, one for each type.
Sample Input 2
3 1000000009
Sample Output 2
118
Let the three kinds of toppings be A, B and C. In addition to the four types of ramen above, four more types of ramen can be ordered, where C is added to the above four. There are
118
sets of ramen that satisfy the conditions, and here are some of them:
The following three ramen: "with A, B", "with A, C", "with B, C".
The following five ramen: "no toppings", "with A", "with A, B", "with B, C", "with A, B, C".
Eight ramen, one for each type.
Note that the set of the following three does not satisfy the condition: "'with A', 'with B', 'with A, B'", because C is not on any of them.
Sample Input 3
50 111111113
Sample Output 3
1456748
Remember to print the number of the sets modulo
M
. Note that these three sample inputs above are included in the test set for the partial score.
Sample Input 4
3000 123456791
Sample Output 4
16369789
This sample input is not included in the test set for the partial score.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n, m = map(int, input().split())
MOD = m
list_size = n+2

f_list = [1] * list_size
f_r_list = [1] * list_size

for i in range(list_size - 1):
	f_list[i + 1] = int((f_list[i] * (i + 1)) % MOD)

f_r_list = [pow(x, MOD-2, MOD) for x in f_list]

def comb(N, r):
	if N < r or r < 0:
		return 0
	else:
		return (((f_list[N] * f_r_list[N - r]) % MOD) * f_r_list[r]) % MOD 

st = [[0 for _ in range(n+1)] for _ in range(n+1)]
st[0][0] = 1
for i in range(1, n+1):
	st[i][0] = 1
	for j in range(1, i+1):
		st[i][j] = (st[i-1][j-1] + (j+1) * st[i-1][j]) % MOD

ans = 0
for i in range(n+1):
	res = (comb(n, i) * pow(2, pow(2, n-i, MOD-1), MOD)) % MOD
	tmp = 0
	for j in range(i+1):
		tmp += st[i][j] * pow(2, (n-i) * j, MOD)
		tmp %= MOD
	res *= tmp
	res %= MOD

	if i%2 == 0:
		ans += res
	else:
		ans -= res
	ans %= MOD

print(ans)
```