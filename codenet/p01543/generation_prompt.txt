Voici un énoncé de problème :

まるかいて
太郎君は小学生で、チラシの裏に落書きをしています。
ある時、太郎君は次のゲームを思いつきました。
n×n
の格子状のマス目を書いておきます。
それぞれのマス目の初期状態は、丸印が書かれているか、書かれていないかのどちらか一方です。
これらの丸印を消したり書いたりして最終的にどの一列を見ても必ずちょうど1つのみの丸印が、どの一行を見ても必ず1つのみの丸印が存在するようにすることが目標であり、この状態にすればゲームをクリアしたことになります。
太郎君はこのゲームを思いつきましたが、太郎君はこのゲームをクリアするのに大変時間がかかってしまいます。そこで、大学生であるあなたに助けを求めました。
太郎君の兄であり大学生であるあなたの仕事は以下の通りです。
厳密な状況を考えるために、あるマス目に丸印を書き込むコスト、あるマス目にある丸印を消すコストをあなたは導き出しました。このコストを用いてこのゲームをクリアするためにかかる操作のコストを最小化するような手順を考える。
このとき、最小のコストおよびそのコストを達成するような手順を出力するプログラムを書いてください。
出力については、最小コストを達成する手順なら、どのような操作、順番でも出力してもよいものとする。
Input
n
W
11
W
12
..
W
1n
W
21
W
22
..
W
2n
..
W
n1
W
n2
..
W
nn
E
11
E
12
..
E
1n
E
21
E
22
..
E
2n
..
E
n1
E
n2
..
E
nn
F
1
(
n
文字)
F
2
(
n
文字)
..
F
n
(
n
文字)
n
は太郎君の作ったマス目が一辺にいくつあるかを表す
W
ij
は上から
i
番目、左から
j
番目のマス目に丸印を書き込むコストを表す
E
ij
は上から
i
番目、左から
j
番目のマス目に書かれてある丸印を消すコストを表す
F
i
は上から
i
番目の行のマス目の初期状態を表す
F
i
の左から
j
文字目について
'o'のとき、上から
i
番目、左から
j
番目のマス目に丸印が書かれてあることを表す。
'.'のとき、上から
i
番目、左から
j
番目のマス目が空白であることを表す。
Constraints
1≤ n ≤ 100
1≤ W
ij
≤ 1000
1≤ E
ij
≤ 1000
F
i
は文字列であり、その長さは
n
である
F
i
は'o'と'.'のみで構成されている
Output
mincost
cnt
R
1
C
1
operate
1
R
2
C
2
operate
2
..
R
cnt
C
cnt
operate
cnt
mincost
は、太郎君のゲームをクリアするために必要な最小コストを表す。
mincost
は書き込み操作、消去操作で発生するコストの総和で計算される。
cnt
:
mincost
のコストを達成する操作を行った回数を表す
k
回目
(1≤k≤cnt)
に実行する操作は
k+2
行目に記述する
k
回目
(1≤k≤cnt)
の操作に対して
上から
i
番目のマス目、左から
j
番目のマス目に対して行ったものとすると
R
k
k
である。
この操作が丸印を消す操作であるならば
operate
k
= "erase"とせよ
この操作が丸印を書き込む操作であるならば
operate
k
= "write"とせよ
R
k
,C
k
,operate
k
は一行に空白区切りで出力しなければならない
丸印の書かれてあるマス目に対して丸印を記述する操作、および丸印が書かれていないマス目に対して丸印を消去する操作をした場合はWrongAnswerである
cnt
個の操作にかかるコストの総和が
mincost
に一致しないときはWrongAnswerである
Sample Input 1
3
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
o.o
...
.o.
Output for the Sample Input 1
2
2
1 3 erase
2 3 write
上から1番目、左から3番目のマス目の丸印を消去し、
上から2番目、左から3番目のマス目に丸印を書き加えれば目標は達成できる。
このときコストは2のみしかかからず、これが最小のコストである。
Sample Input 2
4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
oooo
oooo
oooo
oooo
Output for the Sample Input 2
30
12
1 1 erase
1 2 erase
1 3 erase
2 1 erase
2 2 erase
2 4 erase
3 1 erase
3 3 erase
3 4 erase
4 2 erase
4 3 erase
4 4 erase
コスト(1+2+3+4)*3だけ消去処理をすればクリアとなります。
Sample Input 3
3
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
o..
.o.
..o
Output for the Sample Input 3
0
0
すでに目標は達成されているため、コスト及び操作回数はともに0となる。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        G = self.G
        G[fr].append([to, cap, cost, len(G[to])])
        G[to].append([fr, 0, -cost, len(G[fr])-1])

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [0]*N

        while f:
            dist = [INF]*N
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                for i, (w, cap, cost, _) in enumerate(G[v]):
                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:
                        dist[w] = r = dist[v] + cost + H[v] - H[w]
                        prv_v[w] = v; prv_e[w] = i
                        heappush(que, (r, w))
            if dist[t] == INF:
                return -1

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, G[prv_v[v]][prv_e[v]][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = G[prv_v[v]][prv_e[v]]
                e[1] -= d
                G[v][e[3]][1] += d
                v = prv_v[v]
        return res

def solve():
    readline = sys.stdin.readline
    write = sys.stdout.write

    N = int(readline())
    W = [list(map(int, readline().split())) for i in range(N)]
    E = [list(map(int, readline().split())) for i in range(N)]
    F = [readline() for i in range(N)]
    mcf = MinCostFlow(2*N+2)
    for i in range(N):
        Wi = W[i]; Ei = E[i]; Fi = F[i]
        s0 = sum(Ei[j] for j in range(N) if Fi[j] == "o")
        for j in range(N):
            s = (s0 - Ei[j] if Fi[j] == "o" else s0 + Wi[j])
            mcf.add_edge(i, N+j, 1, s)
        mcf.add_edge(2*N, i, 1, 0)
        mcf.add_edge(N+i, 2*N+1, 1, 0)
    res = mcf.flow(2*N, 2*N+1, N)
    write("%d\n" % res)
    ans = []
    for i in range(N):
        Gi = mcf.G[i]
        Wi = W[i]; Ei = E[i]; Fi = F[i]
        for j in range(N):
            if Gi[j][1] == 0:
                for k in range(N):
                    if j == k or Fi[k] == ".":
                        continue
                    ans.append("%d %d erase" % (i+1, k+1))
                if Fi[j] == ".":
                    ans.append("%d %d write" % (i+1, j+1))
                break
    write("%d\n" % len(ans))
    if ans:
        write("\n".join(ans))
        write("\n")
solve()
```