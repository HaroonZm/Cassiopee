Voici un énoncé de problème :

Score :
300
points
Problem Statement
There are
N
squares arranged in a row from left to right.
The height of the
i
-th square from the left is
H_i
.
You will land on a square of your choice, then repeat moving to the adjacent square
on the right
as long as the height of the next square is not greater than that of the current square.
Find the maximum number of times you can move.
Constraints
All values in input are integers.
1 \leq N \leq 10^5
1 \leq H_i \leq 10^9
Input
Input is given from Standard Input in the following format:
N
H_1
H_2
...
H_N
Output
Print the maximum number of times you can move.
Sample Input 1
5
10 4 8 7 3
Sample Output 1
2
By landing on the third square from the left, you can move to the right twice.
Sample Input 2
7
4 4 5 6 6 5 5
Sample Output 2
3
By landing on the fourth square from the left, you can move to the right three times.
Sample Input 3
4
1 2 3 4
Sample Output 3
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
#sys.setrecursionlimit(n)
import heapq
import re
import bisect
import random
import math
import itertools
from collections import defaultdict, deque
from copy import deepcopy
from decimal import *

readl= lambda: list(map(int, sys.stdin.readline().split()))
readt= lambda: tuple(map(int, sys.stdin.readline().split()))
read = lambda: sys.stdin.readline().rstrip()
readi = lambda: int(read())
readmi = lambda: map(int, sys.stdin.readline().split())
readms = lambda: map(str, sys.stdin.readline().split())

n = readi()
t = readl()

left = 0
right = 1
mx = 0
current = 0
if n == 1:
    print(0)
    exit()
while(1):
    if t[left] >= t[right]:
        current += 1
        mx = max(current, mx)
    else:
        current = 0
    left += 1
    right += 1
    if left >= n or right >= n:
        break
print(mx)
```