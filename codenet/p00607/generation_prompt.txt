Voici un énoncé de problème :

Problem C:
Emacs-like Editor
Emacs is a text editor which is widely used by many programmers.
The advantage of Emacs is that we can move a cursor without arrow keys and the mice. For example, the cursor can be moved right, left, down, and up by pushing
f
,
b
,
n
,
p
with the Control Key respectively. In addition, cut-and-paste can be performed without the mouse.
Your task is to write a program which simulates key operations in the Emacs-like editor. The program should read a text and print the corresponding edited text.
The text consists of several lines and each line consists of zero or more alphabets and space characters. A line, which does not have any character, is a blank line.
The editor has a cursor which can point out a character or the end-of-line in the corresponding line. The cursor can also point out the end-of-line in a blank line.
In addition, the editor has a buffer which can hold either a string (a sequence of characters) or a linefeed.
The editor accepts the following set of commands (If the corresponding line is a blank line, the word "the first character" should be "the end-of-line"):
a
Move the cursor to the first character of the current line.
e
Move the cursor to the end-of-line of the current line.
p
Move the cursor to the first character of the next upper line, if it exists.
If there is no line above the current line, move the cursor to the first character of the current line.
n
Move the cursor to the first character of the next lower line, if it exists.
If there is no line below the current line, move the cursor to the first character of the current line.
f
Move the cursor by one character to the right, unless the cursor points out the end-of-line.
If the cursor points out the end-of-line and there is a line below the current line, move the cursor to the first character of the next lower line. Otherwise, do nothing.
b
Move the cursor by one character to the left, unless the cursor points out the first character.
If the cursor points out the first character and there is a line above the current line, move the cursor to the end-of-line of the next upper line. Otherwise, do nothing.
d
If the cursor points out a character, delete the character (Characters and end-of-line next to the deleted character are shifted to the left).
If the cursor points out the end-of-line and there is a line below, the next lower line is appended to the end-of-line of the current line (Lines below the current line are shifted to the upper).
Otherwise, do nothing.
k
If the cursor points out the end-of-line and there is a line below the current line, perform the command
d
mentioned above, and record a linefeed on the buffer.
If the cursor does not point out the end-of-line, cut characters between the cursor (inclusive) and the end-of-line, and record them on the buffer.
After this operation, the cursor indicates the end-of-line of the current line.
y
If the buffer is empty, do nothing.
If the buffer is holding a linefeed, insert the linefeed at the cursor. The cursor moves to the first character of the new line.
If the buffer is holding characters, insert the characters at the cursor. The cursor moves to the character or end-of-line which is originally pointed by the cursor.
The cursor position just after reading the text is the beginning of the first line, and the initial buffer is empty.
Input
The input consists of only one data-set which includes two parts. The first part gives a text consisting of several lines. The end of the text is indicated by a line (without quotes):
"END_OF_TEXT"
This line should not be included in the text.
Next part gives a series of commands. Each command is given in a line. The end of the commands is indicated by a character '
-
'.
Output
For the input text, print the text edited by the commands.
Constraints
The number of lines in the text given as input ≤ 10
The number of characters in a line given as input ≤ 20
The number of commands ≤ 300
The maximum possible number of lines in the text during operations ≤ 100
The maximum possible number of characters in a line during operations ≤ 1000
Sample Input
hyo
ni
END_OF_TEXT
f
d
f
f
k
p
p
e
y
a
k
y
y
n
y
-
Output for the Sample Input
honihoni
honi


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
class Editer:

    def __init__(self, text):
        # カーソルの位置
        self.row = 0 #行
        self.col = 0 #列
        # 編集中のテキスト
        self.text = [list(t) + ['\n'] for t in text]
        # バッファー
        self.buffer = []

    def row_head(self):
        return 0

    def row_tail(self):
        return len(self.text) - 1

    def col_head(self):
        return 0

    def col_tail(self):
        return len(self.text[self.row]) - 1

    def __repr__(self):
        return ''.join(''.join(t) for t in self.text)

    def command_a(self):
        # カーソルを現在の行の先頭文字に移動
        self.col = self.col_head()

    def command_e(self):
        # カーソルを現在の行の行末に移動
        self.col = self.col_tail()

    def command_p(self):
        # 上に行があれば、カーソルを上の行に
        if self.row != self.row_head() :
            self.row -= 1
        # カーソルを先頭に
        self.col = self.col_head()

    def command_n(self):
        # 下に行があれば
        if self.row != self.row_tail():
            # カーソルを下の行に移動
            self.row += 1
        # カーソルを先頭文字に移動
        self.col = self.col_head()

    def command_b(self):
        # カーソルが行末にない場合
        if self.col != self.col_head():
            # カーソルを１つ左に移動
            self.col -= 1
        # カーソルが行末にあり、上に行がある場合
        elif self.row != self.row_head():
            # カーソルを前の行の先頭に
            self.row -= 1
            self.col = self.col_tail()

    def command_f(self):
        # カーソルが行末にない場合
        if self.col != self.col_tail():
            # カーソルを１つ右に移動
            self.col += 1
        # カーソルが行末にあり、下に行がある場合
        elif self.row != self.row_tail():
            # カーソルを次の行の先頭に
            self.row += 1
            self.col = self.col_head()

    def command_d(self):
        # カーソルが行末にない場合
        if self.col != self.col_tail():
            # カーソルの文字を削除
            self.text[self.row].pop(self.col)
        # カーソルが行末を指し、下に行がある場合
        elif self.row != self.row_tail():
            # 下の行をそのままカーソルの位置に繋げ、以下の行は上にシフト
            self.text[self.row].pop(self.col_tail())
            self.text[self.row] += self.text.pop(self.row+1)

    def command_k(self):
        # カーソルが行末にない場合
        if self.col != self.col_tail():
            # カーソルが指す文字を含めた右側すべての文字を切り取りそれをバッファに記録する。
            self.buffer = self.text[self.row][self.col:-1]
            self.text[self.row] = self.text[self.row][:self.col] + ['\n']
            # カーソルは元の行の行末を指すようになる
            self.col = self.col_tail()
        # カーソルが行末にあり、下に行がある場合
        elif self.row != self.row_tail():
            # バッファに改行を記録する。
            self.buffer = ['\n']
            # 下の行をそのままカーソルの位置に繋げる。以下の行は上にシフトされる。
            self.text[self.row].pop(self.col_tail())
            self.text[self.row] += self.text.pop(self.row+1)

    def command_y(self):
        '''
        カーソルが指す文字の直前にバッファを挿入
        カーソルの位置はもともと指していた文字へ移動
        バッファの内容が改行なら
        '''
        if self.buffer != ['\n']:
            self.text[self.row][self.col:self.col] = self.buffer
            self.col += len(self.buffer)

        else:
            self.text.insert(self.row+1, self.text[self.row][self.col:])
            self.text[self.row] = self.text[self.row][:self.col] + ['\n']
            self.row += 1
            self.col = self.col_head()

def main():
    # input text
    text = []
    while True:
        str = input()
        if str == 'END_OF_TEXT': break
        text.append(str)

    editer = Editer(text)

    # input command
    while True:
        command = input()
        if   command == 'a' : editer.command_a()
        elif command == 'e' : editer.command_e()
        elif command == 'p' : editer.command_p()
        elif command == 'n' : editer.command_n()
        elif command == 'f' : editer.command_f()
        elif command == 'b' : editer.command_b()
        elif command == 'd' : editer.command_d()
        elif command == 'y' : editer.command_y()
        elif command == 'k' : editer.command_k()
        elif command == '-' : break

    print(editer, end='')

if __name__ == '__main__': main()
```