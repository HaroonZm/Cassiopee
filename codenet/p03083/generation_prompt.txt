Voici un énoncé de problème :

Score :
700
points
Problem Statement
Today, Snuke will eat
B
pieces of black chocolate and
W
pieces of white chocolate for an afternoon snack.
He will repeat the following procedure until there is no piece left:
Choose black or white with equal probability, and eat a piece of that color if it exists.
For each integer
i
from
1
to
B+W
(inclusive), find the probability that the color of the
i
-th piece to be eaten is black.
It can be shown that these probabilities are rational, and we ask you to print them modulo
10^9 + 7
, as described in Notes.
Notes
When you print a rational number, first write it as a fraction
\frac{y}{x}
, where
x, y
are integers and
x
is not divisible by
10^9 + 7
(under the constraints of the problem, such representation is always possible).
Then, you need to print the only integer
z
between
0
and
10^9 + 6
, inclusive, that satisfies
xz \equiv y \pmod{10^9 + 7}
.
Constraints
All values in input are integers.
1 \leq B,W \leq 10^{5}
Input
Input is given from Standard Input in the following format:
B
W
Output
Print the answers in
B+W
lines. In the
i
-th line, print the probability that the color of the
i
-th piece to be eaten is black, modulo
10^{9}+7
.
Sample Input 1
2 1
Sample Output 1
500000004
750000006
750000006
There are three possible orders in which Snuke eats the pieces:
white, black, black
black, white, black
black, black, white
with probabilities
\frac{1}{2}, \frac{1}{4}, \frac{1}{4}
, respectively. Thus, the probabilities of eating a black piece first, second and third are
\frac{1}{2},\frac{3}{4}
and
\frac{3}{4}
, respectively.
Sample Input 2
3 2
Sample Output 2
500000004
500000004
625000005
187500002
187500002
They are
\frac{1}{2},\frac{1}{2},\frac{5}{8},\frac{11}{16}
and
\frac{11}{16}
, respectively.
Sample Input 3
6 9
Sample Output 3
500000004
500000004
500000004
500000004
500000004
500000004
929687507
218750002
224609377
303710940
633300786
694091802
172485353
411682132
411682132


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# 入力
B, W = map(int, input().split())

# ModInt定義
MOD = 10**9 + 7

class ModInt:
    def __init__(self, x):
        self.x = x % MOD

    def __str__(self):
        return str(self.x)

    def __repr__(self):
        return str(self.x)

    def __add__(self, other):
        return (
            ModInt(self.x + other.x) if isinstance(other, ModInt) else
            ModInt(self.x + other)
        )

    def __sub__(self, other):
        return (
            ModInt(self.x - other.x) if isinstance(other, ModInt) else
            ModInt(self.x - other)
        )

    def __mul__(self, other):
        return (
            ModInt(self.x * other.x) if isinstance(other, ModInt) else
            ModInt(self.x * other)
        )

    def __truediv__(self, other):
        return (
            ModInt(
                self.x * pow(other.x, MOD - 2, MOD)
            ) if isinstance(other, ModInt) else
            ModInt(self.x * pow(other, MOD - 2, MOD))
        )

    def __pow__(self, other):
        return (
            ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else
            ModInt(pow(self.x, other, MOD))
        )

    __radd__ = __add__
    __rsub__ = __sub__
    __rmul__ = __mul__
    __rtruediv__ = __truediv__
    __rpow__ = __pow__

p = ModInt(0)
q = ModInt(0)
cp = ModInt(0)
cq = ModInt(0)
for i in range(1, B + W + 1):
    # i番目の解は i-1番目までに白チョコレートが枯渇している確率 +
    # i-1番目までにどちらのチョコレートも枯渇しない確率 / 2
    ans = (1 + q - p) / 2
    # 出力
    print(ans)
    cp = (
        ModInt(0) if i < B else
        ModInt(1) if i == B else
        cp * (i - 1) / (i - B)
    )
    p = (
        ModInt(0) if i < B else
        ModInt(1) / ModInt(2)**i if i == B else
        p + cp / ModInt(2)**i
    )
    cq = (
        ModInt(0) if i < W else
        ModInt(1) if i == W else
        cq * (i - 1) / (i - W)
    )
    q = (
        ModInt(0) if i < W else
        ModInt(1) / ModInt(2)**i if i == W else
        q + cq / ModInt(2)**i
    )
```