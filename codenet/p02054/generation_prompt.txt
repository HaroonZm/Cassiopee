Voici un énoncé de problème :

C: 串刺し (Skewering)
問題
ある日、ほむらちゃんが積み木で遊んでいるとてんぷら君がやってきました。
ほむらちゃんは、てんぷら君と一緒に積み木で遊ぶことにしました。
一辺の長さが
1
の立方体の積み木のブロックを
A \times B \times C
個隙間なく積み重ねてできた、
A \times B \times C
の直方体があります。全ての立方体と直方体の各辺は
x
軸、
y
軸、
z
軸のいずれかと平行です。
ほむらちゃんとてんぷら君は交互に以下の操作を繰り返します。
直方体から縦方向、横方向、奥行き方向のいずれかの方向に一列に並んだ積み木のブロックの列を選んで、列に含まれるブロック全てを赤く塗る。ただし、すでに赤く塗られているブロックを含む列は選ぶことができない。
より正確には、
直方体に含まれるブロックのうち一つと、
x,y,z
の三つの方向から一つを選ぶ。
選んだブロックを選んだ方向に整数の距離だけ動かしたとき、完全に重なるようなブロック全てを赤く塗る（
0
や負の整数の距離を動かすことも考える）。ただし、条件を満たすブロックであってすでに塗られたものがひとつでも存在する場合、この操作は行うことができない。
ほむらちゃんが先手で、先に操作を行えなくなった方の負けです。
また、最初全ての立方体に色は塗られていません。
二人が最適に行動したとき、どちらが勝つか判定してください。
入力形式
A
B
C
制約
1 \leq A, B, C \leq 100
入力はすべて整数である。
出力形式
二人が最適に行動したとき、ほむらちゃんが勝つならば
Hom
を、てんぷら君が勝つならば
Tem
を一行に出力する。
入力例 1
1 1 10
出力例 1
Hom
一回目でほむらちゃんは全てのブロックを赤く塗ることができます。
入力例 2
4 3 5
出力例 2
Hom
入力例 3
6 4 10
出力例 3
Tem


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
print("Hom" if sum([int(n)%2 for n in input().split()]) > 1 else "Tem")
```