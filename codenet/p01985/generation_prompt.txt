Voici un énoncé de problème :

分割統治
太郎さんと花子さんと次郎さんは3人で JAG 王国を統治している．JAG 王国には
N
個の街が存在し，いくつかの街は双方向の道路で繋がっている．どの街からも別のすべての街へ 1 本以上の道路を経由して必ず辿り着くことができる．
ある日太郎さんと花子さんはとうとう仲違いを起こしてしまい，3 人で街を分担して統治することに決めた．しかし，あまりにも仲が悪くなりすぎてしまったため，太郎さんが統治している街と花子さんが統治している街が 1 本の道路で直接繋がっていることすら嫌がっている．そこで，以下の条件を満たすように統治する街を分担することにした．
太郎さんが統治する街と花子さんが統治する街からなる任意のペアは，直接道路で繋がっていない．これは太郎さんと花子さんの仲がめちゃくちゃ悪いからである．
同じ人に統治されている街同士も直接道路で繋がっていない．これは，そんな中でも他者の統治下の経由を義務付けることで外交を促すためである．
太郎さんの統治する街の総数と花子さんが統治する街の総数は同じでなければならない．これは総数を等しくしないと太郎さんと花子さんの仲がさらにめちゃくちゃ悪くなりそうだからである．ここで，次郎さんはとても心が広いので，次郎さんが統治する街の総数はいくつでもよい．
以上の条件を満たすような分担であれば，3 人は納得して統治することができ，たとえ誰かの統治する街が 0 個であっても文句はない．このとき，太郎さんが統治する街の総数 (=花子さんが統治する街の総数) としてあり得る数をすべて列挙するプログラムを作成せよ．
Input
入力は複数のデータセットからなる．
データセットの数は最大で 50 である．
各データセットは，次の形式で表される．
N
M
u
1
v
1
...
u
M
v
M
1 行目は 2 つの整数
N
(
2 ≤ N ≤ 10
3
) と
M
(
1 ≤ M ≤ 10
3
) からなり，それぞれ街の数と道路の数を表す．続く
M
行のうち
i
行目は 2 つの整数
u
i
と
v
i
(
1 ≤ u
i
< v
i
≤ N
) からなり，
i
番目の道路が街
u
i
と 街
v
i
を双方向に繋いでいることを表す．ここで，どの街からも別のすべての街へ 1 本以上の道路を経由して必ず辿り着くことができることが保証される．また，同じ街のペアを結ぶ道路が複数与えられることはない．すなわち，すべての
1 ≤ i < j ≤ M
について
(u
i
, v
i
) ≠ (u
j
, v
j
)
を満たす．
入力の終わりは 2 つのゼロからなる行で表される．
Output
各データセットについて，太郎さんが統治する街の総数として考えられる数が
K
通りあるとき，まず 1 行目に
K
を出力し，その後，あり得る総数を 1 行に 1 つずつ昇順で出力せよ．
Sample Input
6 7
1 2
1 4
2 3
2 5
3 4
4 5
4 6
2 1
1 2
3 3
1 2
1 3
2 3
4 3
1 2
2 3
3 4
5 4
1 2
2 3
3 4
4 5
0 0
Output for the Sample Input
2
1
2
0
0
1
1
1
1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
input = sys.stdin.readline

def main():
    while True:
        N, M = map(int, input().split())
        if N == 0:
            break
        path = [[False] * N for i in range(N)]
        for i in range(M):
            u, v = map(int, input().split())
            u -= 1; v -= 1;
            path[u][v] = True
            path[v][u] = True

        d = [-1] * N
        d[0] = 0
        q = [0]
        while len(q) > 0:
            now = q.pop(0)
            for i in range(N):
                if path[now][i] and d[i] == -1:
                    q.append(i)
                    d[i] = d[now] + 1
        ok = True
        for i in range(1, N):
            for j in range(i+1, N):
                if path[i][j] and d[i] == d[j]:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            print(0)
        else:
            num = 0
            for i in range(N):
                if d[i]&1:
                    num += 1
            if N&1:
                print(1)
                if num&1:
                    print((N-num)//2)
                else:
                    print(num//2)
            else:
                if num&1:
                    print(0)
                else:
                    if N//2 == num:
                        print(1)
                        print(num//2)
                    else:
                        print(2)
                        tmp = min(num, N-num)
                        print(tmp//2)
                        print((N-tmp)//2)

if __name__ == "__main__":
    main()
```