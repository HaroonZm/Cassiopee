Voici un énoncé de problème :

Score :
800
points
Problem Statement
Takahashi and Aoki will play a game on a tree.
The tree has
N
vertices numbered
1
to
N
, and the
i
-th of the
N-1
edges connects Vertex
a_i
and Vertex
b_i
.
At the beginning of the game, each vertex contains a coin.
Starting from Takahashi, he and Aoki will alternately perform the following operation:
Choose a vertex
v
that contains one or more coins, and remove all the coins from
v
.
Then, move each coin remaining on the tree to the vertex that is nearest to
v
among the adjacent vertices of the coin's current vertex.
The player who becomes unable to play, loses the game.
That is, the player who takes his turn when there is no coin remaining on the tree, loses the game.
Determine the winner of the game when both players play optimally.
Constraints
1 \leq N \leq 2 \times 10^5
1 \leq a_i, b_i \leq N
a_i \neq b_i
The graph given as input is a tree.
Input
Input is given from Standard Input in the following format:
N
a_1
b_1
a_2
b_2
:
a_{N-1}
b_{N-1}
Output
Print
First
if Takahashi will win, and print
Second
if Aoki will win.
Sample Input 1
3
1 2
2 3
Sample Output 1
First
Here is one possible progress of the game:
Takahashi removes the coin from Vertex
1
. Now, Vertex
1
and Vertex
2
contain one coin each.
Aoki removes the coin from Vertex
2
. Now, Vertex
2
contains one coin.
Takahashi removes the coin from Vertex
2
. Now, there is no coin remaining on the tree.
Aoki takes his turn when there is no coin on the tree and loses.
Sample Input 2
6
1 2
2 3
2 4
4 6
5 6
Sample Output 2
Second
Sample Input 3
7
1 7
7 4
3 4
7 5
6 3
2 1
Sample Output 3
First


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
###############################################################################

from bisect import bisect_left as binl

def intin():
    input_tuple = input().split()
    if len(input_tuple) <= 1:
        return int(input_tuple[0])
    return tuple(map(int, input_tuple))

def intina():
    return [int(i) for i in input().split()]

def intinl(count):
    return [intin() for _ in range(count)]

def modadd(x, y):
    global mod
    return (x + y) % mod

def modmlt(x, y):
    global mod
    return (x * sy) % mod

def lcm(x, y):
    while y != 0:
        z = x % y
        x = y
        y = z
    return x

def make_linklist(xylist):
    linklist = {}
    for a, b in xylist:
        linklist.setdefault(a, [])
        linklist.setdefault(b, [])
        linklist[a].append(b)
        linklist[b].append(a)
    return linklist

def calc_longest_distance(linklist, v=1):
    distance_list = {}
    distance_count = 0
    distance = 0
    vlist_previous = []
    vlist = [v]
    nodecount = len(linklist)

    while distance_count < nodecount:
        vlist_next = []
        for v in vlist:
            distance_list[v] = distance
            distance_count += 1
            vlist_next.extend(linklist[v])
        distance += 1
        vlist_to_del = vlist_previous
        vlist_previous = vlist
        vlist = list(set(vlist_next) - set(vlist_to_del))

    max_distance = -1
    max_v = None
    for v, distance in distance_list.items():
        if distance > max_distance:
            max_distance = distance
            max_v = v

    return (max_distance, max_v)

def calc_tree_diameter(linklist, v=1):
    _, u = calc_longest_distance(linklist, v)
    distance, _ = calc_longest_distance(linklist, u)
    return distance

###############################################################################

def main():
    n = intin()
    ablist = intinl(n-1)

    linklist = make_linklist(ablist)
    diameter = calc_tree_diameter(linklist)

    if diameter % 3 == 1:
        print('Second')
    else:
        print('First')

if __name__ == '__main__':
    main()
```