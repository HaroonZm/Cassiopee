Voici un énoncé de problème :

無限急行
ムゲン鉄道のムゲン線には無限個の駅があります。駅には …, -3, -2, -1, 0, 1, 2, 3, … と番号が振られていて、各駅は数直線上の整数と同じ順番で隣り合っています。あなたはいま、ある番号の駅から電車に乗り、それより大きな番号の駅に向かおうとしています。
ムゲン線には無限種類の快速電車が走っています。それらは 0 級快速、1 級快速、2 級快速、3 級快速、… のように番号で呼ばれています。
n
級快速の電車は、2
n
の倍数の番号の駅に停車します。たとえば、1級快速は駅 …, -4, -2, 0, 2, 4, … に、3 級快速は駅 …, -24, -16, -8, 0, 8, 16, 24, … に停車するといった具合です。0 級快速はすべての駅に停車するので、本当は各駅停車ですがムゲン鉄道は「快速」と呼んでいます。
どの級の快速電車も、ある停車駅から次の停車駅まで移動するのに1単位時間かかります。また、快速電車間の乗り換えにかかる時間は無視できるものとします。乗車駅
s
と降車駅
d
が与えられたとき、
s
から
d
へ移動するのに必要な最小の時間を求めるプログラムを作成してください。ただし、
s
から
d
へ移動する間に、大きな番号から小さな番号の駅に向かっての移動は認められないものとします。
入力
入力は1つのデータセットからなる。入力データは以下の形式で与えられる。
N
s
1
d
1
s
2
d
2
:
s
N
d
N
１行目に移動の回数を表す
N
(1 ≤
N
≤ 100) が与えられる。続く
N
行に、乗車駅の番号
s
i
と降車駅の番号
d
i
(-1,000,000,000 ≤
s
i
<
d
i
≤ 1,000,000,000) が与えられる。
出力
与えられた乗車駅と降車駅ごとに、移動に必要な最小の時間を１行に出力する。
入出力例
入力例
3
0 7
-1048576 0
-3 5
出力例
3
1
4


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import heapq
from collections import deque
from enum import Enum
import sys
import math
from _heapq import heappush, heappop
import copy
from test.support import _MemoryWatchdog

BIG_NUM = 2000000000
HUGE_NUM = 99999999999999999
MOD = 1000000007
EPS = 0.000000001
sys.setrecursionlimit(100000)

SIZE = 32
POW = [1]*SIZE

for i in range(1,SIZE):
    POW[i] = POW[i-1]*2

N = int(input())

for _ in range(N):
    start,goal = map(int,input().split())
    ans = 0

    rank = 0
    current = start

    while current != goal:
        rank = 0

        for i in range(SIZE-1,0,-1):
            if abs(current)%POW[i] == 0 and current+POW[i] <= goal:
                rank = i
                break
        current += POW[rank]
        ans += 1

    print("%d"%(ans))
```