Voici un énoncé de problème :

品質管理
会津タカダ市が生産販売する布製コースターは、対称なデザインでとても美しいことで知られている。会津タカダ市では品質管理の一環として、製造ラインにカメラを設置し、各コースターを撮影して得られた画像が対称になっているかを自動で検証している。各コースターは
N
×
N
ピクセルの正方形の白黒画像として表される。各ピクセルは白または黒の画像に対応して、0 または 1 の値をとる。
この度、生産ラインの機器更新にともなって、画像解析システムのソフトウェアを更新することになった。新システムでは、通信データ量を削減する工夫がなされ、以下の方法でカメラから解析システムにデータが送られてくる。
ラインに流れてくる最初のコースターの情報は、
N
×
N
ピクセルの画像としてシステムに送られてくる。
２枚目以降のコースターの情報は、１つ前に送られた画像との差分だけが送られてくる。差分は、「0 から 1 」または「1 から 0 」へと変化したピクセルの位置の集合として与えられる。
C
枚のコースターについて、１枚目の画像のピクセル情報と続く
C
- 1 枚分の差分情報を入力し、上下対称かつ左右対称となっているコースターの枚数を報告するプログラムを作成せよ。
Input
入力は以下の形式で与えられる。
C
N
p
11
p
12
...
p
1N
p
21
p
22
...
p
2N
:
p
N1
p
N2
...
p
NN
diff
1
diff
2
:
diff
C−1
１行目にコースターの枚数
C
(1 ≤
C
≤ 10000) と画像の縦と横のピクセル数
N
(2 ≤
N
≤ 1000 かつ
N
は偶数) が与えられる。２行目から
N
+ 1 行目に最初のコースターの画像のピクセルを表す
N
行 ×
N
列の数字
p
ij
(
p
ij
は 0 または 1)が与えられる。
N
+ 2 行目以降に、２枚目以降のコースターの情報を表す差分
diff
i
が次の形式で与えられる。
D
r
1
c
1
r
2
c
2
:
r
D
c
D
１行目に変化したピクセルの数
D
(0 ≤
D
≤ 100) が与えられる。続く
D
行に変化したピクセルの行と列の番号をそれぞれ表す
r
i
と
c
i
(1 ≤
r
i
,
c
i
≤
N
) が与えられる。
diff
i
の中に、同じ位置は２回以上与えられない。
Output
上下対称かつ左右対称となっているコースターの枚数を１行に出力する。
Sample Input 1
7 8
00100000
00011000
10111101
01100110
01000110
10111101
00011000
00100100
2
5 3
1 6
1
6 8
3
6 8
3 3
3 6
2
6 3
6 6
0
2
3 8
6 8
Sample Output 1
3
入力例１のコースターの画像を以下に示す。この場合、２枚目、５枚目、６枚目のコースターが上下対称かつ左右対称となるため、3と報告する。
Sample Input 2
1 6
000000
000000
010010
010010
000000
000000
Sample Output 2
1
Sample Input 3
2 2
00
00
4
1 1
1 2
2 1
2 2
Sample Output 3
2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def next(N, i):
    return ((N-i-1)+N)%N

def getState(N, G, i, j):
    return  G[i][j] == G[i][next(N, j)] and  G[i][j] == G[next(N, i)][j] and G[i][j] == G[next(N, i)][next(N, j)]

def getInit(N, G):
    dcnt = 0
    for i in range(N//2):
        for j in range(N//2):
            if not getState(N, G, i, j): dcnt += 1
    return dcnt

C, N = map(int, input().split())
#G = [[0]*N]*N
G = [['N' for _ in range(N)] for _ in range(N)]
for i in range(N):
    str = input()
    for j in range(N):
        G[i][j] = int(str[j])

ans = 0
dcnt = getInit(N, G)
if dcnt == 0: ans += 1

for i in range(C-1):
    k = int(input())
    for j in range(k):
        r, c = map(int, input().split())
        r -= 1
        c -= 1
        pre = getState(N, G, r, c)
        G[r][c] = 0 if G[r][c]== 1 else 1
        post = getState(N, G, r, c)
        if not pre and post: dcnt -= 1
        elif  pre and not post: dcnt += 1
    if dcnt == 0: ans += 1

print(ans)
```