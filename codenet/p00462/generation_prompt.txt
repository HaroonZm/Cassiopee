Voici un énoncé de problème :

ピザ
問題
JOI ピザでは,市の中心部を通る全長
d
メートルの環状線の沿線上でピザの宅配販
売を行っている.
JOI ピザは,環状線上に
n
個の店舗
S
1
, ... ,
S
n
を持つ.本店は
S
1
である.
S
1
から
S
i
まで,時計回りに環状線を移動したときの道のりを
d
i
メートルとおく.
d
2
, ... ,
d
n
は 1 以上
d
- 1 以下の整数である.
d
2
, ... ,
d
n
は全て異なる. ピザの注文を受けると, ピザが冷めないように, 宅配先までの移動距離がもっとも短い店舗でピザを焼き宅配する.
宅配先の位置は 0 以上
d
- 1 以下の整数
k
で表される.これは, 本店
S
1
から宅配先までに時計回りで環状線を移動したときの道のりが
k
メートルであることを意味する. ピザの宅配は環状線に沿って行われ, それ以外の道を通ることは許されない. ただし, 環状線上は時計回りに移動しても反時計回りに移動してもよい.
例えば,店舗の位置と宅配先の位置が下図のようになっている場合 (この例は「入出力の例」の例 1 と対応している),
宅配先 1 にもっとも近い店舗は
S
2
なので, 店舗
S
2
から宅配する.このとき, 店舗からの移動距離は 1 である.また, 宅配先 2 にもっとも近い店舗は
S
1
(本店) なので, 店舗
S
1
(本店) から宅配する.このとき,店舗からの移動距離は 2 である.
環状線の全長
d
, JOI ピザの店舗の個数
n
, 注文の個数
m
, 本店以外の位置を表す
n
- 1 個の整数
d
2
, ... ,
d
n
, 宅配先の場所を表す整数
k
1
, ... ,
k
m
が与えられたとき, 各注文に対する宅配時の移動距離 (すなわち,最寄店舗から宅配先までの道のり) の全注文にわたる総和を求めるプログラムを作成せよ.
入力
入力は複数のデータセットからなる．各データセットは以下の形式で与えられる．
1 行目には環状線の全長を表す正整数
d
(2 ≤
d
≤ 1000000000 = 10
9
), 2 行目には店舗の個数を表す正整数
n
(2 ≤
n
≤ 100000), 3 行目には注文の個数を表す正整数
m
(1 ≤
m
≤ 10000) が書かれている. 4 行目以降の
n
- 1 行には本店以外の店舗の位置を表す整数
d
2
,
d
3
, ... ,
d
n
(1 ≤
d
i
≤
d
- 1) がこの順に書かれており,
n
+ 3 行目以降の
m
行には宅配先の場所を表す整数
k
1
,
k
2
, ... ,
k
m
(0 ≤
k
i
≤
d
- 1) がこの順に書かれている.
採点用データのうち,配点の 40% 分については, n ≤ 10000 を満たす. また,配点の 40% 分については, 求める移動距離の総和と
d
の値はともに 1000000 以下である. さらに,全ての採点用データにおいて, 求める移動距離の総和は 1000000000 = 10
9
以下である.
d
が 0 のとき入力の終了を示す. データセットの数は 10 を超えない．
出力
データセットごとに,宅配時の移動距離の総和を表す 1 つの整数を1 行に出力する.
入出力例
入力例
8
3
2
3
1
4
6
20
4
4
12
8
16
7
7
11
8
0
出力例
3
3
上記問題文と自動審判に使われるデータは、
情報オリンピック日本委員会
が作成し公開している問題文と採点用テストデータです。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import bisect
# python template for atcoder1
import sys
sys.setrecursionlimit(10**9)
input = sys.stdin.readline

def solve():
    d = int(input())
    if d == 0:
        return False
    n = int(input())
    m = int(input())
    stores = [int(input()) for _ in range(n-1)]
    stores = [0]+sorted(stores)+[d]

    ret = 0
    for _ in range(m):
        dest = int(input())
        l = bisect.bisect_right(stores, dest)
        dist = min(stores[l]-dest, dest-stores[l-1])
        ret += dist
    return ret

ans = []
while True:
    a = solve()
    if a:
        ans.append(a)
    else:
        break
print("\n".join(map(str, ans)))
```