Voici un énoncé de problème :

Score :
100
points
Problem Statement
Find the number of integers between
1
and
K
(inclusive) satisfying the following condition, modulo
10^9 + 7
:
The sum of the digits in base ten is a multiple of
D
.
Constraints
All values in input are integers.
1 \leq K < 10^{10000}
1 \leq D \leq 100
Input
Input is given from Standard Input in the following format:
K
D
Output
Print the number of integers satisfying the condition, modulo
10^9 + 7
.
Sample Input 1
30
4
Sample Output 1
6
Those six integers are:
4, 8, 13, 17, 22
and
26
.
Sample Input 2
1000000009
1
Sample Output 2
2
Be sure to print the number modulo
10^9 + 7
.
Sample Input 3
98765432109876543210
58
Sample Output 3
635270834


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
sys.setrecursionlimit(1 << 25)
readline = sys.stdin.buffer.readline
read = sys.stdin.readline  # 文字列読み込む時はこっち

import numpy as np
from functools import partial
array = partial(np.array, dtype=np.int64)
zeros = partial(np.zeros, dtype=np.int64)
full = partial(np.full, dtype=np.int64)

ra = range
enu = enumerate

def a_int(): return int(read())

MOD = 10**9 + 7
INF = 2**31  # 2147483648 > 10**9
# default import

from collections import defaultdict, Counter, deque
from operator import itemgetter, xor, add
from itertools import product, permutations, combinations
from bisect import bisect_left, bisect_right  # , insort_left, insort_right
from functools import reduce

K = np.array(list(map(int, list(input()))))
D = a_int()

'''
ある数xにおいて総和がDの倍数であるかの判定
x[0]+x[1]...+x[n] ≡ 0 (mod D) 各桁の和にMODを取れば良い。つまり桁ごとに処理できる

dp[i,j,k] ... K[:i]以下の整数のうち、k=mod Dとなるような数字の個数。j==1は上位桁が一致している場合の通りの個数。j==0は上位桁が一致しなくなったときの個数。

遷移
for l in range(10):
    dp[i+1,0,(k+l)%D] += dp[i,0,k] #1~9を考慮可能
for l in range(K[i]):
    dp[i+1,0,(k+l)%D] += dp[i,1,k] #1~K[i]-1をつけるとぴったりにならないグループへ行く

dp[i+1,1,(k+K[i])%D] += dp[i,1,k]
'''
# print(K, D)

from numba import njit

@njit('(i8[:],i8)', cache=True)
def solve(K, D):
    N = K.shape[0]
    dp = np.zeros((N + 1, 2, D), dtype=np.int64)
    dp[0, 1, 0] = 1
    for i in range(N):  # 各桁について
        for k in range(D):  # 各あまりについて処理
            for l in range(10):  # 各数字について処理
                dp[i + 1, 0, (k + l) % D] += dp[i, 0, k]  # 1~9を考慮可能
                if l < K[i]:
                    dp[i + 1, 0, (k + l) % D] += dp[i, 1, k]
                    # 1~K[i]-1をつけるとぴったりにならないグループへ行く
                dp[i + 1, 0, (k + l) % D] %= MOD
            # ぴったりグループ
            dp[i + 1, 1, (k + K[i]) % D] += dp[i, 1, k]
            # dp[i + 1, 1, (k + K[i]) % D] %= MOD

    print((dp[-1, :, 0].sum() - 1) % MOD)  # -1は0の分

solve(K, D)
```