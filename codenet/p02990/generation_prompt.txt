Voici un énoncé de problème :

Score :
400
points
Problem Statement
There are
K
blue balls and
N-K
red balls. The balls of the same color cannot be distinguished. Snuke and Takahashi are playing with these balls.
First, Snuke will arrange the
N
balls in a row from left to right.
Then, Takahashi will collect only the
K
blue balls. In one move, he can collect any number of consecutive blue balls. He will collect all the blue balls in the fewest moves possible.
How many ways are there for Snuke to arrange the
N
balls in a row so that Takahashi will need exactly
i
moves to collect all the blue balls? Compute this number modulo
10^9+7
for each
i
such that
1 \leq i \leq K
.
Constraints
1 \leq K \leq N \leq 2000
Input
Input is given from Standard Input in the following format:
N
K
Output
Print
K
lines. The
i
-th line (
1 \leq i \leq K
) should contain the number of ways to arrange the
N
balls so that Takahashi will need exactly
i
moves to collect all the blue balls, modulo
10^9+7
.
Sample Input 1
5 3
Sample Output 1
3
6
1
There are three ways to arrange the balls so that Takahashi will need exactly one move: (B, B, B, R, R), (R, B, B, B, R), and (R, R, B, B, B). (R and B stands for red and blue, respectively).
There are six ways to arrange the balls so that Takahashi will need exactly two moves: (B, B, R, B, R), (B, B, R, R, B), (R, B, B, R, B), (R, B, R, B, B), (B, R, B, B, R), and (B, R, R, B, B).
There is one way to arrange the balls so that Takahashi will need exactly three moves: (B, R, B, R, B).
Sample Input 2
2000 3
Sample Output 2
1998
3990006
327341989
Be sure to print the numbers of arrangements modulo
10^9+7
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys

read = sys.stdin.buffer.read
input = sys.stdin.buffer.readline
inputs = sys.stdin.buffer.readlines

# rstrip().decode('utf-8')
# INF=float("inf")
MOD=10**9+7
# sys.setrecursionlimit(2147483647)
# import math
#import numpy as np
# import operator
# import bisect
# from heapq import heapify,heappop,heappush
#from math import gcd
# from fractions import gcd
# from collections import deque
# from collections import defaultdict
# from collections import Counter
# from itertools import accumulate
# from itertools import groupby
# from itertools import permutations
# from itertools import combinations
# from scipy.sparse import csr_matrix
# from scipy.sparse.csgraph import floyd_warshall
# from scipy.sparse.csgraph import csgraph_from_dense
# from scipy.sparse.csgraph import dijkstra
# map(int,input().split())

def framod(n, mod, a=1):
    for i in range(1,n+1):
        a=a * i % mod
    return a

def power(n, r, mod):
    if r == 0: return 1
    if r%2 == 0:
        return power(n*n % mod, r//2, mod) % mod
    if r%2 == 1:
        return n * power(n, r-1, mod) % mod

def comb(n, k, mod):
    a=framod(n, mod)
    b=framod(k, mod)
    c=framod(n-k, mod)
    return (a * power(b, mod-2, mod) * power(c, mod-2, mod)) % mod

def main():
	N,K=map(int,input().split())
	
	for i in range(1,K+1):
		if i<=N-K+1:
			print(comb(N-K+1,i,MOD)*comb(K-1,i-1,MOD)%MOD)
		else:
			print(0)
	

if __name__ == '__main__':
	main()
```