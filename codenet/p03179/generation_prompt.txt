Voici un énoncé de problème :

Score :
100
points
Problem Statement
Let
N
be a positive integer.
You are given a string
s
of length
N - 1
, consisting of
<
and
>
.
Find the number of permutations
(p_1, p_2, \ldots, p_N)
of
(1, 2, \ldots, N)
that satisfy the following condition, modulo
10^9 + 7
:
For each
i
(
1 \leq i \leq N - 1
),
p_i < p_{i + 1}
if the
i
-th character in
s
is
<
, and
p_i > p_{i + 1}
if the
i
-th character in
s
is
>
.
Constraints
N
is an integer.
2 \leq N \leq 3000
s
is a string of length
N - 1
.
s
consists of
<
and
>
.
Input
Input is given from Standard Input in the following format:
N
s
Output
Print the number of permutations that satisfy the condition, modulo
10^9 + 7
.
Sample Input 1
4
<><
Sample Output 1
5
There are five permutations that satisfy the condition, as follows:
(1, 3, 2, 4)
(1, 4, 2, 3)
(2, 3, 1, 4)
(2, 4, 1, 3)
(3, 4, 1, 2)
Sample Input 2
5
<<<<
Sample Output 2
1
There is one permutation that satisfies the condition, as follows:
(1, 2, 3, 4, 5)
Sample Input 3
20
>>>><>>><>><>>><<>>
Sample Output 3
217136290
Be sure to print the number modulo
10^9 + 7
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
N=int(input())
S=input()
mod=10**9+7

#DP[i]#最後においた数の右にある残っている個数
rest=N-1
DP=[1]*(N)

for s in S:
    NDP=[0]*(N)
    if s=="<":
        for i in range(rest+1):
            if i>=1:
                NDP[i-1]=(DP[i]+NDP[i-1])%mod

        DP=NDP
        for i in range(N-2,-1,-1):
            DP[i]=(DP[i+1]+DP[i])%mod

    else:
        DP=[DP[rest-i] for i in range(N)]#左右逆にして考える

        #print(DP)
        for i in range(rest+1):
            if i>=1:
                NDP[i-1]=(DP[i]+NDP[i-1])%mod

        DP=NDP
        for i in range(N-2,-1,-1):
            DP[i]=(DP[i+1]+DP[i])%mod

        DP=[DP[rest-1-i] for i in range(N)]

    rest-=1
    #print(DP,rest)

print(DP[0])
```