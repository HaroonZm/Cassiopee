En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque
while 1:
    n, a, s, g = map(int, raw_input().split())
    if n == a == s == g == 0:
        break
    G = [[] for i in xrange(n)]
    H = [[] for i in xrange(n)]
    for i in xrange(a):
        x, y, lab = raw_input().split()
        x = int(x); y = int(y)
        G[y].append((x, lab))
        H[x].append(y)
    can = [0]*n
    deq = deque()
    can[s] = 1
    deq.append(s)
    while deq:
        v = deq.popleft()
        for t in H[v]:
            if not can[t]:
                can[t] = 1
                deq.append(t)

    state = [None]*n
    state[g] = ""
    step = 0; prev_s = None; LIM = 5*n+1; ok = 0
    for c in xrange(LIM*2):
        update = 0
        for v in xrange(n):
            if state[v] is None or not can[v]:
                continue
            for t, l in G[v]:
                if state[t] is None or l + state[v] < state[t]:
                    state[t] = l + state[v]
                    update = 1
        if prev_s == state[s]:
            step += 1
        else:
            prev_s = state[s]
            step = 0
        if step == LIM:
            ok = 1
            break
    if state[s] is None or not ok:
        print "NO"
    else:
        print state[s]
```