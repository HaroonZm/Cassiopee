Voici un énoncé de problème :

Score :
600
points
Problem Statement
There are
N
piles of stones. The
i
-th pile has
A_i
stones.
Aoki and Takahashi are about to use them to play the following game:
Starting with Aoki, the two players alternately do the following operation:
Operation: Choose one pile of stones, and remove one or more stones from it.
When a player is unable to do the operation, he loses, and the other player wins.
When the two players play optimally, there are two possibilities in this game: the player who moves first always wins, or the player who moves second always wins, only depending on the initial number of stones in each pile.
In such a situation, Takahashi, the second player to act, is trying to guarantee his win by moving at least zero and at most
(A_1 - 1)
stones from the
1
-st pile to the
2
-nd pile before the game begins.
If this is possible, print the minimum number of stones to move to guarantee his victory; otherwise, print
-1
instead.
Constraints
2 \leq N \leq 300
1 \leq A_i \leq 10^{12}
Input
Input is given from Standard Input in the following format:
N
A_1
\ldots
A_N
Output
Print the minimum number of stones to move to guarantee Takahashi's win; otherwise, print
-1
instead.
Sample Input 1
2
5 3
Sample Output 1
1
Without moving stones, if Aoki first removes
2
stones from the
1
-st pile, Takahashi cannot win in any way.
If Takahashi moves
1
stone from the
1
-st pile to the
2
-nd before the game begins so that both piles have
4
stones, Takahashi can always win by properly choosing his actions.
Sample Input 2
2
3 5
Sample Output 2
-1
It is not allowed to move stones from the
2
-nd pile to the
1
-st.
Sample Input 3
3
1 1 2
Sample Output 3
-1
It is not allowed to move all stones from the
1
-st pile.
Sample Input 4
8
10 9 8 7 6 5 4 3
Sample Output 4
3
Sample Input 5
3
4294967297 8589934593 12884901890
Sample Output 5
1
Watch out for overflows.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from functools import reduce, lru_cache

INF = float("inf")

N, a, b, *A = map(int, open(0).read().split())
c = reduce(lambda a, b: a ^ b, A, 0)

@lru_cache(None)
def solve(a, b, c):
    if (a % 2) ^ (b % 2) != (c % 2):
        return INF
    if c == 0:
        return INF if a < b else (a - b) // 2

    return min(
        2 * solve(a // 2, b // 2, c // 2),
        1 + 2 * solve((a - 1) // 2, (b + 1) // 2, c // 2)
    )

print(-1 if (res := solve(a, b, c)) >= a else res)
```