Voici un énoncé de problème :

Score :
100
points
Problem Statement
There are three airports A, B and C, and flights between each pair of airports in both directions.
A one-way flight between airports A and B takes
P
hours, a one-way flight between airports B and C takes
Q
hours, and a one-way flight between airports C and A takes
R
hours.
Consider a route where we start at one of the airports, fly to another airport and then fly to the other airport.
What is the minimum possible sum of the flight times?
Constraints
1 \leq P,Q,R \leq 100
All values in input are integers.
Input
Input is given from Standard Input in the following format:
P
Q
R
Output
Print the minimum possible sum of the flight times.
Sample Input 1
1 3 4
Sample Output 1
4
The sum of the flight times in the route A
\rightarrow
B
\rightarrow
C:
1 + 3 = 4
hours
The sum of the flight times in the route A
\rightarrow
C
\rightarrow
C:
4 + 3 = 7
hours
The sum of the flight times in the route B
\rightarrow
A
\rightarrow
C:
1 + 4 = 5
hours
The sum of the flight times in the route B
\rightarrow
C
\rightarrow
A:
3 + 4 = 7
hours
The sum of the flight times in the route C
\rightarrow
A
\rightarrow
B:
4 + 1 = 5
hours
The sum of the flight times in the route C
\rightarrow
B
\rightarrow
A:
3 + 1 = 4
hours
The minimum of these is
4
hours.
Sample Input 2
3 2 3
Sample Output 2
5


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python3

import sys
# import math
# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)
# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()
# from collections import defaultdict          # subclass of dict. defaultdict(facroty)
# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)
# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).
# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).
# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])
# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]
# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]
# from itertools import product                # product(iter, repeat=n)
# from itertools import accumulate             # accumulate(iter[, f])
# from functools import reduce                 # reduce(f, iter[, init])
# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict
# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).
# from copy import deepcopy                    # to copy multi-dimentional matrix without reference
# from fractions import gcd                    # for Python 3.4

def main():
    mod = 1000000007                  # 10^9+7
    inf = float('inf')
    sys.setrecursionlimit(10**6)    # 1000 -> 1000000
    def input(): return sys.stdin.readline().rstrip()
    def ii():  return int(input())
    def mi():  return map(int, input().split())
    def mi_0(): return map(lambda x: int(x)-1, input().split())
    def lmi(): return list(map(int, input().split()))
    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))
    def li():  return list(input())
    
    
    L = sorted(lmi())
    print(L[0]+L[1])

if __name__ == "__main__":
    main()
```