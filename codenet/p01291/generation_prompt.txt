Voici un énoncé de problème :

Problem I:
Wind Passages
Wind Corridor is a covered passageway where strong wind is always blowing. It is a long corridor of
width W, and there are several pillars in it. Each pillar is a right prism and its face is a polygon (not
necessarily convex).
In this problem, we consider two-dimensional space where the positive
x
-axis points the east and the
positive
y
-axis points the north. The passageway spans from the south to the north, and its length is
infinity. Specifically, it covers the area 0 ≤
x
≤
W
. The outside of the passageway is filled with walls.
Each pillar is expressed as a polygon, and all the pillars are located within the corridor without conflicting
or touching each other.
Wind blows from the south side of the corridor to the north. For each second,
w
unit volume of air can
be flowed at most if the minimum width of the path of the wind is
w
. Note that the path may fork and
merge, but never overlaps with pillars and walls.
Your task in this problem is to write a program that calculates the maximum amount of air that can be
flowed through the corridor per second.
Input
The input consists of multiple datasets. Each dataset has the following format:
The first line of the input contains two integers
W
and
N
.
W
is the width of the corridor, and
N
is the
number of pillars.
W
and
N
satisfy the following condition: 1 ≤
W
≤ 10
4
and 0 ≤
N
≤ 200.
Then,
N
specifications of each pillar follow. Each specification starts with a line that contains a single
integer
M
, which is the number of the vertices of a polygon (3 ≤
M
≤ 40). The following
M
lines describe the shape of the polygon. The
i
-th line (1 ≤
i
≤
M
) contains two integers
x
i
and
y
i
that denote the coordinate of the
i
-th vertex (0 <
x
i
<
W
, 0 <
y
i
< 10
4
).
The last dataset is followed by a line containing two zeros. This line is not a part of any dataset and should not be processed.
Output
For each dataset, your program should print a line that contains the maximum amount of air flow per second, in unit
volume. The output may contain arbitrary number of digits after the decimal point, but the absolute error
must not exceed 10
-6
.
Sample Input
5 2
4
1 1
1 2
2 2
2 1
4
3 3
3 4
4 4
4 3
0 0
Output for the Sample Input
3.41421356


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop
import sys
readline = sys.stdin.readline
write = sys.stdout.write
def cross2(p, q):
    return p[0]*q[1] - p[1]*q[0]
def dot2(p, q):
    return p[0]*q[0] + p[1]*q[1]
def dist2(p):
    return p[0]**2 + p[1]**2
def segment_line_dist(x, p0, p1):
    z0 = (p1[0] - p0[0], p1[1] - p0[1])
    z1 = (x[0] - p0[0], x[1] - p0[1])
    if 0 <= dot2(z0, z1) <= dist2(z0):
        return cross2(z0, z1)**2 / dist2(z0)
    z2 = (x[0] - p1[0], x[1] - p1[1])
    return min(dist2(z1), dist2(z2))

def solve():
    W, N = map(int, readline().split())
    if W == N == 0:
        return False
    PS = []
    for i in range(N):
        M = int(readline())
        P = [list(map(int, readline().split())) for i in range(M)]
        PS.append(P)

    G = [[] for i in range(N+2)]
    for i in range(N):
        Pi = PS[i]
        ni = len(Pi)
        for j in range(i+1, N):
            Pj = PS[j]
            r = 10**18
            nj = len(Pj)
            for p1 in Pi:
                for k in range(nj):
                    q1 = Pj[k-1]; q2 = Pj[k]
                    r = min(r, segment_line_dist(p1, q1, q2))
            for q1 in Pj:
                for k in range(ni):
                    p1 = Pi[k-1]; p2 = Pi[k]
                    r = min(r, segment_line_dist(q1, p1, p2))
            d = r**.5
            G[i].append((j, d))
            G[j].append((i, d))
        d = min(x for x, y in Pi)
        G[i].append((N, d))
        G[N].append((i, d))

        d = W - max(x for x, y in Pi)
        G[i].append((N+1, d))
        G[N+1].append((i, d))

    G[N].append((N+1, W))
    G[N+1].append((N, W))
    que = [(0, N)]
    dist = [10**18]*(N+2)
    dist[N] = 0
    while que:
        cost, v = heappop(que)
        if dist[v] < cost:
            continue
        for w, d in G[v]:
            if cost + d < dist[w]:
                dist[w] = cost + d
                heappush(que, (cost + d, w))
    write("%.16f\n" % dist[N+1])
    return True
while solve():
    ...
```