Voici un énoncé de problème :

Score :
400
points
Problem Statement
A positive integer
X
is said to be a lunlun number if and only if the following condition is satisfied:
In the base ten representation of
X
(without leading zeros), for every pair of two adjacent digits, the absolute difference of those digits is at most
1
.
For example,
1234
,
1
, and
334
are lunlun numbers, while none of
31415
,
119
, or
13579
is.
You are given a positive integer
K
. Find the
K
-th smallest lunlun number.
Constraints
1 \leq K \leq 10^5
All values in input are integers.
Input
Input is given from Standard Input in the following format:
K
Output
Print the answer.
Sample Input 1
15
Sample Output 1
23
We will list the
15
smallest lunlun numbers in ascending order:
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
,
10
,
11
,
12
,
21
,
22
,
23
.
Thus, the answer is
23
.
Sample Input 2
1
Sample Output 2
1
Sample Input 3
13
Sample Output 3
21
Sample Input 4
100000
Sample Output 4
3234566667
Note that the answer may not fit into the
32
-bit signed integer type.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import queue

# ['1', '0'] => 10 関数 
def strtoNum(l):
    val = ''
    for _ in l:
        val += _
    return int(val)

# 入力
k = int(input())

# k < 10だけ別対応しておく
if k < 10:
    print(k)
    exit()

# ルンルン数を管理するキュー
lun = queue.Queue()
# 初期値として1~9を入れておく
for i in range(1, 10):
    lun.put(i)

# 10からスタートなので、既にルンルンカウントを9にしておく
cnt = 9
# 0~
apdNum = [[0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9]]

while not lun.empty():
    # dequeueした数を取得
    getNum = list(str(lun.get()))
    # 一番最後の桁だけを確認する
    chkNum = int(getNum[len(getNum)-1])
    for i in apdNum[chkNum]:
        cnt += 1
        putNum = getNum + [str(i)]
        if cnt == k:
            print(strtoNum(putNum))
            exit()
        else:
            lun.put(strtoNum(putNum))
```