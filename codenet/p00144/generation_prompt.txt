Voici un énoncé de problème :

パケット転送
インターネットでは、データはパケットに分割され、パケットごとにルータと呼ばれる中継機器を介して宛先に転送されます。各ルータはパケットに記載された宛先から次に転送すべきルータを判断します。さらに、無限にルータ間を転送され続けることを防ぐため、パケットには TTL（Time To Live） という値が付加されています。ルータは受け取ったパケットの TTL を 1 減算し、その結果が 0 ならそのパケットを破棄し、それ以外なら次のルータに転送します。
そこで、ネットワークの設計を手助けするプログラムを作ることになりました。ネットワークの接続情報と送信パケットの情報を入力として、各パケットが宛先ルータに到着するまでに経由するルータの数のうち最小の値を表示するプログラムを作成してください。
ネットワークは図のように複数のルータとそれらを結ぶケーブルで構成されています。ただし、各接続（ケーブル）は単方向であることに注意してください。各ルータが直接つながっているルータの番号の配列がネットワークの接続の情報として与えられます。ルータの数を
n
とすれば、各ルータは 1 から
n
までの整数で識別されます。送信元から宛先ルータまでの経路が複数ある場合は、経由するルータの数が少ない方の値を出力してください。また、パケットが宛先に到達しない場合は NA と出力してください。
例えば、以下の図のようなネットワークで、送信元ルータが 6、宛先ルータが 5 の場合を考えます。最短経路は 6→1→5 であり経由するルータは 3 個です。この場合、TTL はルータ 6、1 でそれぞれ減算されるので、送信時の TTL が 3 以上であればパケットは到達できます。宛先ルータでは TTL を減算する必要はありません。また、送信元と宛先が同じルータになるようなパケットは無いものとします。
Input
入力は以下の形式で与えられます。
n
r
1
k
1
t
11
t
12
...
t
1k
1
r
2
k
2
t
21
t
22
...
t
2k
2
:
r
n
k
n
t
n1
t
n2
...
t
nk
n
p
s
1
d
1
v
1
s
2
d
2
v
2
:
s
p
d
p
v
p
1 行目にルータの総数
n
（
n
≤ 100）、続く
n
行に
i
番目のルータの接続情報が与えられます。接続情報として、
i
番目のルータの番号
r
i
、
i
番目のルータと直接接続しているルータの個数
k
i
、
i
番目のルータから送信できるルータの番号
t
i1
,
t
i2
, ...
t
ik
i
が与えられます。
続く行にパケットの個数
p
（
p
≤ 1000）、続く
p
行に
i
番目のパケットの情報が与えられます。パケットの情報として、 送信元ルータの番号
s
i
, 宛先ルータの番号
d
i
, TTL の値
v
i
(0 ≤
v
i
≤ 10000) が与えられます。
Output
各パケットごとに、経由するルータの個数または NA を１行に出力してください。
Sample Input
7
1 4 2 5 4 3
2 1 5
3 1 6
4 1 7
5 2 7 6
6 1 1
7 0
6
1 2 2
1 5 3
1 2 1
5 1 3
6 3 3
1 7 4
Output for the Sample Input
2
2
NA
3
3
3


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from functools import lru_cache

n=int(input())
router={}
for _ in range(n):
    t=[int(i) for i in input().split(" ")]
    r=t[0]
    k=t[1]
    t=t[2::]
    router[r]=t

def transport(s,g):
    distance=[10**10 for i in range(n+1)]
    distance[s]=0
    next=[s]
    for i in range(1,n+1):
        _next=[]
        for j in next:
            _next+=router[j]
        next=list(set(_next))
        for j in next:
            distance[j]=min(i,distance[j])
    return distance[g]+1

p=int(input())
for _ in range(p):
    s,d,v=[int(i) for i in input().split(" ")]
    t=transport(s,d)
    if t<=v:
        print(t)
    else:
        print("NA")
```