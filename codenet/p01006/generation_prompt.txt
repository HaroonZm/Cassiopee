Voici un énoncé de problème :

Problem A: Nasty Boys
Problem
太郎君は学校のロッカーに大事な本を隠しているので他の人よりとても厳重に管理していて、学校で支給された鍵に加えて以下のようなボタン認証式の鍵を設置しています。
ただパスワードを忘れやすい太郎くんはパスワードを一筆書きで書けるものにしてしまう癖があります。更に詰めの甘い太郎君は自分のパスワードを考えるときに候補を紙に書いていました。その紙をたまたま拾ったは次郎君は、性格が悪いので捨てずにロッカーを開けることに挑戦しました。
しかし紙にはなんと1000個ものパスワードの案が書かれており、全ての入力を試すと日が暮れてしまいそうです。
そこで太郎君の癖を知っている次郎君は、調べる回数を減らすために1000個のパスワードの中から一筆書きできるものだけを取り上げることにして、その作業をプログラマーの貴方に頼むことにしました。
1つのデータセットにつき必ず候補は一つ以上存在します。一筆書きのルールを以下に示します。
同じ文字は連続しない。例えばAAAは許されない。
上下左右4方向に一筆書きが可能。斜め方向に移動しない。
ボタン配列の枠外に出て連続することはない。例えばABCAのような移動は許されない。
一度通った文字の上も何度も通過可能。
ボタン1文字のみの入力も一筆書きとみなす。
Input
入力は以下のように1000個の文字列群からなり、各行はAからIまでの1文字以上10文字以下の大文字のアルファベット列である。それぞれ文字列のデータの重複はないものとする。
string
1
string
2
...
string
1000
Output
入力のうち候補となるパスワード（candidatePassword）のみ抜き出して以下のように列挙せよ。なお以下の場合はN個の候補が挙げられている。
candidatePassword
1
candidatePassword
2
...
candidatePassword
N
出力は入力の文字列の順と同じであり順番を入れ替えてはならない。
Sample Input
ABCFI
ABCABCABC
AEI
EFC
（中略）
DEHED
EEEEE
（以上でちょうど1000個）
Sample Output
ABCFI
EFC
（中略）
DEHED


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# AOJ 1516: Nasty Boys
# Python3 2018.7.13 bal4u

rr = [0,0,0,1,1,1,2,2,2]
cc = [0,1,2,0,1,2,0,1,2]
A = ord('A')

for i in range(1000):
	buf = list(input())
	j = 0
	r, c = rr[ord(buf[j])-A], cc[ord(buf[j])-A]
	j, f = j+1, True
	while j < len(buf) and f:
		f = False
		r2, c2 = rr[ord(buf[j])-A], cc[ord(buf[j])-A]
		j += 1
		if r2 == r:
			if c2 == c+1 or c2 == c-1: f = True
		elif c2 == c:
			if r2 == r+1 or r2 == r-1: f = True
		r, c = r2, c2
	if f: print(*buf, sep='')
```