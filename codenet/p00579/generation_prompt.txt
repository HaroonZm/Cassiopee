Voici un énoncé de problème :

イルミネーション (Illumination)
問題文
JOI 氏は，自宅の敷地に
N
本の木を所有している．これらの木は一列に並んでおり，順に
1
から
N
までの整数で番号が付けられている．
この冬，JOI 氏はいくつかの木を選んで，イルミネーションを飾り付けることにした．イルミネーションには
美しさ
と呼ばれる値が定まっている．木
i
にイルミネーションを飾り付ける場合の美しさは
A_i
である．
JOI 氏は，あまりに近い
2
つの木の両方にイルミネーションを飾り付けてしまうと，眩しすぎる場合があることに気がついた．具体的には，
j = 1, 2, ..., M
に対して，木
L_j
,
L_j + 1
,
...
,
R_j
のうち
2
つ以上にイルミネーションを飾り付けるべきではないということが判明した．
この条件に従ってイルミネーションを飾り付けるときの，美しさの合計の最大値を求めよ．
制約
1 ≦ N ≦ 200000 (= 2×10^5)
1 ≦ M ≦ 200000 (= 2×10^5)
1 ≦ A_i ≦ 1000000000 (= 10^9)
(
1 ≦ i ≦ N
)
1 ≦ L_j ≦ R_j ≦ N
(
1 ≦ j ≦ M
)
入力・出力
入力
入力は以下の形式で標準入力から与えられる．
N
M
A_1
A_2
...
A_N
L_1
R_1
L_2
R_2
⋮
L_M
R_M
出力
イルミネーションの美しさの合計の最大値を
1
行で出力せよ．
入出力例
入力例 1
4 1
1 2 3 8
2 4
出力例 1
9
この入力例では，木
1
,
4
にイルミネーションを飾り付けると，美しさの合計が
9
となり最大となる．
L_1 = 2
,
R_1 = 4
なので，木
2
,
3
,
4
のうち
2
つ以上にイルミネーションを飾り付けることはできない．例えば木
1
,
2
,
4
にイルミネーションを飾り付けることはできないことに注意せよ．
入力例 2
5 2
2 3 9 5 6
1 3
2 4
出力例 2
15
入力例 3
20 10
870851814 594414687 615919461 65033245 460143082 617460823 881870957 126041265 623075703 34130727 27054628 853567651 483228744 491145755 220689940 148007930 229257101 790404982 612186806 281076231
15 19
20 20
12 13
1 4
19 19
9 13
3 6
9 12
16 16
18 19
出力例 3
4912419478
情報オリンピック日本委員会作 『第 18 回日本情報オリンピック JOI 2018/2019 予選競技課題』


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/python3

import array
from fractions import Fraction
import functools
import itertools
import math
import os
import sys

def main():
    N, M = read_ints()
    A = read_ints()
    B = [(l, r) for l, r in [read_ints() for _ in range(M)]]
    print(solve(N, M, A, B))

def solve(N, M, A, B):
    B.sort()
    bi = 0
    dp = [0] * (N + 1)
    range_counts = []
    range_starts = []
    ri = 0
    range_map = {}
    end_map = {}
    for i in range(1, N + 1):
        while bi < len(B) and B[bi][0] == i:
            l, r = B[bi]
            if l not in range_map:
                range_map[l] = len(range_counts)
                range_counts.append(0)
                range_starts.append(l)
            range_counts[range_map[l]] += 1
            if r not in end_map:
                end_map[r] = []
            end_map[r].append(range_map[l])
            bi += 1

        li = i - 1
        if ri < len(range_counts):
            li = range_starts[ri] - 1
        dp[i] = max(dp[i - 1], dp[li] + A[i - 1])

        if i in end_map:
            for rangei in end_map[i]:
                range_counts[rangei] -= 1
        while ri < len(range_counts) and range_counts[ri] == 0:
            ri += 1

    return dp[-1]

###############################################################################
# AUXILIARY FUNCTIONS

DEBUG = 'DEBUG' in os.environ

def inp():
    return sys.stdin.readline().rstrip()

def read_int():
    return int(inp())

def read_ints():
    return [int(e) for e in inp().split()]

def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)

if __name__ == '__main__':
    main()
```