Voici un énoncé de problème :

真っ暗な部屋
目を覚ますと、A君は真っ暗な部屋の中にいた。
どうやらA君は
N
個の部屋から構成されたダンジョンに迷い込んでしまったようだ。
あなたはA君がどの部屋に迷い込んだのかを知ることはできなかったが、幸いにもダンジョンのマップを手に入れることができた。
A君の進むべき道を示し明るい部屋に導こう。
N
個の部屋のうち
M
個の部屋が真っ暗な部屋であり、それぞれ
D_1
,
D_2
, ...,
D_M
番目の部屋が真っ暗な部屋であることが分かっている。
また、全ての部屋からちょうど
K
本の一方通行の道が順に並んでおり、
i
番目の部屋から出る道はそれぞれ
v_{i,1}
,
v_{i,2}
, ...,
v_{i,K}
番目の部屋に繋がっている。
あなたは、A君に対し今いる部屋から
a_1
,
a_2
, ...,
a_l
番目の道を順に進ませることができる。
ただし、A君は明るい部屋に到達したらそれ以降の指示は無視する。
あなたは、指示の前後においてA君が今いる部屋の情報を知ることはできないため、A君がどの部屋にいたとしても明るい部屋に辿り着けるような指示列を伝えなければならない。
そのような指示のうち、最も短いものの長さを答えよ。
Constraints
2 ≤ N ≤ 100
1 ≤ M ≤ min(16, N − 1)
1 ≤ K ≤ N
1 ≤ D_i ≤ N
D_i
は全て異なる
1 ≤ v_{i, j} ≤ N
全ての暗い部屋は少なくとも1つの明るい部屋に到達可能である
Input Format
入力は以下の形式で標準入力から与えられる。
N
M
K
D_1
D_2
...
D_M
v_{1,1}
v_{1,2}
...
v_{1,K}
v_{2,1}
v_{2,2}
...
v_{2,K}
...
v_{N,1}
v_{N,2}
...
v_{N,K}
Output Format
答えを一行に出力せよ。
Sample Input 1
4 2 2
1 2
2 4
3 1
4 2
1 3
Sample Output 1
2
1, 1 という指示を出すと
A君の初期位置が部屋1である場合、2つ目の移動で部屋3に到達する
A君の初期位置が部屋2である場合、1つ目の移動で部屋3に到達する
Sample Input 2
3 2 2
1 2
2 3
1 2
2 1
Sample Output 2
3
2, 1, 2 という指示を出すと
A君の初期位置が部屋1である場合、1つ目の移動で部屋3に到達する
A君の初期位置が部屋2である場合、3つ目の移動で部屋3に到達する
Sample Input 3
6 3 3
1 2 3
4 1 1
2 5 2
3 3 6
4 4 4
5 5 5
6 6 6
Sample Output 3
3
非連結であるケースや、自己辺、多重辺があるケースに気をつけよう


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    n,m,k = LI()
    d = LI_()
    v = [LI_() for _ in range(n)]
    dd = collections.defaultdict(lambda: None)
    for i in range(m):
        dd[d[i]] = i
    vv = []
    for c in d:
        vv.append([dd[v[c][i]] for i in range(k)])
    vvv = [[vv[i][j] for i in range(m)] for j in range(k)]
    u = set()
    m2 = 2**m
    u.add(m2-1)
    q = [(m2-1, 1)]
    ii = [2**_ for _ in range(m)]
    # print('vv',vv)
    while q:
        qd, qk = q.pop(0)
        # print('q', qd,qk)
        qdi = [di for di in range(m) if qd & ii[di]]
        for vi in range(k):
            t = 0
            vvi = vvv[vi]
            for di in qdi:
                if not vvi[di] is None:
                    t |= ii[vvi[di]]
            # print('vit',vi,t)
            if t in u:
                continue
            if t == 0:
                return qk
            u.add(t)
            q.append((t,qk+1))

    return -1

print(main())
```