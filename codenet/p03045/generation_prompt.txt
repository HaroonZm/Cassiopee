Voici un énoncé de problème :

Score :
500
points
Problem Statement
There are
N
cards placed face down in a row. On each card, an integer
1
or
2
is written.
Let
A_i
be the integer written on the
i
-th card.
Your objective is to guess
A_1, A_2, ..., A_N
correctly.
You know the following facts:
For each
i = 1, 2, ..., M
, the value
A_{X_i} + A_{Y_i} + Z_i
is an even number.
You are a magician and can use the following magic any number of times:
Magic
: Choose one card and know the integer
A_i
written on it. The cost of using this magic is
1
.
What is the minimum cost required to determine all of
A_1, A_2, ..., A_N
?
It is guaranteed that there is no contradiction in given input.
Constraints
All values in input are integers.
2 \leq N \leq 10^5
1 \leq M \leq 10^5
1 \leq X_i < Y_i \leq N
1 \leq Z_i \leq 100
The pairs
(X_i, Y_i)
are distinct.
There is no contradiction in input. (That is, there exist integers
A_1, A_2, ..., A_N
that satisfy the conditions.)
Input
Input is given from Standard Input in the following format:
N
M
X_1
Y_1
Z_1
X_2
Y_2
Z_2
\vdots
X_M
Y_M
Z_M
Output
Print the minimum total cost required to determine all of
A_1, A_2, ..., A_N
.
Sample Input 1
3 1
1 2 1
Sample Output 1
2
You can determine all of
A_1, A_2, A_3
by using the magic for the first and third cards.
Sample Input 2
6 5
1 2 1
2 3 2
1 3 3
4 5 4
5 6 5
Sample Output 2
2
Sample Input 3
100000 1
1 100000 100
Sample Output 3
99999


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# UnionFind、0-indexであることに注意
#############################################################

class UnionFind:

    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, v):  # vが属する集合の根を返す
        if self.parents[v] < 0:
            return v
        else:
            self.parents[v] = self.find(self.parents[v])
            return self.parents[v]

    def unite(self, u, v):  # 「uが属する集合」と「vが属する集合」を併合（根同士を結ぶ）
        u = self.find(u)
        v = self.find(v)
        if u == v:
            return
        if self.parents[u] > self.parents[v]:  # u < v に統一する
            u, v = v, u
        self.parents[u] += self.parents[v]
        self.parents[v] = u

    def size(self, v):  # vが属する集合の要素数
        return -self.parents[self.find(v)]

    def same(self, u, v):  # uとvが同じ集合に属するか否か
        return self.find(u) == self.find(v)

#############################################################
N, M = map(int, input().split())

uf = UnionFind(N)

# a+bの偶奇が分かる
# ここで、実際の偶奇や、zの値は必要ない
# 一方が分かれば他方も分かる、ということが本質
for _ in range(M):
    a, b, z = map(int, input().split())
    uf.unite(a - 1, b - 1)

# A_1 + A_2の偶奇, A_2 + A_3の偶奇が分かった時、
# 1つだけ魔法で確定させれば他の値は確定する。

# M個の条件についてUnionFindを生成する。
# 連結成分ごとに1回魔法を使えばあとは芋づる式に求まる。

# (連結成分の個数) = (rootの値が何種類存在するか)

root_list = []

for i in range(N):
    root_list.append(uf.find(i))

root_set = set(root_list)

print(len(root_set))
```