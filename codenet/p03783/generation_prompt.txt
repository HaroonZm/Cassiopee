Voici un énoncé de problème :

Score :
1000
points
Problem Statement
AtCoDeer the deer found
N
rectangle lying on the table, each with height
1
.
If we consider the surface of the desk as a two-dimensional plane, the
i
-th rectangle
i(1≤i≤N)
covers the vertical range of
[i-1,i]
and the horizontal range of
[l_i,r_i]
, as shown in the following figure:
AtCoDeer will move these rectangles horizontally so that all the rectangles are connected.
For each rectangle, the cost to move it horizontally by a distance of
x
, is
x
.
Find the minimum cost to achieve connectivity.
It can be proved that this value is always an integer under the constraints of the problem.
Constraints
All input values are integers.
1≤N≤10^5
1≤l_i<r_i≤10^9
Partial Score
300
points will be awarded for passing the test set satisfying
1≤N≤400
and
1≤l_i<r_i≤400
.
Input
The input is given from Standard Input in the following format:
N
l_1
r_1
l_2
r_2
:
l_N
r_N
Output
Print the minimum cost to achieve connectivity.
Sample Input 1
3
1 3
5 7
1 3
Sample Output 1
2
The second rectangle should be moved to the left by a distance of
2
.
Sample Input 2
3
2 5
4 6
1 4
Sample Output 2
0
The rectangles are already connected, and thus no move is needed.
Sample Input 3
5
999999999 1000000000
1 2
314 315
500000 500001
999999999 1000000000
Sample Output 3
1999999680
Sample Input 4
5
123456 789012
123 456
12 345678901
123456 789012
1 23
Sample Output 4
246433
Sample Input 5
1
1 400
Sample Output 5
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
# seishin.py
N = int(input())
P = [list(map(int, input().split())) for i in range(N)]

INF = 10**18

from heapq import heappush, heappop

l0, r0 = P[0]

L = [-l0+1]
R = [l0-1]
s = t = 0

def debug(L, s, t, R):
    L0 = L[:]
    Q1 = []; Q2 = []
    while L0:
        Q1.append(-s-heappop(L0))
    R0 = R[:]
    while R0:
        Q2.append(t+heappop(R0))
    print("debug:", *Q1[::-1]+Q2)

#print(L, s, t, R)
res = 0
for i in range(N-1):
    l0, r0 = P[i]
    l1, r1 = P[i+1]
    #print(">", l1, r1)
    s += (r1 - l1); t += (r0 - l0)
    if -s-L[0] <= l1-1 <= t+R[0]:
        #print(0)
        heappush(L, -l1+1-s)
        heappush(R, l1-1-t)
        # res += 0
    elif l1-1 < -s-L[0]:
        #print(1)
        heappush(L, -l1+1-s)
        heappush(L, -l1+1-s)
        p = -heappop(L)-s
        #d = (-L[0]-s) - p
        heappush(R, p-t)
        #print(d)
        #res += d
        res += (p - (l1-1))
    elif t+R[0] < l1-1:
        #print(2)
        heappush(R, l1-1-t)
        heappush(R, l1-1-t)
        p = heappop(R) + t
        #d = R[0]+t - p
        heappush(L, -p-s)
        #print(d)
        res += (l1-1 - p)
    #print(L, s, t, R, -s-L[0], R[0]+t, res)
    #debug(L, s, t, R)
print(res)
```