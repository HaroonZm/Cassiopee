Voici un énoncé de problème :

マトリョーシカ
マトリョーシカはロシアの民芸品として有名な人形である．
マトリョーシカは上下に分割でき，開くと中により小さい別の人形が入っている．
現れた小さい人形を開くとさらに小さい人形が入っている，というような入れ子構造になっている．
あなたは旅行先で珍しい形のマトリョーシカを見つけ，
N
体の人形を購入した．
i
番目の人形の形状は，
x
i
× y
i
× z
i
の直方体である．
ひとしきりマトリョーシカを鑑賞したあなたは，マトリョーシカを仕舞おうとしている．
その前に，いくつかの人形を別の人形に格納することによって必要なスペースを減らしたい．
人形を格納する際には，まだ中にひとつも人形を格納していない人形にだけ，他の人形をひとつ格納できる．
ただし，直接的に格納される人形についてだけ数えるものとし，中に人形が入っている人形を別の人形に格納することはできる．
収納された人形は，外部から見えない状態になる．
ただし，以下の条件を満たさなければならない．
人形は回転してよいが，直方体のそれぞれの辺は，他方の直方体のいずれかの辺に平行
回転後，対応する辺同士の長さそれぞれについて，収納される側の人形の長さの方が短い
1 個の人形の中に直接収納できる人形の数は高々 1 個
押入れの容積は限られているので，外部から見えている人形の体積の和を最小化したい．
あなたの仕事は，人形を収納する操作を任意の回数繰り返して達成できる，外部から見えている人形の体積の和の最小値を求めるプログラムを作成することである．
Input
入力は複数のデータセットからなる．
データセットの個数は最大でも 50 個を超えない．
各データセットは次の形式で表される．
N
x
1
y
1
z
1
:
:
x
N
y
N
z
N
各データセットは
N + 1
行からなり，データセットの 1 行目には，人形の数を表す整数
N
が与えられる．
続く
N
行の内
i
行目には，
i
番目の人形の大きさを表す 3 つの整数
x
i
, y
i
, z
i
が半角スペース区切りで与えられる．
これらの整数は，
1 ≤ N, x
i
, y
i
, z
i
≤ 100
を満たす．
入力の終わりは 1 つのゼロからなる行で表される．
Output
各データセットについて，外部から見えている人形の体積の和の最小値を 1 行で出力せよ．
Sample Input
2
1 2 3
4 2 3
3
2 5 2
3 3 4
5 5 5
5
1 1 1
2 2 2
3 3 3
4 4 4
5 5 5
5
1 1 1
2 1 1
3 1 1
4 1 1
5 1 1
10
3 1 4
1 5 9
2 6 5
3 5 8
9 7 9
3 2 3
8 4 6
2 6 4
3 3 8
3 2 7
0
Output for Sample Input
24
145
125
15
864


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
readline = sys.stdin.readline
write = sys.stdout.write

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        G = self.G
        G[fr].append([to, cap, cost, len(G[to])])
        G[to].append([fr, 0, -cost, len(G[fr])-1])

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [0]*N

        while f:
            dist = [INF]*N
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                for i, (w, cap, cost, _) in enumerate(G[v]):
                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:
                        dist[w] = r = dist[v] + cost + H[v] - H[w]
                        prv_v[w] = v; prv_e[w] = i
                        heappush(que, (r, w))
            if dist[t] == INF:
                return -1

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, G[prv_v[v]][prv_e[v]][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = G[prv_v[v]][prv_e[v]]
                e[1] -= d
                G[v][e[3]][1] += d
                v = prv_v[v]
        return res

def solve():
    N = int(readline())
    if N == 0:
        return False
    P = []
    for i in range(N):
        *p, = map(int, readline().split())
        p.sort()
        P.append(p)
    mcf = MinCostFlow(2*N+2)
    P.sort()
    su = 0
    for i in range(N):
        xi, yi, zi = P[i]
        for j in range(i):
            xj, yj, zj = P[j]
            if xi > xj and yi > yj and zi > zj:
                mcf.add_edge(2*j+1, 2*i, 1, -xj*yj*zj)
        su += xi*yi*zi
        mcf.add_edge(2*i, 2*i+1, 1, 0)
        mcf.add_edge(2*N, 2*i, 1, 0)
        mcf.add_edge(2*i+1, 2*N+1, 1, 0)
    ans = su
    for i in range(N):
        f = mcf.flow(2*N, 2*N+1, 1)
        su += f
        ans = min(ans, su)
    write("%d\n" % ans)
    return True
while solve():
    ...
```