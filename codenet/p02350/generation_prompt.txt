Voici un énoncé de problème :

RMQ and RUQ
Write a program which manipulates a sequence
A
= {
a
0
, a
1
, . . . , a
n−1
} with the following operations:
update(s, t, x)
: change
a
s
,
a
s+1
, ...,
a
t
to
x
.
find(s, t)
: report the minimum element in
a
s
,
a
s+1
, ...,
a
t
.
Note that the initial values of
a
i
(
i = 0, 1, . . . , n−1
) are 2
31
-1.
Input
n
q
query
1
query
2
:
query
q
In the first line,
n
(the number of elements in
A
) and
q
(the number of queries) are given. Then,
i
th query
query
i
is given in the following format:
0
s
t
x
or
1
s
t
The first digit represents the type of the query. '0' denotes
update(s, t, x)
and '1' denotes
find(s, t)
.
Output
For each
find
operation, print the minimum value.
Constraints
1 ≤ n ≤ 100000
1 ≤ q ≤ 100000
0 ≤ s ≤ t < n
0 ≤ x < 2
31
−1
Sample Input 1
3 5
0 0 1 1
0 1 2 3
0 2 2 2
1 0 2
1 1 2
Sample Output 1
1
2
Sample Input 2
1 3
1 0 0
0 0 0 5
1 0 0
Sample Output 2
2147483647
5


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math
from collections import deque

class SegmentTree:
    __slots__ = ["rank", "elem_size", "tree_size", "tree", "lazy", "default_value"]

    def __init__(self, a: list, default: int):
        self.default_value = default
        real_size = len(a)
        self.rank = math.ceil(math.log2(real_size))
        self.elem_size = 1 << self.rank
        self.tree_size = 2 * self.elem_size
        self.tree = [default]*self.elem_size + a + [default]*(self.elem_size - real_size)
        self.lazy = [None]*self.tree_size
        self.init_tree()

    def init_tree(self):
        tree = self.tree
        for i in range(self.elem_size-1, 0, -1):
            left, right = tree[i << 1], tree[(i << 1)+1]
            # ===== change me =====
            tree[i] = left if left < right else right

    def propagate(self, l: int, r: int, value: int = None):
        '''[x, y)'''
        tree, lazy, elem_size, rank = self.tree, self.lazy, self.elem_size, self.rank-1
        l, r, targets, p_l, p_r, l_rank, r_rank = l+elem_size, r+elem_size, deque(), 0, 0, 0, 0
        t_ap = targets.append

        while l < r:
            if l & 1:
                t_ap(l)
                p_l = p_l or l >> 1
                l_rank = l_rank or rank
                l += 1
            if r & 1:
                r -= 1
                t_ap(r)
                p_r = p_r or r >> 1
                r_rank = r_rank or rank
            l >>= 1
            r >>= 1
            rank -= 1

        deepest = (p_l, p_r)

        paths = [[p_l >> n for n in range(l_rank-1, -1, -1)], [p_r >> n for n in range(r_rank-1, -1, -1)]]

        for a in paths:
            for i in a:
                if lazy[i] is None:
                    continue
                # ===== change me =====
                tree[i] = lazy[i]
                if i < elem_size:
                    lazy[i << 1] = lazy[i]
                    lazy[(i << 1)+1] = lazy[i]
                lazy[i] = None

        result = self.default_value
        if value is None:
            for i in targets:
                if lazy[i] is not None:
                    tree[i] = lazy[i]
                    if i < elem_size:
                        lazy[i << 1] = lazy[i]
                        lazy[(i << 1)+1] = lazy[i]
                    lazy[i] = None
                # ===== change me =====
                if result > tree[i]:
                    result = tree[i]

        else:
            for i in targets:
                # ===== change me =====
                if i < elem_size:
                    lazy[i << 1] = value
                    lazy[(i << 1)+1] = value
                tree[i] = value
                lazy[i] = None

        self.update_tree(deepest)

        return result

    def update_lazy(self, l, r, value):
        self.propagate(l, r, value)

    def get_value(self, l: int, r: int):
        tree = self.tree
        targets = self.propagate(l, r)

        # ===== change me =====
        return min(tree[n] for n in targets)

    def update_tree(self, indexes: tuple):
        ''' ????????????lazy?????¨????????¬????????§???????????¨???????????¨???????????? '''

        tree, lazy = self.tree, self.lazy

        for k in indexes:
            while k > 0:
                left, right = k << 1, (k << 1)+1
                # ===== change me =====
                l_value = tree[left] if lazy[left] is None else lazy[left]
                r_value = tree[right] if lazy[right] is None else lazy[right]
                tree[k] = l_value if l_value < r_value else r_value

                k >>= 1

n, q = map(int, input().split())
rmq = SegmentTree([2**31-1]*n, 2**31-1)
ans = []
append = ans.append
for _ in [0]*q:
    l = list(map(int, input().split()))
    if l[0] == 0:
        rmq.propagate(l[1], l[2]+1, l[3])
    else:
        a = rmq.propagate(l[1], l[2]+1)
        append(a)

print("\n".join([str(n) for n in ans]))
```