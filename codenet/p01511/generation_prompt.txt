Voici un énoncé de problème :

Three-way Branch
There is a grid that consists of
W \times H
cells. The upper-left-most cell is
(1, 1)
.
You are standing on the cell of
(1,1)
and you are going to move to cell of
(W, H)
.
You can only move to adjacent lower-left, lower or lower-right cells.
There are obstructions on several cells. You can not move to it. You cannot move out the grid, either.
Write a program that outputs the number of ways to reach
(W,H)
modulo 1,000,000,009.
You can assume that there is no obstruction at
(1,1)
.
Input
The first line contains three integers, the width
W
, the height
H
, and the number of obstructions
N
.
(
1 \leq W \leq 75
,
2 \leq H \leq 10^{18}
,
0 \leq N \leq 30
)
Each of following
N
lines contains 2 integers, denoting the position of an obstruction
(x_i, y_i)
.
The last test case is followed by a line containing three zeros.
Output
For each test case, print its case number and the number of ways to reach
(W,H)
modulo 1,000,000,009.
Sample Input
2 4 1
2 1
2 2 1
2 2
0 0 0
Output for the Sample Input
Case 1: 4
Case 2: 0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import defaultdict
import sys
readline = sys.stdin.readline
write = sys.stdout.write

MOD = 10**9 + 9

def matmul(N, A, B):
    C = [[0]*N for i in range(N)]
    for i in range(N):
        for j in range(N):
            C[i][j] = sum(A[i][k] * B[k][j] for k in range(N)) % MOD
    return C

def prepare(N, H):
    mat = [[0]*N for i in range(N)]
    res = []
    for i in range(N):
        mat[i][i] = 1
    res.append([e[:] for e in mat])
    for i in range(N-1):
        mat[i][i+1] = mat[i+1][i] = 1
    res.append([e[:] for e in mat])
    while H:
        mat = matmul(N, mat, mat)
        res.append([e[:] for e in mat])
        H >>= 1
    return res
def matpow(X, N, h, MS):
    k = 1
    while h:
        if h & 1:
            mat = MS[k]
            X = [sum(ai*xi for ai, xi in zip(mat_i, X)) % MOD for mat_i in mat]
        h >>= 1
        k += 1
    return X

cnt = 1
def solve():
    W, H, N = map(int, readline().split())
    if W == H == N == 0:
        return False
    P = defaultdict(list)
    for i in range(N):
        x, y = map(int, readline().split())
        if y > 1:
            P[y-1].append(x-1)
    MS = prepare(W, H)
    *S, = P.items()
    S.sort()
    X = [0]*W
    X[0] = 1
    prv = 0
    for y, vs in S:
        X = matpow(X, W, y-prv, MS)
        for v in vs:
            X[v] = 0
        prv = y
    if prv < H-1:
        X = matpow(X, W, H-1-prv, MS)
    write("Case %d: %d\n" % (cnt, X[W-1]))
    return True
while solve():
    cnt += 1
```