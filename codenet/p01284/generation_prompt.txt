Voici un énoncé de problème :

Problem B:
Erratic Sleep Habits
Peter is a person with erratic sleep habits. He goes to sleep at twelve o'lock every midnight. He gets
up just after one hour of sleep on some days; he may even sleep for twenty-three hours on other days.
His sleeping duration changes in a cycle, where he always sleeps for only one hour on the first day of the
cycle.
Unfortunately, he has some job interviews this month. No doubt he wants to be in time for them. He can
take anhydrous caffeine to reset his sleeping cycle to the beginning of the cycle anytime. Then he will
wake up after one hour of sleep when he takes caffeine. But of course he wants to avoid taking caffeine
as possible, since it may affect his health and accordingly his very important job interviews.
Your task is to write a program that reports the minimum amount of caffeine required for Peter to attend
all his interviews without being late, where the information about the cycle and the schedule of his
interviews are given. The time for move to the place of each interview should be considered negligible.
Input
The input consists of multiple datasets. Each dataset is given in the following format:
T
t
1
t
2
...
t
T
N
D
1
M
1
D
2
M
2
...
D
N
M
N
T
is the length of the cycle (1 ≤
T
≤ 30);
t
i
(for 1 ≤
i
≤
T
) is the amount of sleep on the
i
-th day of the
cycle, given in hours (1 ≤
t
i
≤ 23);
N
is the number of interviews (1 ≤
N
≤ 100);
D
j
(for 1 ≤
j
≤
N
)
is the day of the
j
-th interview (1 ≤
D
j
≤ 100);
M
j
(for 1 ≤
j
≤
N
) is the hour when the
j
-th interview starts (1 ≤
M
j
≤ 23).
The numbers in the input are all integers.
t
1
is always 1 as stated above. The day indicated by 1 is the
first day in the cycle of Peter's sleep.
The last dataset is followed by a line containing one zero. This line is not a part of any dataset and should not be processed.
Output
For each dataset, print the minimum number of times Peter needs to take anhydrous caffeine.
Sample Input
2
1 23
3
1 1
2 1
3 1
0
Output for the Sample Input
2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

def main():
    rr = []

    while True:
        T = I()
        if T == 0:
            break
        t = LI()
        n = I()
        a = sorted([LI() for _ in range(n)])
        ad = collections.defaultdict(lambda: inf)
        for d,m in a:
            if ad[d] > m:
                ad[d] = m
        c = collections.defaultdict(lambda: inf)
        c[-1] = 0
        cd = 0
        for d in range(1,max(ad.keys()) + 1):
            m = ad[d]
            nt = 1
            nd = collections.defaultdict(lambda: inf)
            for k,v in c.items():
                if t[(k+nt) % T] <= m:
                    if nd[(k+nt) % T] > v:
                        nd[(k+nt) % T] = v
                if nd[0] > v+1:
                    nd[0] = v+1
            c = nd
            cd = d
        rr.append(min(c.values()))

    return '\n'.join(map(str,rr))

print(main())
```