En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
fin = sys.stdin.readline
from random import randint
from heapq import heappush, heappop

class Node(object):
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None

# Meldable Heap implementation
def merge(h1, h2):
    if h1 is None:
        return h2
    if h2 is None:
        return h1
    if h2.val < h1.val:
        h1, h2 = h2, h1
    if randint(0, 1):
        h1.left = merge(h1.left, h2)
        h1.left.parent = h1
    else:
        h1.right = merge(h1.right, h2)
        h1.right.parent = h1
    return h1

def push(root, x):
    u = Node(x)
    root = merge(u, root)
    root.parent = None
    return root

def pop(root):
    x = root.val
    root = merge(root.left, root.right)
    if root is not None:
        root.parent = None
    return x, root

def find_min(root):
    return root.val if root else float('inf')

def find_second_min(root):
    return min(find_min(root.left), find_min(root.right)) if root else float('inf')

INF = 2**64 - 1
N = int(fin())
w_list = [int(elem) for elem in fin().split()]

hpq = [0] * (N + 1)
mpq = []
rig = [0] * (N + 1)
cst = [0] * (N + 1)
lef = [0] * (N + 1)

for i in range(N - 1):
    hpq[i] = None
    rig[i] = i + 1
    lef[i] = i - 1
    cst[i] = w_list[i] + w_list[i + 1]
    heappush(mpq, (cst[i], i))

ans = 0
for k in range(N - 1):
    c, i = heappop(mpq)
    while rig[i] == -1 or cst[i] != c:
        c, i = heappop(mpq)
    
    ml = mr = False
    if w_list[i] + find_min(hpq[i]) == c:
        _, hpq[i] = pop(hpq[i])
        ml = True
    elif w_list[i] + w_list[rig[i]] == c:
        ml = mr = True
    elif find_min(hpq[i]) + find_second_min(hpq[i]) == c:
        _, hpq[i] = pop(pop(hpq[i])[1])
    else:
        _, hpq[i] = pop(hpq[i])
        mr = True
    
    ans += c
    hpq[i] = push(hpq[i], c)
    if ml:
        w_list[i] = INF
    if mr:
        w_list[rig[i]] = INF
    if ml and i > 0:
        j = lef[i]
        hpq[j] = merge(hpq[j], hpq[i])
        rig[j] = rig[i]
        rig[i] = -1
        lef[rig[j]] = j
        i = j
    if mr and rig[i] + 1 < N:
        j = rig[i]
        hpq[i] = merge(hpq[i], hpq[j])
        rig[i] = rig[j]
        rig[j] = -1
        lef[rig[i]] = i
    cst[i] = w_list[i] + w_list[rig[i]]
    cst[i] = min(cst[i], min(w_list[i], w_list[rig[i]]) + find_min(hpq[i]))
    cst[i] = min(cst[i], find_min(hpq[i]) + find_second_min(hpq[i]))
    heappush(mpq, (cst[i], i))

print(ans)
```