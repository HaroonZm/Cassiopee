Voici un énoncé de problème :

Problem E:
The Genome Database of All Space Life
In 2300, the Life Science Division of Federal Republic of Space starts
a very ambitious project to complete the genome sequencing of all
living creatures in the entire universe and develop the genomic
database of all space life.
Thanks to scientific research over many years, it has been known that
the genome of any species consists of at most 26 kinds of
molecules, denoted by English capital letters (
i.e.
A
to
Z
).
What will be stored into the database are plain strings consisting of
English capital letters.
In general, however, the genome sequences of space life include
frequent repetitions and can be awfully long.
So, for efficient utilization of storage, we compress
N
-times
repetitions of a letter sequence
seq
into
N
(
seq
)
, where
N
is a natural
number greater than or equal to two and the length of
seq
is at
least one.
When
seq
consists of just one letter
c
, we may omit parentheses and write
Nc
.
For example, a fragment of a genome sequence:
ABABABABXYXYXYABABABABXYXYXYCCCCCCCCCC
can be compressed into:
4(AB)XYXYXYABABABABXYXYXYCCCCCCCCCC
by replacing the first occurrence of
ABABABAB
with its compressed form.
Similarly, by replacing the following repetitions of
XY
,
AB
, and
C
, we get:
4(AB)3(XY)4(AB)3(XY)10C
Since
C
is a single letter, parentheses are omitted in this
compressed representation.
Finally, we have:
2(4(AB)3(XY))10C
by compressing the repetitions of
4(AB)3(XY)
.
As you may notice from this example, parentheses can be nested.
Your mission is to write a program that uncompress compressed genome
sequences.
Input
The input consists of multiple lines, each of which contains a
character string
s
and an integer
i
separated by a
single space.
The character string
s
, in the aforementioned manner,
represents a genome sequence.
You may assume that the length of
s
is between 1 and 100,
inclusive.
However, of course, the genome sequence represented by
s
may be
much, much, and much longer than 100.
You may also assume that each natural number in
s
representing the
number of repetitions is at most 1,000.
The integer
i
is at least zero and at most one million.
A line containing two zeros separated by a space follows the last input line and indicates
the end of the input.
Output
For each input line, your program should print a line containing the
i
-th letter in the genome sequence that
s
represents.
If the genome sequence is too short to have the
i
-th element,
it should just print a zero.
No other characters should be printed in the output lines.
Note that in this problem the index number begins from zero rather
than one and therefore the initial letter of a sequence is its zeroth element.
Sample Input
ABC 3
ABC 0
2(4(AB)3(XY))10C 30
1000(1000(1000(1000(1000(1000(NM)))))) 999999
0 0
Output for the Sample Input
0
A
C
M


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python

from collections import deque
import itertools as it
import sys

sys.setrecursionlimit(1000000)

def check(c):
    return (ord(c) >= ord('0') and ord(c) <= ord('9'))

def check2(c):
    return (ord(c) >= ord('A') and ord(c) <= ord('Z'))

while True:
    S1, S2 = raw_input().split()
    if S1 == '0':
        break
    N = int(S2)
    SS = ''
    flag = False
    for i in range(len(S1) - 1):
        SS += S1[i]
        if check(S1[i]) and not check(S1[i + 1]) and S1[i + 1] != '(':
            SS += '('
            flag = True
        elif flag:
            SS += ')'
            flag = False
    SS += S1[len(S1) - 1]
    if flag:
        SS += ')'
    S1 = '(' + SS + ')'
    for i in range(26):
        c = chr(ord('A') + i)
        S1 = S1.replace('(' + c, '("' + c)
        S1 = S1.replace(c + ')', c + '")')
        S1 = S1.replace(')' + c, ')"' + c)
        S1 = S1.replace(c + '(', c + '"(')
        for j in range(10):
            c2 = str(j)
            S1 = S1.replace(c + c2, c + '"' + c2)
    S1 = S1[1 : -1]
    S1 = S1.replace('(', ',')
    SS = ''
    for i in range(len(S1) - 1):
        SS += S1[i]
        if not check(S1[i]) and check(S1[i + 1]):
            SS += '('
    SS += S1[len(S1) - 1]
    if check(S1[0]):
        SS = '(' + SS
    S1 = '(1, ' + SS + ')'
    S1 = S1.replace(')(', '),(')
    S1 = S1.replace(')"', '),"')
    S1 = S1.replace('"(', '",(')
    hoge = eval(S1)
    ans = 0
    m = {}
    def func(obj):
        if type(obj) == type("hoge"):
            m[obj] = len(obj)
            return len(obj)
        num = obj[0]
        ret = 0
        for i in range(1, len(obj)):
            ret += num * func(obj[i])
        m[obj] = ret
        return ret

    def func2(obj, index):
        if type(obj) == type("hoge"):
            return obj[index]
        num = obj[0]
        S = m[obj]
        index %= S / num
        ret = 0
        for i in range(1, len(obj)):
            ret += m[obj[i]]
            if ret > index:
                ret -= m[obj[i]]
                return func2(obj[i], index - ret)
        return '0'
    
    func(hoge)
    if N >= m[hoge]:
        print '0'
    else:
        print func2(hoge, N)
```