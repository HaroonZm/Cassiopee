Voici un énoncé de problème :

Score :
700
points
Problem Statement
Aoki is playing with a sequence of numbers
a_{1}, a_{2}, ..., a_{N}
. Every second, he performs the following operation :
Choose a positive integer
k
. For each element of the sequence
v
, Aoki may choose to replace
v
with its remainder when divided by
k
, or do nothing with
v
. The cost of this operation is
2^{k}
(regardless of how many elements he changes).
Aoki wants to turn the sequence into
b_{1}, b_{2}, ..., b_{N}
(the order of the elements is important). Determine if it is possible for Aoki to perform this task and if yes, find the minimum cost required.
Constraints
1 \leq N \leq 50
0 \leq a_{i}, b_{i} \leq 50
All values in the input are integers.
Input
Input is given from Standard Input in the following format:
N
a_{1}
a_{2}
...
a_{N}
b_{1}
b_{2}
...
b_{N}
Output
Print the minimum cost required to turn the original sequence into
b_{1}, b_{2}, ..., b_{N}
. If the task is impossible, output
-1
instead.
Sample Input 1
3
19 10 14
0 3 4
Sample Output 1
160
Here's a possible sequence of operations :
Choose
k = 7
. Replace
19
with
5
,
10
with
3
and do nothing to
14
. The sequence is now
5, 3, 14
.
Choose
k = 5
. Replace
5
with
0
, do nothing to
3
and replace
14
with
4
. The sequence is now
0, 3, 4
.
The total cost is
2^{7} + 2^{5} = 160
.
Sample Input 2
3
19 15 14
0 0 0
Sample Output 2
2
Aoki can just choose
k = 1
and turn everything into
0
. The cost is
2^{1} = 2
.
Sample Input 3
2
8 13
5 13
Sample Output 3
-1
The task is impossible because we can never turn
8
into
5
using the given operation.
Sample Input 4
4
2 0 1 8
2 0 1 8
Sample Output 4
0
Aoki doesn't need to do anything here. The cost is
0
.
Sample Input 5
1
50
13
Sample Output 5
137438953472
Beware of overflow issues.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
N=int(input())
inf=float("inf")
dp=[[inf]*51 for i in range(51)]
for b in range(51):
  for a in range(51):
    if b==0:
      if a==0:
        dp[a][b]=0
      else:
        dp[a][b]=1
    else:
      for i in range(1,a+1):
        if a==b:
          dp[a][b]=0
        elif dp[a%i][b]<=50 or a%i==b:
          dp[a][b]=i
          break
a=[int(i) for i in input().split()]
b=[int(i) for i in input().split()]
ans=0
stack=[[a[i]] for i in range(N)]
def dfs(x):
  if x==0:
    return 
  global ans
  ans+=2**x
  for i in range(N):
    visited=[False]*51
    for j in stack[i]:
      visited[j]=True
      if not visited[j%x]:
        stack[i].append(j%x)
        visited[j%x]=True
  k=0
  for i in range(N):
    k=max(k,min([dp[j][b[i]] for j in stack[i]]))
  if k==0:
    return 
  return dfs(k)
M=max([dp[a[i]][b[i]] for i in range(N)])
if M>50:
  print(-1)
  exit()
dfs(M)
print(ans)
```