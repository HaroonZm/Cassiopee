Voici un énoncé de problème :

Problem I: Traffic Tree
Problem
それぞれ1から
N
までの番号が付いた
N
個の頂点が、
N
-1本の無向辺によって繋がれたグラフが与えられる。各頂点について、その頂点からスタートしてすべての頂点を訪れるための最短のステップ数を出力せよ。
ただし、ある頂点から1本の辺をたどって別の頂点に移動することを1ステップとする。
Input
入力は以下の形式で与えられる。
N
u
1
v
1
.
.
.
u
N−1
v
N−1
1行目に、1つの整数
N
が与えられる。
続く
N
-1行のうち
i
行目には
i
番目の辺の両端の頂点番号を表す整数
u
i
,
v
i
が空白区切りで与えられる。
Constraints
2 ≤
N
≤ 10
5
1 ≤
u
i
,
v
i
≤
N
(1 ≤
i
≤
N
-1)
u
i
≠
v
i
与えられるグラフは連結である
Output
頂点1から頂点
N
について
i
行目に頂点
i
からスタートしてすべての頂点を訪れるための最短のステップ数を出力せよ。
Sample Input 1
2
1 2
Sample Output 1
1
1
Sample Input 2
6
1 2
1 3
3 4
3 5
5 6
Sample Output 2
7
6
8
7
7
6
Sample Input2の図


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque

N = int(input())
X = [[] for i in range(N)]
for i in range(N-1):
    x, y = map(int, input().split())
    X[x-1].append(y-1)
    X[y-1].append(x-1)

P = [-1] * N
Q = deque([0])
T = []
while Q:
    i = deque.popleft(Q)
    T.append(i)
    for a in X[i]:
        if a != P[i]:
            P[a] = i
            X[a].remove(i)
            deque.append(Q, a)

BUA = [0] * N # Bottom Up : i以下をすべてまわる
BUB = [0] * N # Bottom Up : i以下をすべてまわってiに戻る
TDA = [0] * N # Top Down : iの上をすべてまわる
TDB = [0] * N # Top Down : iの上をすべてまわってiに戻る
for i in T[::-1]:
    if len(X[i]) == 0:
        BUA[i] = 0
        BUB[i] = 0
        continue
    s = 0
    ma = 0
    for j in X[i]:
        s += BUB[j] + 2
        ma = max(ma, BUB[j] - BUA[j] + 1)
    BUA[i] = s - ma
    BUB[i] = s

for i in T:
    B = [0] * (len(X[i]) + 1)
    C = [0] * (len(X[i]) + 1)
    for k, j in enumerate(X[i]):
        B[k+1] = B[k] + BUB[j] + 2
        C[k+1] = max(C[k], BUB[j] - BUA[j] + 2)
    s = 0
    ma = 0
    for k in range(len(X[i]))[::-1]:
        j = X[i][k]
        TDB[j] = TDB[i] + s + B[k] + 2
        TDA[j] = min(TDB[j] - max(ma, C[k]), TDA[i] + s + B[k] + 1)
        s += BUB[j] + 2
        ma = max(ma, BUB[j] - BUA[j] + 2)

for t in [min(a+d, b+c) for a, b, c, d in zip(BUA, BUB, TDA, TDB)]:
    print(t)
```