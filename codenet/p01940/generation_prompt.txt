Voici un énoncé de problème :

C： たったひとつの部分列 - Unique Subsequence -
問題
ある日えびちゃんは、机の上に長さ
n
のテキスト文字列
T
と長さ
m
のパターン文字列
P
(
m \leq n
) が置かれていることに気づきました。えびちゃんは、文字列に現れる「たったひとつの部分列」が大好きであるため、
P
が
T
のたったひとつの部分列であるかどうかをすぐに調査し始めました。
P
が
T
のたったひとつの部分列であるという性質は以下のように表されます。ここで、文字列
X
の
i
文字目を
X_i
と書きます。
長さ
m
の数列
S = (s_1, ..., s_m)
(ただし、
s_1 < s_2 < ... < s_m
) で、各
i
(
i = 1, ..., m
) について
T_{s_i} = P_i
である数列
S
が一意に定まる。
調査を始めてから数時間、えびちゃんは文字列をぐっと睨んでいましたが、文字列が長すぎるために疲れてしまったようです。それを見かねたあなたは、えびちゃんを手伝ってあげることにしました。えびちゃんのために、
P
が
T
のたったひとつの部分列であるならば “yes” を、そうでないならば “no” を出力するプログラムを作成してください。
入力形式
T
P
1
行目には、テキスト文字列
T
が与えられる。
2
行目には、パターン文字列
P
が与えられる。
制約
1 \leq |P| \leq |T| \leq 5 \times 10^5
T
および
P
は英字小文字 ‘a’-’z’ で構成される。
出力形式
P
が
T
のたったひとつの部分列であるならば “yes” を、そうでないならば “no” を1行に出力してください。
入力例1
aizucamp
azu
出力例1
yes
入力例2
abracadabra
rada
出力例2
no
入力例3
hokkaido
dekai
出力例3
no


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
t = input()
p = input()

ok = 1
result1 = [0] * len(p); idx = 0
for i, c in enumerate(t):
    if idx < len(p) and c == p[idx]:
        result1[idx] = i
        idx += 1
if idx < len(p):
    ok = 0
result2 = [0] * len(p); idx = len(p)-1
for i in range(len(t)-1, -1, -1):
    c = t[i]
    if idx >= 0 and c == p[idx]:
        result2[idx] = i
        idx -= 1
if idx >= 0:
    ok = 0
if ok and result1 == result2:
    print("yes")
else:
    print("no")
```