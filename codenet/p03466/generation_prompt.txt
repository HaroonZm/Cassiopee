Voici un énoncé de problème :

Score :
1100
points
Problem Statement
Let
f(A, B)
, where
A
and
B
are positive integers, be the string satisfying the following conditions:
f(A, B)
has length
A + B
;
f(A, B)
contains exactly
A
letters
A
and exactly
B
letters
B
;
The length of the longest substring of
f(A, B)
consisting of equal letters (ex.,
AAAAA
or
BBBB
) is as small as possible under the conditions above;
f(A, B)
is the lexicographically smallest string satisfying the conditions above.
For example,
f(2, 3)
=
BABAB
, and
f(6, 4)
=
AABAABAABB
.
Answer
Q
queries: find the substring of
f(A_i, B_i)
from position
C_i
to position
D_i
(1-based).
Constraints
1 \leq Q \leq 10^3
1 \leq A_i, B_i \leq 5 \times 10^8
1 \leq C_i \leq D_i \leq A_i + B_i
D_i - C_i + 1 \leq 100
All input values are integers.
Partial Score
500
points will be awarded for passing the testset satisfying
1 \leq A_i, B_i \leq 10^3
.
Input
Input is given from Standard Input in the following format:
Q
A_1
B_1
C_1
D_1
A_2
B_2
C_2
D_2
:
A_Q
B_Q
C_Q
D_Q
Output
For each query
i
in order of input, print a line containing the substring of
f(A_i, B_i)
from position
C_i
to position
D_i
(1-based).
Sample Input 1
5
2 3 1 5
6 4 1 10
2 3 4 4
6 4 3 7
8 10 5 8
Sample Output 1
BABAB
AABAABAABB
A
BAABA
ABAB


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
import numpy as np
import numba
from numba import njit, b1, i4, i8
from numba.types import Omitted

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

@njit((i8, i8), cache=True)
def find_min_length(a, b):
    if a < b:
        a, b = b, a
    return (a + b) // (b + 1)

@njit((i8, i8, i8, i8), cache=True)
def f(a, b, c, d):
    L = find_min_length(a, b)
    ret = ''

    def test(a, b, L):
        # ...B の直後に A を a 個、B を b 個置けるかどうか
        ok = a >= 0 and b >= 0
        if a == 0:
            ok = ok and (b <= L - 1)
        else:
            ok = ok and (a <= L * (b + 1))
            ok = ok and (1 + b <= L * (a + 1))
        return ok

    def add(s, x, t, y, n):
        # 文字列に (s*x + t*y)*n を追加
        nonlocal c, d, ret
        if (x + y) * n < c:
            c -= (x + y) * n
            d -= (x + y) * n
            return
        m = (c - 1) // (x + y)
        c -= m * (x + y)
        d -= m * (x + y)
        n -= m
        while n and c <= d:
            if d <= x:
                ret += s * (d - c + 1)
                d = 0
                return
            if 1 <= c <= x:
                ret += s * (x - c + 1)
                c = x + 1
            ret += t * (min(d, x + y) - c + 1)
            c = 1
            d -= x + y
            n -= 1

    # AAABAAAB と n セット並べてしまって大丈夫かどうか
    l, r = 0, b + 100
    while l + 1 < r:
        m = (l + r) >> 1
        a1, b1 = a - L * m, b - m
        if test(a1, b1, L):
            l = m
        else:
            r = m
    n = l
    flag = n == 0
    add('A', L, 'B', 1, n)
    a -= L * n
    b -= n
    # 次に、A^kB
    l, r = 0, L
    while l + 1 < r:
        m = (l + r) // 2
        if test(a - m, b - 1, L):
            l = m
        else:
            r = m
    k = l
    flag = flag and k == 0
    if k:
        add('A', k, 'B', 1, 1)
        a -= k
        b -= 1
    # 以降は、Aは高々ひとつずつ
    if not a:
        add('B', b, 'A', 0, 1)
        return ret
    if not b:
        add('A', a, 'B', 0, 1)
        return ret

    # B^kA、kはなるべく少なく
    l, r = -1, L - 1
    if flag:
        r = L
    while l + 1 < r:
        m = (l + r) // 2
        if test(a, b - m, L) and b - m <= a * L:
            r = m
        else:
            l = m
    k = r

    if k >= 0:
        add('B', k, 'A', 1, 1)
        a -= 1
        b -= k
    # B^LA をいくつか
    n = min(b // L, a)
    add('B', L, 'A', 1, n)
    a -= n
    b -= n * L
    add('B', b, 'A', 0, 1)
    add('B', 0, 'A', a, 1)
    return ret

ABCD = np.array(read().split(), np.int64)[1:]

for a, b, c, d in ABCD.reshape(-1, 4):
    print(f(a, b, c, d))
```