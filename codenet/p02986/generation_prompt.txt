Voici un énoncé de problème :

Score :
600
points
Problem Statement
There is a tree with
N
vertices numbered
1
to
N
.
The
i
-th edge in this tree connects Vertex
a_i
and Vertex
b_i
, and the color and length of that edge are
c_i
and
d_i
, respectively.
Here the color of each edge is represented by an integer between
1
and
N-1
(inclusive). The same integer corresponds to the same color, and different integers correspond to different colors.
Answer the following
Q
queries:
Query
j
(
1 \leq j \leq Q
): assuming that the length of every edge whose color is
x_j
is changed to
y_j
, find the distance between Vertex
u_j
and Vertex
v_j
. (The changes of the lengths of edges do not affect the subsequent queries.)
Constraints
2 \leq N \leq 10^5
1 \leq Q \leq 10^5
1 \leq a_i, b_i \leq N
1 \leq c_i \leq N-1
1 \leq d_i \leq 10^4
1 \leq x_j \leq N-1
1 \leq y_j \leq 10^4
1 \leq u_j < v_j \leq N
The given graph is a tree.
All values in input are integers.
Input
Input is given from Standard Input in the following format:
N
Q
a_1
b_1
c_1
d_1
:
a_{N-1}
b_{N-1}
c_{N-1}
d_{N-1}
x_1
y_1
u_1
v_1
:
x_Q
y_Q
u_Q
v_Q
Output
Print
Q
lines. The
j
-th line (
1 \leq j \leq Q
) should contain the answer to Query
j
.
Sample Input 1
5 3
1 2 1 10
1 3 2 20
2 4 4 30
5 2 1 40
1 100 1 4
1 100 1 5
3 1000 3 4
Sample Output 1
130
200
60
The graph in this input is as follows:
Here the edges of Color
1
are shown as solid red lines, the edge of Color
2
is shown as a bold green line, and the edge of Color
4
is shown as a blue dashed line.
Query
1
: Assuming that the length of every edge whose color is
1
is changed to
100
, the distance between Vertex
1
and Vertex
4
is
100 + 30 = 130
.
Query
2
: Assuming that the length of every edge whose color is
1
is changed to
100
, the distance between Vertex
1
and Vertex
5
is
100 + 100 = 200
.
Query
3
: Assuming that the length of every edge whose color is
3
is changed to
1000
(there is no such edge), the distance between Vertex
3
and Vertex
4
is
20 + 10 + 30 = 60
. Note that the edges of Color
1
now have their original lengths.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
input = sys.stdin.readline

N,Q=map(int,input().split())
EDGE=[list(map(int,input().split())) for i in range(N-1)]
Query=[list(map(int,input().split())) for i in range(Q)]
mod=10**9+7

EDGELIST=[dict() for i in range(N+1)]
for x,y,c,l in EDGE:
    EDGELIST[x][y]=(c,l)
    EDGELIST[y][x]=(c,l)
    
# LCA(オイラーツアー＋Segment tree)

DEPTH=[-1]*(N+1)
DEPTH[1]=0

from collections import deque
QUE = deque([1])
QUE2 = deque()
EULER=[]#(i,j)で,(1からツアーで辿った点の深さ,そのindex)

USED=[0]*(N+1)
while QUE:
    x=QUE.pop()
    EULER.append((DEPTH[x],x))
    if USED[x]==1:
        continue
    for to in EDGELIST[x]:
        
        if USED[to]==0:
            DEPTH[to]=DEPTH[x]+1
            QUE2.append(to)
        else:
            QUE.append(to)
    QUE.extend(QUE2)
    QUE2=deque()
 
    USED[x]=1

MINP=[1<<30]*(N+1)
MAXP=[-1]*(N+1)

for ind,(depth,p) in enumerate(EULER):
    MINP[p]=min(MINP[p],ind)
    MAXP[p]=max(MAXP[p],ind)

LEN=len(EULER)

seg_el=1<<(LEN.bit_length())#Segment treeの台の要素数
SEG=[(1<<30,0)]*(2*seg_el)#1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化

for i in range(LEN):#Dを対応する箇所へupdate
    SEG[i+seg_el]=EULER[i]

for i in range(seg_el-1,0,-1):#親の部分もupdate
    SEG[i]=min(SEG[i*2],SEG[i*2+1])

def update(n,x,seg_el):#A[n]をxへ更新（反映）
    i=n+seg_el
    SEG[i]=x
    i>>=1#子ノードへ
    
    while i!=0:
        SEG[i]=min(SEG[i*2],SEG[i*2+1])
        i>>=1
        
def getvalues(l,r):#区間[l,r)に関するminを調べる
    L=l+seg_el
    R=r+seg_el
    ANS=(1<<30,0)

    while L<R:
        if L & 1:
            ANS=min(ANS , SEG[L])
            L+=1

        if R & 1:
            R-=1
            ANS=min(ANS , SEG[R])
        L>>=1
        R>>=1

    return ANS

def LCA(l,r):
    return getvalues(min(MINP[l],MINP[r]),max(MAXP[l],MAXP[r])+1)

check=[set() for i in range(N+1)]
for c,l,x,y in Query:
    check[x].add(c)
    check[y].add(c)
    check[LCA(x,y)[1]].add(c)

LENGTH=[0]*(N+1)
LENG=0
C_LENGTH=[0]*N
C_SUM=[0]*N
C_LDICT=dict()
C_SDICT=dict()

for c in check[1]:
    C_LDICT[(1,c)]=0
    C_SDICT[(1,c)]=0
    

for i in range(1,len(EULER)):
    ind=EULER[i][1]
    c,l=EDGELIST[EULER[i-1][1]][ind]
    if EULER[i][0]>EULER[i-1][0]:
        LENG+=l
        C_LENGTH[c]+=l
        C_SUM[c]+=1

        LENGTH[ind]=LENG

        for c in check[ind]:
            C_LDICT[(ind,c)]=C_LENGTH[c]
            C_SDICT[(ind,c)]=C_SUM[c]
            

    else:
        LENG-=l
        C_LENGTH[c]-=l
        C_SUM[c]-=1
        
        
for c,pl,x,y in Query:
    ind=LCA(x,y)[1]
    print(LENGTH[x]+LENGTH[y]-LENGTH[ind]*2+(C_SDICT[x,c]+C_SDICT[y,c]-C_SDICT[ind,c]*2)*pl-(C_LDICT[x,c]+C_LDICT[y,c]-C_LDICT[ind,c]*2))
```