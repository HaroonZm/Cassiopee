Voici un énoncé de problème :

Score :
100
points
Problem Statement
There is a set
A = \{ a_1, a_2, \ldots, a_N \}
consisting of
N
positive integers.
Taro and Jiro will play the following game against each other.
Initially, we have a pile consisting of
K
stones.
The two players perform the following operation alternately, starting from Taro:
Choose an element
x
in
A
, and remove exactly
x
stones from the pile.
A player loses when he becomes unable to play.
Assuming that both players play optimally, determine the winner.
Constraints
All values in input are integers.
1 \leq N \leq 100
1 \leq K \leq 10^5
1 \leq a_1 < a_2 < \cdots < a_N \leq K
Input
Input is given from Standard Input in the following format:
N
K
a_1
a_2
\ldots
a_N
Output
If Taro will win, print
First
; if Jiro will win, print
Second
.
Sample Input 1
2 4
2 3
Sample Output 1
First
If Taro removes three stones, Jiro cannot make a move.
Thus, Taro wins.
Sample Input 2
2 5
2 3
Sample Output 2
Second
Whatever Taro does in his operation, Jiro wins, as follows:
If Taro removes two stones, Jiro can remove three stones to make Taro unable to make a move.
If Taro removes three stones, Jiro can remove two stones to make Taro unable to make a move.
Sample Input 3
2 7
2 3
Sample Output 3
First
Taro should remove two stones. Then, whatever Jiro does in his operation, Taro wins, as follows:
If Jiro removes two stones, Taro can remove three stones to make Jiro unable to make a move.
If Jiro removes three stones, Taro can remove two stones to make Jiro unable to make a move.
Sample Input 4
3 20
1 2 3
Sample Output 4
Second
Sample Input 5
3 21
1 2 3
Sample Output 5
First
Sample Input 6
1 100000
1
Sample Output 6
Second


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n, k = map(int, input().split())
a = tuple(map(int, input().split()))

dp = [None] * (k + k + 1)
# dp[手番の石の数] := 手番の勝敗
# True(勝ち) / None(負け)

for opponent_remains in range(k):  # 自分が石を取った残りなので、k未満
    if dp[opponent_remains] is None:  # 相手が負ける場合
        for my_take in a:  # 自分が取る石の数
            my_remains = opponent_remains + my_take  # 相手が負けるようにできる、自分の手番の石の数
            dp[my_remains] = True

ans = dp[k]
print('First' if ans else 'Second')
```