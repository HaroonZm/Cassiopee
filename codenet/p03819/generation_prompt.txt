Voici un énoncé de problème :

Score :
700
points
Problem Statement
Snuke has decided to play a game, where the player runs a railway company.
There are
M+1
stations on Snuke Line, numbered
0
through
M
.
A train on Snuke Line stops at station
0
and every
d
-th station thereafter, where
d
is a predetermined constant for each train.
For example, if
d = 3
, the train stops at station
0
,
3
,
6
,
9
, and so forth.
There are
N
kinds of souvenirs sold in areas around Snuke Line. The
i
-th kind of souvenirs can be purchased when the train stops at one of the following stations: stations
l_i
,
l_i+1
,
l_i+2
,
...
,
r_i
.
There are
M
values of
d
, the interval between two stops, for trains on Snuke Line:
1
,
2
,
3
,
...
,
M
.
For each of these
M
values, find the number of the kinds of souvenirs that can be purchased if one takes a train with that value of
d
at station
0
.
Here, assume that it is not allowed to change trains.
Constraints
1 ≦ N ≦ 3 × 10^{5}
1 ≦ M ≦ 10^{5}
1 ≦ l_i ≦ r_i ≦ M
Input
The input is given from Standard Input in the following format:
N
M
l_1
r_1
:
l_{N}
r_{N}
Output
Print the answer in
M
lines. The
i
-th line should contain the maximum number of the kinds of souvenirs that can be purchased if one takes a train stopping every
i
-th station.
Sample Input 1
3 3
1 2
2 3
3 3
Sample Output 1
3
2
2
If one takes a train stopping every station, three kinds of souvenirs can be purchased: kind
1
,
2
and
3
.
If one takes a train stopping every second station, two kinds of souvenirs can be purchased: kind
1
and
2
.
If one takes a train stopping every third station, two kinds of souvenirs can be purchased: kind
2
and
3
.
Sample Input 2
7 9
1 7
5 9
5 7
5 9
1 1
6 8
3 4
Sample Output 2
7
6
6
5
4
5
5
3
2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys
def input():
    return sys.stdin.readline()[:-1]

N, M = map(int, input().split())
L = []
for i in range(N):
    l, r = map(int, input().split())
    L.append((r - l + 1, l, r + 1))
L.sort()

class Bit:
    """
    0-indexed
    # 使用例
    bit = Bit(10)  # 要素数
    bit.add(2, 10)
    print(bit.sum(5))  # 10
    """

    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)

    def sum(self, i):
        # [0, i) の要素の総和を返す
        if not (0 <= i <= self.size): raise ValueError("error!")
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def add(self, i, x):
        if not (0 <= i < self.size): raise ValueError("error!")
        i += 1
        while i <= self.size:
            self.tree[i] += x
            i += i & -i

class BitImos:
    """
    ・範囲すべての要素に加算
    ・ひとつの値を取得
    の2種類のクエリをO(logn)で処理
    """

    def __init__(self, n):
        self.bit = Bit(n + 1)

    def add(self, s, t, x):
        # [s, t)にxを加算
        self.bit.add(s, x)
        self.bit.add(t, -x)

    def get(self, i):
        return self[i]

    def __getitem__(self, key):
        # 位置iの値を取得
        return self.bit.sum(key + 1)

imos = BitImos(M + 1)
il = 0
a = N
for i in range(1, M + 1):
    while il < N:
        ra, l, r = L[il]
        if i < ra:
            break
        il += 1
        a -= 1
        imos.add(l, r, 1)
    ans = 0
    for j in range(i, M + 1, i):
        ans += imos[j]

    print(ans + a)
```