Voici un énoncé de problème :

Score :
400
points
Problem Statement
Akari has
n
kinds of flowers, one of each kind.
She is going to choose one or more of these flowers to make a bouquet.
However, she hates two numbers
a
and
b
, so the number of flowers in the bouquet cannot be
a
or
b
.
How many different bouquets are there that Akari can make?
Find the count modulo
(10^9 + 7)
.
Here, two bouquets are considered different when there is a flower that is used in one of the bouquets but not in the other bouquet.
Constraints
All values in input are integers.
2 \leq n \leq 10^9
1 \leq a < b \leq \textrm{min}(n, 2 \times 10^5)
Input
Input is given from Standard Input in the following format:
n
a
b
Output
Print the number of bouquets that Akari can make, modulo
(10^9 + 7)
. (If there are no such bouquets, print
0
.)
Sample Input 1
4 1 3
Sample Output 1
7
In this case, Akari can choose
2
or
4
flowers to make the bouquet.
There are
6
ways to choose
2
out of the
4
flowers, and
1
way to choose
4
, so there are a total of
7
different bouquets that Akari can make.
Sample Input 2
1000000000 141421 173205
Sample Output 2
34076506
Print the count modulo
(10^9 + 7)
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from functools import *
import sys
sys.setrecursionlimit(100000)

def acinput():
    return list(map(int, input().split(" ")))

def II():
    return int(input())
mod = 10**9+7

def factorial(n):
    fact = 1
    for integer in range(1, n + 1):
        fact *= integer
    return fact

def cmb2(n, r):
    if n - r < r:
        r = n - r
    if r == 0:
        return 1
    if r == 1:
        return n

    numerator = [n - r + k + 1 for k in range(r)]
    denominator = [k + 1 for k in range(r)]

    for p in range(2, r+1):
        pivot = denominator[p - 1]
        if pivot > 1:
            offset = (n - r) % p
            for k in range(p-1, r, p):
                numerator[k - offset] /= pivot
                denominator[k] /= pivot

    result = 1
    for k in range(r):
        if numerator[k] > 1:
            result *= int(numerator[k])

    return int(result)

    return count

def egcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, y, x = egcd(b % a, a)
        return g, x - (b // a) * y, y
    
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
    
def combination(n, r, mod=10**9+7):
    r = min(r, n-r)
    res = 1
    for i in range(r):
        res = res * (n - i) * modinv(i+1, mod) % mod
    return res

def modpow(a, n, mod):
    res = 1
    while n > 0:
        #print(n)

        if n & 1:
            res = res*a % mod
        a = a*a % mod
            #n >>= 1
        n>>=1

    return res

n,a,b=acinput()

#print(combination(n,a))
c=combination(n,min(n,n-a))+combination(n,min(b,n-b))

print((modpow(2,n,mod)-c-1)%mod)
```