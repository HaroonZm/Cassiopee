En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from functools import *
import sys
sys.setrecursionlimit(100000)

def acinput():
    return list(map(int, input().split(" ")))

def II():
    return int(input())
mod = 10**9+7

def factorial(n):
    fact = 1
    for integer in range(1, n + 1):
        fact *= integer
    return fact

def cmb2(n, r):
    if n - r < r:
        r = n - r
    if r == 0:
        return 1
    if r == 1:
        return n

    numerator = [n - r + k + 1 for k in range(r)]
    denominator = [k + 1 for k in range(r)]

    for p in range(2, r+1):
        pivot = denominator[p - 1]
        if pivot > 1:
            offset = (n - r) % p
            for k in range(p-1, r, p):
                numerator[k - offset] /= pivot
                denominator[k] /= pivot

    result = 1
    for k in range(r):
        if numerator[k] > 1:
            result *= int(numerator[k])

    return int(result)

    return count

def egcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, y, x = egcd(b % a, a)
        return g, x - (b // a) * y, y
    
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
    
def combination(n, r, mod=10**9+7):
    r = min(r, n-r)
    res = 1
    for i in range(r):
        res = res * (n - i) * modinv(i+1, mod) % mod
    return res

def modpow(a, n, mod):
    res = 1
    while n > 0:
        #print(n)

        if n & 1:
            res = res*a % mod
        a = a*a % mod
            #n >>= 1
        n>>=1

    return res

n,a,b=acinput()

#print(combination(n,a))
c=combination(n,min(n,n-a))+combination(n,min(b,n-b))

print((modpow(2,n,mod)-c-1)%mod)
```