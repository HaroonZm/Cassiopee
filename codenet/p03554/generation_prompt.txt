Voici un énoncé de problème :

Score :
1000
points
Problem Statement
You are given a sequence
a = \{a_1, ..., a_N\}
with all zeros, and a sequence
b = \{b_1, ..., b_N\}
consisting of
0
and
1
. The length of both is
N
.
You can perform
Q
kinds of operations. The
i
-th operation is as follows:
Replace each of
a_{l_i}, a_{l_i + 1}, ..., a_{r_i}
with
1
.
Minimize the hamming distance between
a
and
b
, that is, the number of
i
such that
a_i \neq b_i
, by performing some of the
Q
operations.
Constraints
1 \leq N \leq 200,000
b
consists of
0
and
1
.
1 \leq Q \leq 200,000
1 \leq l_i \leq r_i \leq N
If
i \neq j
, either
l_i \neq l_j
or
r_i \neq r_j
.
Input
Input is given from Standard Input in the following format:
N
b_1
b_2
...
b_N
Q
l_1
r_1
l_2
r_2
:
l_Q
r_Q
Output
Print the minimum possible hamming distance.
Sample Input 1
3
1 0 1
1
1 3
Sample Output 1
1
If you choose to perform the operation,
a
will become
\{1, 1, 1\}
, for a hamming distance of
1
.
Sample Input 2
3
1 0 1
2
1 1
3 3
Sample Output 2
0
If both operations are performed,
a
will become
\{1, 0, 1\}
, for a hamming distance of
0
.
Sample Input 3
3
1 0 1
2
1 1
2 3
Sample Output 3
1
Sample Input 4
5
0 1 0 1 0
1
1 5
Sample Output 4
2
It may be optimal to perform no operation.
Sample Input 5
9
0 1 0 1 1 1 0 1 0
3
1 4
5 8
6 7
Sample Output 5
3
Sample Input 6
15
1 1 0 0 0 0 0 0 1 0 1 1 1 0 0
9
4 10
13 14
1 7
4 14
9 11
2 6
7 8
3 12
7 13
Sample Output 6
5
Sample Input 7
10
0 0 0 1 0 0 1 1 1 0
7
1 4
2 5
1 3
6 7
9 9
1 5
7 9
Sample Output 7
1


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
n=int(input())
b=list(map(int,input().split()))
ope=[[] for i in range(n)]
Q=int(input())
for i in range(Q):
    l,r=map(int,input().split())
    ope[r-1].append(l-1)

res=b.count(0)

Data=[(-1)**((b[i]==1)+1) for i in range(n)]
for i in range(1,n):
    Data[i]+=Data[i-1]
Data=[0]+Data

for i in range(n):
    ope[i].sort(reverse=True)

# N: 処理する区間の長さ
N=n+1
N0 = 2**(N-1).bit_length()
data = [None]*(2*N0)
INF = (-2**31, -2**31)
# 区間[l, r+1)の値をvに書き換える
# vは(t, value)という値にする (新しい値ほどtは大きくなる)
def update(l, r, v):
    L = l + N0; R = r + N0
    while L < R:
        if R & 1:
            R -= 1
            if data[R-1]:
                data[R-1] = max(v,data[R-1])
            else:
                data[R-1]=v

        if L & 1:
            if data[L-1]:
                data[L-1] = max(v,data[L-1])
            else:
                data[L-1]=v
            L += 1
        L >>= 1; R >>= 1
# a_iの現在の値を取得
def _query(k):
    k += N0-1
    s = INF
    while k >= 0:
        if data[k]:
            s = max(s, data[k])
        k = (k - 1) // 2
    return s
# これを呼び出す
def query(k):
    return _query(k)[1]

for i in range(n+1):
    update(i,i+1,(-Data[i],-Data[i]))
if ope[0]:
    update(1,2,(0,0))

for i in range(1,n):
    val=query(i)
    update(i+1,i+2,(val+Data[i]-Data[i+1],val+Data[i]-Data[i+1]))
    for l in ope[i]:
        val=query(l)
        update(l+1,i+2,(val,val))

print(n-(res+query(n)+Data[n]))
```