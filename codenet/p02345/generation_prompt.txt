Voici un énoncé de problème :

Range Minimum Query (RMQ)
Write a program which manipulates a sequence
A
= {
a
0
, a
1
, . . . , a
n-1
} with the following operations:
find(s, t)
: report the minimum element in
a
s
, a
s+1
, . . . ,a
t
.
update(i, x)
: change
a
i
to
x
.
Note that the initial values of
a
i
(
i = 0, 1, . . . , n−1
) are 2
31
-1.
Input
n
q
com
0
x
0
y
0
com
1
x
1
y
1
...
com
q−1
x
q−1
y
q−1
In the first line,
n
(the number of elements in
A
) and
q
(the number of queries) are given. Then,
q
queries are given where
com
represents the type of queries. '0' denotes
update(x
i
, y
i
)
and '1' denotes
find(x
i
, y
i
)
.
Output
For each
find
operation, print the minimum element.
Constraints
1 ≤ n ≤ 100000
1 ≤ q ≤ 100000
If
com
i
is 0, then
0 ≤ x
i
< n
,
0 ≤ y
i
< 2
31
-1
.
If
com
i
is 1, then
0 ≤ x
i
< n
,
0 ≤ y
i
< n
.
Sample Input 1
3 5
0 0 1
0 1 2
0 2 3
1 0 2
1 1 2
Sample Output 1
1
2
Sample Input 2
1 3
1 0 0
0 0 5
1 0 0
Sample Output 2
2147483647
5


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/python3
import math

# main
n, q = map(int, input().split())
b_size = math.ceil(math.sqrt(n))
b_len = math.ceil(n/b_size)
a = [2 ** 31 - 1 for i in range(n)]
b = [min(a[b_size * i:b_size * (i + 1)]) for i in range(b_len)]
for i in range(q):
    com, x, y = map(int, input().split())
    if com == 0:
        # update
        a[x] = y
        # update b
        index = x // b_size
        b[index] = min(a[index * b_size:(index + 1) * b_size])

    else:
        # find
        target = []
        x_index = x // b_size
        y_index = y // b_size
        x_mod = x % b_size
        y_mod = y % b_size
        if x_index == y_index:
            target.extend(a[x:y + 1])
        else:
            if x_mod == 0:
                target.append(b[x_index])
            else:
                target.extend(a[x:(x_index + 1) * b_size])

            if y_mod == b_size - 1:
                target.append(b[y_index])
            else:
                target.extend(a[y_index * b_size:y + 1])

            if x_index + 1 <= y_index - 1:
                target.append(min(b[x_index + 1 : y_index]))
        print(min(target))
```