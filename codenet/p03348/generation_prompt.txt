Voici un énoncé de problème :

Score :
1100
points
Problem Statement
Coloring of the vertices of a tree
G
is called a
good coloring
when, for every pair of two vertices
u
and
v
painted in the same color, picking
u
as the root and picking
v
as the root would result in isomorphic rooted trees.
Also, the
colorfulness
of
G
is defined as the minimum possible number of different colors used in a good coloring of
G
.
You are given a tree with
N
vertices. The vertices are numbered
1
through
N
, and the
i
-th edge connects Vertex
a_i
and Vertex
b_i
. We will construct a new tree
T
by repeating the following operation on this tree some number of times:
Add a new vertex to the tree by connecting it to one of the vertices in the current tree with an edge.
Find the minimum possible colorfulness of
T
.
Additionally, print the minimum number of leaves (vertices with degree
1
) in a tree
T
that achieves the minimum colorfulness.
Notes
The phrase "picking
u
as the root and picking
v
as the root would result in isomorphic rooted trees" for a tree
G
means that there exists a bijective function
f_{uv}
from the vertex set of
G
to itself such that both of the following conditions are met:
f_{uv}(u)=v
For every pair of two vertices
(a,b)
, edge
(a,b)
exists if and only if edge
(f_{uv}(a),f_{uv}(b))
exists.
Constraints
2 \leq N \leq 100
1 \leq a_i,b_i \leq N(1\leq i\leq N-1)
The given graph is a tree.
Input
Input is given from Standard Input in the following format:
N
a_1
b_1
:
a_{N-1}
b_{N-1}
Output
Print two integers with a space in between.
First, print the minimum possible colorfulness of a tree
T
that can be constructed.
Second, print the minimum number of leaves in a tree that achieves it.
It can be shown that, under the constraints of this problem, the values that should be printed fit into
64
-bit signed integers.
Sample Input 1
5
1 2
2 3
3 4
3 5
Sample Output 1
2 4
If we connect a new vertex
6
to vertex
2
, painting the vertices
(1,4,5,6)
red and painting the vertices
(2,3)
blue is a good coloring.
Since painting all the vertices in a single color is not a good coloring, we can see that the colorfulness of this tree is
2
.
This is actually the optimal solution. There are four leaves, so we should print
2
and
4
.
Sample Input 2
8
1 2
2 3
4 3
5 4
6 7
6 8
3 6
Sample Output 2
3 4
Sample Input 3
10
1 2
2 3
3 4
4 5
5 6
6 7
3 8
5 9
3 10
Sample Output 3
4 6
Sample Input 4
13
5 6
6 4
2 8
4 7
8 9
3 2
10 4
11 10
2 4
13 10
1 8
12 1
Sample Output 4
4 12


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import deque
from functools import reduce
from itertools import zip_longest
from operator import mul

def dfs(links):
    q = deque([(v, 0) for v in links[0]])
    v = 0
    while q:
        v, a = q.popleft()
        q.extend((u, v) for u in links[v] if u != a)

    anc = [-1] * len(links)
    q = deque([(u, v) for u in links[v]])
    u = 0, 0
    while q:
        u, a = q.popleft()
        anc[u] = a
        q.extend((w, u) for w in links[u] if w != a)

    path = [u]
    a = u
    while a != v:
        a = anc[a]
        path.append(a)
    return path

def calc(links, v, a, l):
    ans = [1] * l
    q = deque([(u, v, 1) for u in links[v] if u != a])
    ans[0] = len(q)
    while q:
        u, a, c = q.popleft()
        ans[c] = max(ans[c], len(links[u]) - 1)
        q.extend((w, u, c + 1) for w in links[u] if w != a)
    return ans

def solve(n, links):
    if n == 2:
        return 1, 2

    path = dfs(links)
    c = len(path)
    l = (len(path) + 1) // 2
    # print('path', path)

    if c % 2 == 0:
        u, v = path[c // 2 - 1], path[c // 2]
        ans1 = calc(links, u, v, l)
        ans2 = calc(links, v, u, l)
        # print('ans12', ans1, ans2)
        leaves = 1
        for a1, a2 in zip(ans1, ans2):
            leaves *= max(a1, a2)
        return len(ans1), leaves * 2
    v = path[c // 2]
    ans0 = calc(links, v, None, l)
    leaves = reduce(mul, ans0, 1)
    # print('ans0', ans0, leaves)
    for u in links[v]:
        ans1 = calc(links, u, v, l)
        ans2 = calc(links, v, u, l)
        tmp = 1
        for a1, a2 in zip_longest(ans1, ans2):
            tmp *= max(a1, a2)
        # print('ans12', ans1, ans2, tmp)
        leaves = min(leaves, tmp * 2)
    return len(ans0), leaves

n = int(input())
links = [set() for _ in range(n)]
for _ in range(n - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    links[a].add(b)
    links[b].add(a)
print(*solve(n, links))
```