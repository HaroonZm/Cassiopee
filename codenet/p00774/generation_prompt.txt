Voici un énoncé de problème :

Chain Disappearance Puzzle
We are playing a puzzle.
An upright board with
H
rows by 5 columns of cells, as shown in
the figure below, is used in this puzzle.
A stone engraved with a digit, one of 1 through 9, is placed in each of
the cells.
When three or more stones in horizontally adjacent cells are engraved
with the same digit, the stones will disappear.
If there are stones in the cells above the cell with a disappeared
stone, the stones in the above cells will drop down, filling the
vacancy.
The puzzle proceeds taking the following steps.
When three or more stones in horizontally adjacent cells are
engraved with the same digit, the stones will disappear. Disappearances
of all such groups of stones take place simultaneously.
When stones are in the cells above the emptied cells, these stones drop down so that the emptied cells are filled.
After the completion of all stone drops, if one or more groups of
stones satisfy the disappearance condition, repeat by returning to the
step 1.
The score of this puzzle is the sum of the digits on the disappeared stones.
Write a program that calculates the score of given configurations of stones.
Input
The input consists of multiple datasets.
Each dataset is formed as follows.
Board height
H
Stone placement of the row 1
Stone placement of the row 2
...
Stone placement of the row
H
The first line specifies the height (
H
) of the puzzle board (1 ≤
H
≤ 10).
The remaining
H
lines give placement of stones on each of the rows from top to bottom.
The placements are given by five digits (1 through 9), separated by a space.
These digits are engraved on the five stones in the corresponding row, in the same order.
The input ends with a line with a single zero.
Output
For each dataset, output the score in a line.
Output lines may not include any characters except the digits expressing the scores.
Sample Input
1
6 9 9 9 9
5
5 9 5 5 9
5 5 6 9 9
4 6 3 6 9
3 3 2 9 9
2 2 1 1 1
10
3 5 6 5 6
2 2 2 8 3
6 2 5 9 2
7 7 7 6 1
4 6 6 4 9
8 9 1 1 8
5 6 1 8 1
6 8 2 1 2
9 6 3 3 5
5 3 8 8 8
5
1 2 3 4 5
6 7 8 9 1
2 3 4 5 6
7 8 9 1 2
3 4 5 6 7
3
2 2 8 7 4
6 5 7 7 7
8 8 9 9 9
0
Output for the Sample Input
36
38
99
0
72


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def puyo_one(A):
  ans = 0
  now = 1
  for i in range(1, 5):
    if A[i] == A[i - 1]:
      now += 1
    else:
      if now >= 3:
        ans += now * A[i - 1]
      now = 1
  return ans

def puyo(A):#A:配列
  p = 0#消せるものがなくなったらp=1とし、ansを返す
  ans = 0
  while p == 0:
    this = 0
    #ぷよを消して加点
    for i in range(len(A)):
      now = 1 
      for j in range(1, 5):
        if (A[i][j] == A[i][j - 1]) and (A[i][j] != 0):
          now += 1
        else:
          if now >= 3:
            this = 1
            ans += A[i][j - 1] * now 
            for k in range(j - now, j):
              A[i][k] = 0
          now = 1
      if now >= 3:
        this = 1
        ans += A[i][j - 1] * now 
        for k in range(j - now + 1, j + 1):
          A[i][k] = 0
    #print(A, this, ans)
    #一回も消してない場合
    if this == 0:
      p = 1
    #残ったぷよを落とす
    #落とすところ
    N = len(A)
    for i in range(1, N + 1):
      for j in range(5):
        if (A[N - i][j] == 0) and (i != N):
          k = 1
          while (A[N - i - k][j] == 0) and (k + i < N):
            k += 1
          A[N - i][j] = A[N - i - k][j]
          A[N - i - k][j] = 0
    #一つもない行がある時、その行ごと消す
    q = 0
    while q == 0:
      if [0, 0, 0, 0, 0] in A:
        A.pop(A.index([0, 0, 0, 0, 0]))
      else:
        q = 1
    #print(A)
  return ans

l = 0
while l == 0:
  H = int(input())
  if H == 0:
    quit()
  else:
    A = [0] * H
    for i in range(H):
      A[i] = list(map(int, input().split()))
      #print(A)
    print(puyo(A))
```