Voici un énoncé de problème :

H: 板
問題
$R * C$ のマスが与えられます．各マスは何もないマスか，穴が開いているマスのどちらかです．
与えられるマスは以下の条件を満たします。
穴の開いたマス同士は連結である．（穴の開いたマスを十字方向につたって任意の穴の開いたマスに移動することができる）
何もないマス同士は連結である．
あなたは幅が $1$ の任意長の長方形型のタイルを生成することができます．
このタイルを複数枚設置して全ての穴のあるマスを埋めたいです．タイルを設置するとき，以下の制約を守る必要があります．
タイルは縦向きか横向きの $2$ 方向でのみ設置が可能である．
一つのマスに二枚以上のタイルが重なるように設置してはいけない．
穴のないマスの上にタイルがあってはいけない．
上記の制約を守って全ての穴のあるマスをタイルで埋めたときの，タイルの最小枚数を答えてください．
制約
$1 \leq R, C \leq 25$
$|S_i| = C \ \ \ \ |S_i|$ は文字列の長さを表す。
$S_{i,j}$ は '#' または '.' で、それぞれ穴の開いたマス、何もないマスを表す。
入力形式
入力は以下の形式で与えられる。
$R\ C$
$S_{1,1} \dots S_{1,C}$
$\vdots$
$S_{R,1} \dots S_{R,C}$
出力
最小回数を出力してください。末尾に改行も出力してください。
サンプル
サンプル入力 1
5 5
.....
.#.#.
.###.
.#.#.
.....
サンプル出力 1
3
$3$ 枚のタイルを以下のように置くのが最適です
.....
.1.3.
.123
.1.3
.....
サンプル入力 2
4 10
##########
....#.....
....#.....
..........
サンプル出力 2
2
$2$ 枚のタイルを以下のように置くのが最適です．タイルの長さは任意長にでき，縦向きにも横向きにも使えることに注意してください．
1111111111
....2.....
....2.....
..........


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left
from fractions import gcd
from heapq import heappush, heappop
from functools import reduce

def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = 10**10
mod = 10 ** 9 + 7

class Dinic:
    def __init__(self, v, inf=10**10):
        self.v = v
        self.inf = inf
        self.G = [[] for _ in range(v)]
        self.level = [-1]*v  # 深さ
        self.ite = [0]*v  # DFSでの探索が済んでいるか
    def add_edge(self, fr, to, cap):
        self.G[fr].append([to, cap, len(self.G[to])])
        self.G[to].append([fr, 0, len(self.G[fr])-1])
    def bfs(self, s):  # BFSで深さ決定,sがstart
        self.level = [-1]*self.v  # 必要
        self.level[s] = 0
        Q = deque()
        Q.append(s)
        while Q:
            v = Q.popleft()
            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if e[1]>0 and self.level[e[0]]<0: ###capacity>0かつtoの深さ未定
                    self.level[e[0]] = self.level[v]+1
                    Q.append(e[0])
    def dfs(self, v, t, f):  # DFSで増加パス探索,v開始、t終点、総フローf
        if v==t:
            return f
        for i in range(self.ite[v], len(self.G[v])):
            self.ite[v] = i
            e = self.G[v][i]
            if e[1]>0 and self.level[v]<self.level[e[0]]:
                d = self.dfs(e[0], t, min(f, e[1]))
                if d>0:
                    e[1] -= d  # cap減少
                    self.G[e[0]][e[2]][1] += d  # 逆辺のcap増加
                    return d
        return 0
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.level[t]<0:
                return flow
            self.ite = [0]*self.v  # DFSでの探索が済んでいるか否か
            f = self.dfs(s,t,self.inf)
            while f>0:
                flow += f
                f = self.dfs(s,t,self.inf)

R, C = MAP()
S = [input() for _ in range(R)]

D = Dinic(3*R*C+2)
s = 3*R*C
t = s+1

block = 0
adj = 0

for i in range(R):
    for j in range(C):
        if S[i][j] == ".": continue
        block += 1
        if i+1 < R and S[i+1][j] == "#":  # 縦
            adj += 1
            newv = R*C+C*i+j
            D.add_edge(newv, t, 1)
            D.add_edge(C*i+j, newv, INF)
            D.add_edge(C*(i+1)+j, newv, INF)

        if j+1 < C and S[i][j+1] == "#":  # 横
            adj += 1
            newv = 2*R*C+C*i+j
            D.add_edge(s, newv, 1)
            D.add_edge(newv, C*i+j, INF)
            D.add_edge(newv, C*i+(j+1), INF)

print(block-(adj-D.max_flow(s, t)))
```