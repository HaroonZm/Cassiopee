En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from heapq import heappush, heappop
H, W = map(int, input().split())
A = [list(map(int, input().split())) for i in range(H)]

INF = 10**18
D = [[[INF]*W for i in range(H)] for k in range(H*W+1)]

dd = ((-1, 0), (0, -1), (1, 0), (0, 1))

que = [(0, 0, 0, 0)]
while que:
    cost, d, x, y = heappop(que)
    if D[d][y][x] < cost or d == H*W:
        continue
    for dx, dy in dd:
        nx = x + dx; ny = y + dy
        if not 0 <= nx < W or not 0 <= ny < H:
            continue
        nd = cost + A[ny][nx]*(d*2+1)
        if nd < D[d+1][ny][nx]:
            D[d+1][ny][nx] = nd
            heappush(que, (nd, d+1, nx, ny))
ans = INF
for i in range(H*W+1):
    ans = min(ans, D[i][H-1][W-1])
print(ans)
```