En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def main():
    while True:
        n = int(input())
        if n == -1:
            break
        mp = [list(map(int, input().split())) for _ in range(5)]
        scores = list(map(int, input().split()))
    
        vec = ((1, 0), (0, -1), (-1, 0), (0, 1))
    
    
        def simulate():
            use_mp = [[mp[y][x] for x in range(5)] for y in range(5)]
            bonus = 1
            score = 0
            while True:
                delete_set = set()
                for y in range(5):
                    for length in range(5, 2, -1):
                        for left in range(5 - length + 1):
                            if use_mp[y][left] == 0:continue
                            if all([use_mp[y][left] == num for num in use_mp[y][left:left+length]]):
                                for add in range(length):
                                    delete_set.add((left + add, y))
    
                for x in range(5):
                    for length in range(5, 2, -1):
                        for top in range(5 - length + 1):
                            if use_mp[top][x] == 0:continue
                            if all([use_mp[top][x] == num for num in [use_mp[y][x] for y in range(top, top + length)]]):
                                for add in range(length):
                                    delete_set.add((x, top + add))
    
                if not delete_set:
                    break
    
                for x, y in delete_set:
                    score += scores[use_mp[y][x] - 1] * bonus
                    use_mp[y][x] = 0
    
                for x in range(5):
                    line = [use_mp[y][x] for y in range(5) if use_mp[y][x] != 0]
                    line = [0] * (5 - len(line)) + line
                    for y in range(5):
                        use_mp[y][x] = line[y]
    
                bonus += 1
    
            return score
    
        def search(x, y, n):
            ret = simulate()
            if n == 0:return ret
            for dx, dy in vec:
                nx, ny = x + dx, y + dy
                if 0 <= nx < 5 and 0 <= ny < 5:
                    mp[y][x], mp[ny][nx] = mp[ny][nx], mp[y][x]
                    ret = max(ret, search(nx, ny, n - 1))
                    mp[y][x], mp[ny][nx] = mp[ny][nx], mp[y][x]
            return ret
    
    
        ans = 0
        for y in range(5):
            for x in range(5):
                ans = max(ans, search(x, y, n))
    
        print(ans)
    
main()
```