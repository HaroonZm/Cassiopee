Voici un énoncé de problème :

Balls and Boxes 9
Balls
Boxes
Any way
At most one ball
At least one ball
Distinguishable
Distinguishable
1
2
3
Indistinguishable
Distinguishable
4
5
6
Distinguishable
Indistinguishable
7
8
9
Indistinguishable
Indistinguishable
10
11
12
Problem
You have $n$ balls and $k$ boxes. You want to put these balls into the boxes.
Find the number of ways to put the balls under the following conditions:
Each ball is distinguished from the other.
Each box is
not
distinguished from the other.
Each ball can go into only one box and no one remains outside of the boxes.
Each box must contain at least one ball.
Note that you must print this count modulo $10^9+7$.
Input
$n$ $k$
The first line will contain two integers $n$ and $k$.
Output
Print the number of ways modulo $10^9+7$ in a line.
Constraints
$1 \le n \le 1000$
$1 \le k \le 1000$
Sample Input 1
4 3
Sample Output 1
6
Sample Input 2
10 5
Sample Output 2
42525
Sample Input 3
100 30
Sample Output 3
203169470


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python

import sys
import math
import itertools as it
from collections import deque

sys.setrecursionlimit(10000000)

MOD = 10 ** 9 + 7
n, k = map(int, raw_input().split())

m_comb = {}
m_pow = {}
m_inv = {}

def comb(N, K):
    if (N, K) in m_comb:
        return m_comb[(N, K)]
    if N == K or K == 0:
        m_comb[(N, K)] = 1
        return 1
    m_comb[(N, K)] = (comb(N - 1, K) + comb(N - 1, K - 1)) % MOD
    return m_comb[(N, K)]

def pow(N):
    if N in m_pow:
        return m_pow[N]
    ret = 1
    for i in range(n):
        ret *= N
        ret %= MOD
    m_pow[N] = ret
    return ret

def inv(N):
    if N in m_inv:
        return m_inv[N]
    pow_num = MOD - 2
    pow_cur = N
    ret = 1
    while pow_num > 0:
        if pow_num % 2 == 1:
            ret *= pow_cur
            ret %= MOD
        pow_cur *= pow_cur
        pow_cur %= MOD
        pow_num /= 2
    m_inv[N] = ret
    return ret

ans = pow(k)
sig = -1

for i in range(k - 1, 0, -1):
    ans += (comb(k, i) * pow(i) % MOD) * sig
    sig *= -1

for i in range(1, k + 1):
    ans *= inv(i)
    ans %= MOD

print ans
```