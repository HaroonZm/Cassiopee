Voici un énoncé de problème :

会津山スキー場の新企画
会津山スキー場の経営者である油木屋さんは、上級者向けとして障害物やジャンプ台を配置したコースを用意しました。コースにはいろいろな滑り方があり、シーズン中に全てのパターンの滑り方が出来た利用者には、プレゼントを贈ることになっています。
油木屋さんのために、コースの見取り図をもとに滑り方のパターン数を出力するプログラムを作ってあげましょう。
コースは上図のような
X × Y
個のマスからなるグリッドで表されます。左上を原点とし、x 座標は右に行くにつれて大きくなり、y 座標は下にいくにつれて大きくなるものとします。
各滑り方のパターンは、最も高いところ(
y = 1
、ただし障害物の無いところ) からスタートし、ゴール(
y = Y
) に向かって進んでいきます。グリッドのマス(
x, y
) にいる滑走者は、(
x − 1, y + 1
)、(
x, y + 1
)、 (
x + 1, y + 1
) のいずれかに移動することができます。マスには、障害物やジャンプ台があり、障害物のあるマスには進入できず、ジャンプ台があるマスに進入すると(
x, y + 2
) へ移動します。ただし、いちばん高いマス (
y = 1
のマス) にはジャンプ台は存在せず、ジャンプ台のあるマスに進入する際には x 座標が同じマスからしか進入できません。コースの上端(
y = 1
) からスタートし、コースからはずれることなく下端を超えれば(
y ≥ Y
) 1つの滑り方とみなし、滑り終わります。
コースの情報を入力とし、滑り方の総数を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロふたつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
c
11
c
21
...
c
X1
c
12
c
22
...
c
X2
:
c
1Y
c
2Y
...
c
XY
1 行目にコースの大きさ
X, Y
(1 ≤
X, Y
≤ 15) が与えられます。続く
Y
行にコースの情報が与えられます。
c
ij
(0 , 1 , 2 のいずれか) は
x = i, y = j
のマスの情報を表す整数で、0 が移動可能なマス、1 が障害物があるマス、2 がジャンプ台があるマスを表します。
データセットの数は 50 を超えません。
Output
入力データセットごとに、コースの滑り方のパターン数を1行に出力します。
Sample Input
5 5
0 0 0 0 1
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
5 5
0 0 1 0 0
2 1 0 2 0
1 0 0 1 1
0 2 1 2 0
0 1 0 0 0
15 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0
Output for the Sample Input
8
6
52694573


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
"""
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0203

"""
import sys
from sys import stdin
from collections import deque, defaultdict
input = stdin.readline

def solve(field):
    BLANK, OBSTACLE, JUMP = 0, 1, 2
    ans = 0                     #  ??????????????°???????????°

    dy = [1, 1, 1]  # ?????????????????????????????????????§???????
    dx = [0, -1, 1]
    x_limit = len(field[0])
    y_limit = len(field)

    path = defaultdict(int)     #  ??????????????????????????°???????????°????????????'x???_y???'???????????????
    Q = deque()
    for x, m in enumerate(field[0]):
        if m == BLANK:              #  ?????????????????°?????´?????????????????????????????????
            t = '{}_{}'.format(x, 0)
            Q.append((x, 0))
            path[t] = 1

    while Q:
        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?
        t = '{}_{}'.format(cx, cy)
        num = path.pop(t)

        if field[cy][cx] == OBSTACLE:
            continue
        elif field[cy][cx] == JUMP: #  ?????£????????§?????°?????????????????£????????°
            if cy+2 > y_limit-1:
                ans += num
            else:
                t = '{}_{}'.format(cx, cy+2)
                if not path[t]:
                    Q.append((cx, cy+2))
                path[t] += num
            continue
        elif cy == y_limit -1:
            ans += num
            continue

        for i in range(3):      #  ?????????3???len(dy)?????????
            nx = cx + dx[i]     #  ?????°????????§?¨?
            ny = cy + dy[i]

            if 0<= nx < x_limit:
                if field[ny][nx] == JUMP and dx[i] == 0: #  ?????£????????°????????£??????????????\????????´???
                    if ny+2 > y_limit - 1:
                        ans += num
                    else:
                        t = '{}_{}'.format(nx, ny+2)
                        if not path[t]:
                            Q.append((nx, ny+2))
                        path[t] += num
                elif field[ny][nx] == BLANK:
                    if (ny >= y_limit - 1):
                        ans += num
                    else:
                        t = '{}_{}'.format(nx, ny)
                        if not path[t]:
                            Q.append((nx, ny))
                        path[t] += num
    return ans

def main(args):
    while True:
        X, Y = map(int, input().strip().split())
        if X == 0 and Y == 0:
            break
        field = []
        for _ in range(Y):
            temp = [int(x) for x in input().strip().split()]
            field.append(temp)
        result = solve(field)
        print(result)

if __name__ == '__main__':
    main(sys.argv[1:])
```