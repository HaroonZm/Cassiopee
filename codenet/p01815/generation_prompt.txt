Voici un énoncé de problème :

Escape
頂点に正の値を持つ無向グラフが与えられる。
頂点には 1 から
N
の番号がついており、
i
番目の頂点は
w_i
の値を持っている。
1 番目の頂点からスタートし、直前に通った辺を通ることができないという制約のもとでグラフ上を移動することができる。
各頂点では，初めて訪れた時に限りその頂点が持つ値の点数を得られる。
取得できる点数の総和の最大値を求めよ。
Constraints
1 ≤ N ≤ 100000
N − 1 ≤ M ≤ 100000
1 ≤ w_i ≤ 1000
1 ≤ u_i, v_i ≤ N
多重辺・自己辺は存在しない
グラフは連結である
Input Format
入力は以下の形式で標準入力から与えられる。
N
M
w_1
w_2
...
w_N
u_1
v_1
u_2
v_2
...
u_M
v_M
1
行目には
グラフ
の頂点数
N
と辺の数を表す整数
M
が入力される。
2
行目には各頂点が持つ値
w_i
が入力される。
さらに続けて
M
行に、各辺により繋がれる
2
頂点の番号が入力される。
Output Format
答えを1行に出力せよ。
Sample Input 1
6 6
1 2 3 4 5 6
1 2
2 3
3 4
1 4
4 5
5 6
Sample Output 1
21
頂点 1→2→3→4→5→6 と進むことで全ての頂点の点数を集めることができます。
Sample Input 2
7 8
1 3 3 5 2 2 3
1 2
2 3
3 1
1 4
1 7
1 5
1 6
5 6
Sample Output 2
16
頂点 1→2→3→1→5→6→1→4 と進むことで16点を集めることができます。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def find(x):
  if par[x] == x:
    return x
  else:
    par[x] = find(par[x])
    return par[x]

def union(x, y):
  par_x = find(x)
  par_y = find(y)
  if rank[par_x] < rank[par_y]:
    par[par_x] = par_y
    w[par_y]+=w[par_x]
  else:
    par[par_y] = par_x
    w[par_x]+=w[par_y]
    if rank[par_x] == rank[par_y]:
      rank[par_x] += 1

def same(x, y):
  return find(x)==find(y)

def dfs(cur, prev):
  if visited[cur] or cur!=find(cur):
    while len(path)>0:
      union(0, path.pop())
    return
  visited[cur] = 1
  path.append(cur)
  for to in graph[cur]:
    if to==prev:
      continue
    dfs(to, cur)
  visited[cur] = 0
  if len(path)>0 and path[-1]==cur:
    path.pop()

def dfs2(cur):
  visited[cur] = 1
  ret = 0
  for i in range(len(graph2[cur])):
    for ele in graph[graph2[cur][i]]:
      if visited[find(ele)] == 0:
        ret = max(ret, dfs2(find(ele)))
  return ret+w[find(cur)]

import sys
from collections import defaultdict
sys.setrecursionlimit(1000000)
n, m = map(int, input().split())
w = [0]
w.extend(list(map(int, input().split())))
graph = defaultdict(list)
for _ in range(m):
  u, v = map(int, input().split())
  graph[u].append(v)
  graph[v].append(u)

path = []
graph2 = [[] for _ in range(n+1)]
visited = [0]*(n+1)
par = [i for i in range(n+1)]
rank = [0]*(n+1)

dfs(1, -1)
for i in range(1, n+1):
  graph2[find(i)].append(i)

print(dfs2(find(1)))
```