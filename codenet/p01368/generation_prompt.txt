Voici un énoncé de problème :

Problem J:
Merry Christmas
International Christmas Present Company (ICPC) is a company to employ Santa and deliver
presents on Christmas. Many parents request ICPC to deliver presents to their children at
specified time of December 24. Although same Santa can deliver two or more presents, because
it takes time to move between houses, two or more Santa might be needed to finish all the
requests on time.
Employing Santa needs much money, so the president of ICPC employed you, a great program-
mer, to optimize delivery schedule. Your task is to write a program to calculate the minimum
number of Santa necessary to finish the given requests on time. Because each Santa has been
well trained and can conceal himself in the town, you can put the initial position of each Santa
anywhere.
Input
The input consists of several datasets. Each dataset is formatted as follows.
N M L
u
1
v
1
d
1
u
2
v
2
d
2
.
.
.
u
M
v
M
d
M
p
1
t
1
p
2
t
2
.
.
.
p
L
t
L
The first line of a dataset contains three integer,
N
,
M
and
L
(1 ≤
N
≤ 100, 0 ≤
M
≤ 1000,
1 ≤
L
≤ 1000) each indicates the number of houses, roads and requests respectively.
The following
M
lines describe the road network. The
i
-th line contains three integers,
u
i
,
v
i
,
and
d
i
(0 ≤
u
i
<
v
i
≤
N
- 1, 1 ≤
d
i
≤ 100) which means that there is a road connecting houses
u
i
and
v
i
with
d
i
length. Each road is bidirectional. There is at most one road between same
pair of houses. Whole network might be disconnected.
The next
L
lines describe the requests. The
i
-th line contains two integers,
p
i
and
t
i
(0 ≤
p
i
≤
N
- 1, 0 ≤
t
i
≤ 10
8
) which means that there is a delivery request to house
p
i
on time
t
i
. There
is at most one request for same place and time. You can assume that time taken other than
movement can be neglectable, and every Santa has the same speed, one unit distance per unit
time.
The end of the input is indicated by a line containing three zeros separated by a space, and you
should not process this as a test case.
Output
Print the minimum number of Santa necessary to finish all the requests on time.
Sample Input
3 2 3
0 1 10
1 2 10
0 0
1 10
2 0
3 2 4
0 1 10
1 2 10
0 0
1 10
2 20
0 40
10 10 10
0 1 39
2 3 48
3 5 20
4 8 43
3 9 10
8 9 40
3 4 5
5 7 20
1 7 93
1 3 20
0 0
1 100000000
2 100
3 543
4 500
5 400
6 300
7 200
8 100
9 100
0 0 0
Output for the Sample Input
2
1
4


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)

class WarshallFloyd():
    def __init__(self, e, n):
        self.E = e
        self.N = n

    def search(self):
        n = self.N
        nl = list(range(n))
        d = [[inf] * n for _ in nl]
        for i in range(n):
            d[i][i] = 0
        for k,v in self.E.items():
            dk = d[k]
            for b,c in v:
                # consider multiple edges
                if dk[b] > c:
                    dk[b] = c
        for i in nl:
            di = d[i]
            for j in nl:
                if i == j:
                    continue
                dj = d[j]
                for k in nl:
                    if i != k and j != k and dj[k] > dj[i] + di[k]:
                        dj[k] = dj[i] + di[k]
        return d

class Flow():
    def __init__(self, e, N):
        self.E = e
        self.N = N
        self.nl = list(range(N))

    def max_flow(self, s, t):
        r = 0
        e = self.E
        v = None

        def f(c):
            v[c] = 1
            if c == t:
                return 1
            for i in e[c]:
                if v[i] is None and f(i):
                    e[c].remove(i)
                    e[i].add(c)
                    return 1
            return

        while True:
            v = [None] * self.N
            if f(s) is None:
                break
            r += 1

        return r

def main():
    rr = []

    def f(n,m,l):
        ma = [LI() for _ in range(m)]
        la = [LI() for _ in range(l)]
        e = collections.defaultdict(list)
        for u,v,d in ma:
            e[u].append((v,d))
            e[v].append((u,d))
        wf = WarshallFloyd(e,n)
        wd = wf.search()
        e2 = collections.defaultdict(set)
        for i in range(l):
            p1,t1 = la[i]
            for j in range(l):
                if i == j:
                    continue
                p2,t2 = la[j]
                if wd[p1][p2] <= t2-t1:
                    e2[i].add(j+l)
            e2[l*2].add(i)
            e2[i+l].add(l*2+1)
        # for k,v in e2.items():
        #     print('k,v',k,v)
        fl = Flow(e2,l*2+2)
        t = fl.max_flow(l*2,l*2+1)
        # print('t',t)
        return l - t

    while 1:
        n,m,l = LI()
        if n == 0:
            break
        rr.append(f(n,m,l))
        # print('rr', rr[-1])

    return '\n'.join(map(str,rr))

print(main())
```