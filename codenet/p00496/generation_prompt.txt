Voici un énoncé de problème :

夜店(Night Market)
太郎くんは，JOI 神社で開かれる夏祭りに行くことにした．
JOI 神社に向かう道に沿って，
N
個の夜店が開かれている．それぞれの夜店には，1 から
N
までの番号が順番についており，遊んだ時の楽しさと遊ぶのにかかる時間がそれぞれ整数で決まっている．夜店
i
で遊んだ時の楽しさは
A
i
で，夜店
i
で遊ぶのにかかる時間は
B
i
である．
また，夏祭りのイベントとして花火大会があり，時刻
S
に最も大きな花火が打ち上げられる．太郎くんはこの最も大きな花火を見たいと思っている．
太郎くんは夜店と花火の両方を楽しむために，夏祭りに到着する時刻0 から夏祭りが終わる時刻
T
までの予定を立てることにした．
太郎くんは夜店の中から
k
個(1 ≤
k
≤
N
) の夜店を選び，それぞれに対して訪れる時刻を整数で決める．同じ夜店を2 度選ぶことはできない．選ばれた夜店の番号を小さい順に
y
1
,
y
2
, ...
y
k
とし，夜店
y
i
を訪れる時刻を
x
y
i
とすると，太郎くんは夜店
y
i
で時刻
x
y
i
から時刻
x
y
i
+
B
y
i
まで遊ぶ．
太郎くんは夜店の番号の小さい順に遊び，同時に2 つの夜店では遊べない．また，夜店と夜店の間の移
動にかかる時間は無視できる．
時刻
T
を超えると夏祭りが終わるので，夜店で遊ぶことはできない．また，夜店で遊んでいる間は花火を見ることはできない．ただし，時刻
S
がある夜店で遊び始める時刻や遊び終わる時刻であった場合は，太郎くんは花火を見ることができるものとする．
すなわち，予定は以下の条件を満たしていなければならない．
y
1
<
y
2
< ... <
y
k
x
y
1
,
x
y
2
, ...
x
y
k
は整数．
0 ≤
x
y
1
<
x
y
1
+
B
y
1
≤
x
y
2
<
x
y
2
+
B
y
2
≤ ... ≤
x
y
k
<
x
y
k
+
B
y
k
≤
T
x
y
i
<
S
<
x
y
i
+
B
y
i
となるような
i
は存在しない．
選ばれた夜店の楽しさ
A
y
1
,
A
y
2
, ...
A
y
k
の合計を
M
とする．太郎くんは
M
ができるだけ大きくなるように予定を立てたいと思っている．
課題
N
個の夜店の情報と時刻
S
,
T
が与えられた時，
M
の最大値を求めるプログラムを作成せよ．
制限
1 ≤
N
≤ 3000 夜店の数
1 ≤
T
≤ 3000 夏祭りが終わる時刻
0 ≤
S
≤
T
最も大きな花火が打ち上げられる時刻
0 ≤
A
i
≤ 100000 (= 10
5
) 夜店i で遊んだ時の楽しさ
1 ≤
B
i
≤ 3000 夜店
i
で遊ぶのにかかる時間
入力
標準入力から以下の入力を読み込め．
入力の1 行目には整数
N
,
T
,
S
が空白を区切りとして書かれており，夜店の数が
N
個，夏祭りが終わる時刻が
T
，最も大きな花火が打ち上げられる時刻が
S
であることを表す．
続く
N
行には夜店の情報が書かれている．入力の
i
+ 1 (1 ≤
i
≤
N
) 行目には整数
A
i
,
B
i
が空白を区切りとして書かれており，夜店
i
で遊んだ時の楽しさが
A
i
で，夜店
i
で遊ぶのにかかる時間が
B
i
であることを表す．
また，すべての入力において，１つ以上の予定を立てられることが保証されている．
出力
標準出力に，
M
の最大値を表す整数を1 行で出力せよ．
採点基準
採点用データのうち，
配点の10%分については，
N
≤ 20 を満たす．
配点の20%分については，
S
= 0 を満たす．
配点の30%分については，これら2 つの条件の少なくとも一方を満たす．また，これら2 つの条件の両方を満たすような採点用データはない．
入出力例
入力例 1
5 20 14
8 9
2 4
7 13
6 3
5 8
出力例 1
16
この例において，
夜店1 を時刻0 に訪れ，
夜店2 を時刻9 に訪れ，
夜店4 を時刻14 に訪れるような予定を立てると，
M
を最も大きくすることができる．
このとき，
M
= 8 + 2 + 6 = 16 である．
問題文と自動審判に使われるデータは、
情報オリンピック日本委員会
が作成し公開している問題文と採点用テストデータです。


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def main():
  n, t, s = map(int, input().split())
  A = []
  B = []
  for _ in range(n):
    a, b = map(int, input().split())
    A.append(a)
    B.append(b)
  
  """
  dp[x + 1][y] ... 店xまででで時刻yまでの最大値
  dp[x + 1][y] = max(dp[x][y], dp[x + 1][y - 1], dp[x][y - B[x]] + A[x]) (not y - B[x] < s < y)
  dp[x + 1][y] = max(dp[x][y], dp[x + 1][y - 1])
  """

  dp = [[0] * (t + 1) for _ in range(n + 1)]
  for x in range(n):
    bx = B[x]
    ax = A[x]
    dpx = dp[x]
    dpx1 = dp[x + 1]
    for y in range(1, t + 1):
      if 0 <= y - bx and (not (y - bx < s < y)):
        dpx1[y] = max(dpx[y], dpx1[y - 1], dpx[y - bx] + ax)
      else:
        dpx1[y] = max(dpx[y], dpx1[y - 1])
   
  print(dp[n][t])
 
main()
```