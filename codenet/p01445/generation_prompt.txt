Voici un énoncé de problème :

Problem I:
Mobile Network
The trafic on the Internet is increasing these days due to smartphones. The wireless carriers
have to enhance their network infrastructure.
The network of a wireless carrier consists of a number of base stations and lines. Each line connects two base stations bi-directionally. The bandwidth of a line increases every year and is given by a polynomial
f
(
x
) of the year
x
.
Your task is, given the network structure, to write a program to calculate the maximal bandwidth between the 1-st and
N
-th base stations as a polynomial of
x
.
Input
The input consists of multiple datasets. Each dataset has the following format:
N M
u
1
v
1
p
1
...
u
M
v
M
p
M
The first line of each dataset contains two integers
N
(2 ≤
N
≤ 50) and
M
(0 ≤
M
≤ 500), which indicates the number of base stations and lines respectively. The following
M
lines describe the network structure. The
i
-th of them corresponds to the
i
-th network line and contains two integers
u
i
and
v
i
and a polynomial
p
i
.
u
i
and
v
i
indicate the indices of base stations (1 ≤
u
i
,
v
i
≤
N
);
p
i
indicates the network bandwidth.
Each polynomial has the form of:
a
L
x
L
+
a
L
-1
x
L
-1
+ ... +
a
2
x
2
+
a
1
x
+
a
0
where
L
(0 ≤
L
≤ 50) is the degree and
a
i
's (0 ≤
i
≤
L
, 0 ≤
a
i
≤ 100) are the coefficients. In the input,
each term
a
i
x
i
(for
i
≥ 2) is represented as <
a
i
>
x
^<
i
>
the linear term (
a
1
x
) is represented as <
a
1
>
x
;
the constant (
a
0
) is represented just by digits;
these terms are given in the strictly decreasing order of the degrees and connected by a
plus sign ("
+
");
just like the standard notations, the <
a
i
> is omitted if
a
i
= 1 for non-constant terms;
similarly, the entire term is omitted if
a
i
= 0 for any terms; and
the polynomial representations contain no space or characters other than digits, "x", "^", and "+".
For example, 2
x
2
+ 3
x
+ 5 is represented as
2x^2+3x+5
; 2
x
3
+
x
is represented as
2x^3+x
, not
2x^3+0x^2+1x+0
or the like. No polynomial is a constant zero, i.e. the one with all the coefficients being zero.
The end of input is indicated by a line with two zeros. This line is not part of any dataset.
Output
For each dataset, print the maximal bandwidth as a polynomial of
x
. The polynomial should be represented in the same way as the input format except that a constant zero is possible and should be represented by "0" (without quotes).
Sample Input
3 3
1 2 x+2
2 3 2x+1
3 1 x+1
2 0
3 2
1 2 x
2 3 2
4 3
1 2 x^3+2x^2+3x+4
2 3 x^2+2x+3
3 4 x+2
0 0
Output for the Sample Input
2x+3
0
2
x+2


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
import collections

class MyList(list):
    def __init__(self, x=[]):
        list.__init__(self, x)

    def __iadd__(self, A):
        ret = MyList()
        for a, b in zip(self, A):
            ret.append(a + b)
        return ret

    def __isub__(self, A):
        ret = MyList()
        for a, b in zip(self, A):
            ret.append(a - b)
        return ret

    def __gt__(self, A):
        for a, b in zip(self, A):
            if a != b:
                return a > b
        return False

class MaxFlow:
    """Dinic Algorithm: find max-flow
       complexity: O(EV^2)
       used in GRL6A(AOJ)
    """
    class Edge:
        def __init__(self, to, cap, rev):
            self.to, self.cap, self.rev = to, cap, rev

    def __init__(self, V, D):
        """ V: the number of vertexes
            E: adjacency list
            source: start point
            sink: goal point
        """
        self.V = V
        self.E = [[] for _ in range(V)]
        self.D = D

    def zero(self):
        return MyList([0] * self.D)

    def add_edge(self, fr, to, cap):
        self.E[fr].append(self.Edge(to, cap, len(self.E[to])))
        self.E[to].append(self.Edge(fr, self.zero(), len(self.E[fr])-1))

    def dinic(self, source, sink):
        """find max-flow"""
        INF = MyList([10**9] * self.D)
        maxflow = self.zero()
        while True:
            self.bfs(source)
            if self.level[sink] < 0:
                return maxflow
            self.itr = MyList([0] * self.V)
            while True:
                flow = self.dfs(source, sink, INF)
                if flow > self.zero():
                    maxflow += flow
                else:
                    break

    def dfs(self, vertex, sink, flow):
        """find augmenting path"""
        if vertex == sink:
            return flow
        for i in range(self.itr[vertex], len(self.E[vertex])):
            self.itr[vertex] = i
            e = self.E[vertex][i]
            if e.cap > self.zero() and self.level[vertex] < self.level[e.to]:
                if flow > e.cap:
                    d = self.dfs(e.to, sink, e.cap)
                else:
                    d = self.dfs(e.to, sink, flow)
                if d > self.zero():
                    e.cap -= d
                    self.E[e.to][e.rev].cap += d
                    return d
        return self.zero()

    def bfs(self, start):
        """find shortest path from start"""
        que = collections.deque()
        self.level = [-1] * self.V
        que.append(start)
        self.level[start] = 0

        while que:
            fr = que.popleft()
            for e in self.E[fr]:
                if e.cap > self.zero() and self.level[e.to] < 0:
                    self.level[e.to] = self.level[fr] + 1
                    que.append(e.to)

def to_poly(a, l):
    if l == 0:
        return str(a)
    elif l == 1:
        return "{}x".format('' if a == 1 else a)
    else:
        return "{}x^{}".format('' if a == 1 else a, l)

while True:
    N, M = map(int, input().split())
    if N == M == 0:
        break
    mf = MaxFlow(N, 51)
    for _ in range(M):
        u, v, p = input().split()
        u, v = int(u)-1, int(v)-1
        poly = MyList([0] * 51)
        for x in p.split('+'):
            try:
                num = int(x)
                poly[-1] = num
            except ValueError:
                a, l = x.split('x')
                if l:
                    poly[-int(l.strip("^"))-1] = int(a) if a else 1
                else:
                    poly[-2] = int(a) if a else 1
        mf.add_edge(u, v, poly)
        mf.add_edge(v, u, poly)
    maxflow = mf.dinic(0, N-1)
    ans = '+'.join(to_poly(a, l) for a, l in zip(maxflow, reversed(range(51))) if a)
    print(ans if ans else 0)
```