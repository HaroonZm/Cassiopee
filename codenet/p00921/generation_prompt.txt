En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from math import sqrt

def get_cross_point_of_circles(x1, y1, r1, x2, y2, r2):
    rr0 = (x2 - x1) ** 2 + (y2 - y1) ** 2
    xd = x2 - x1
    yd = y2 - y1
    rr1 = r1 ** 2
    rr2 = r2 ** 2
    cv = (rr0 + rr1 - rr2)
    sv2 = 4 * rr0 * rr1 - cv ** 2
    if sv2 < 0:
        return None

    sv = sqrt(sv2)
    return (
        (x1 + (cv * xd - sv * yd) / (2. * rr0), y1 + (cv * yd + sv * xd) / (2. * rr0)),
        (x1 + (cv * xd + sv * yd) / (2. * rr0), y1 + (cv * yd - sv * xd) / (2. * rr0)),
    )

def get_solution_of_quadratic(a, b, c):
    if b**2 >= 4*a*c:
        return {(-b + sqrt(b**2 - 4*a*c))/(2*a), (-b - sqrt(b**2 - 4*a*c))/(2*a)}
    else:
        return {}

def get_nearest_wall(x, y):
    if y <= x:
        if y <= 100 - x:
            return x, 0
        else:
            return 100, y
    else:
        if y <= 100 - x:
            return 0, y
        else:
            return x, 100

while True:
    n, w = map(int, input().split())
    if n == w == 0:
        break

    xyh = [tuple(map(float, input().split())) for _ in range(n)]

    # 目いっぱいでもOKか
    m = (2500+w**2) / (2*w) if w < 50 else 50
    P = (50, 50, m)
    flag0 = True
    for k in range(n):
        if (50 - xyh[k][0]) ** 2 + (50 - xyh[k][1]) ** 2 + max(.0, m - xyh[k][2]) ** 2 <= m ** 2:
            flag0 = False
    if flag0:
        print(m)
        continue

    l = 0
    r = 130
    while abs(r - l) >= 0.0001:
        m = (l + r) / 2

        flag = False

        for i in range(n):
            if n != 1 and i != n - 1:
                # needle二つで抑えられる点
                for j in range(i + 1, n):
                    h1 = min(xyh[i][2], m)
                    h2 = min(xyh[j][2], m)

                    P = get_cross_point_of_circles(xyh[i][0], xyh[i][1], sqrt(2 * h1 * m - h1 ** 2),
                                                   xyh[j][0], xyh[j][1], sqrt(2 * h2 * m - h2 ** 2))
                    if P is None:
                        continue

                    for p in P:
                        if 0 <= p[0] <= 100 and 0 <= p[1] <= 100:

                            wx, wy = get_nearest_wall(p[0], p[1])

                            if (wx - p[0]) ** 2 + (wy - p[1]) ** 2 + max(0, m - w) ** 2 >= m ** 2:
                                flag2 = True
                                for k in range(n):
                                    if k != i and k != j:
                                        if (p[0] - xyh[k][0]) ** 2 + (p[1] - xyh[k][1]) ** 2 \
                                                + max(.0, m - xyh[k][2]) ** 2 <= m ** 2:
                                            flag2 = False
                                if flag2:
                                    flag = True

            # needle一つで抑える
            x, y, h = xyh[i]
            h = min(h, m)

            S1 = get_solution_of_quadratic(2, -2 * (x + y), x ** 2 + y ** 2 - 2 * m * h + h ** 2)
            S2 = get_solution_of_quadratic(2, -2 * (x + 100 - y), x ** 2 + (100 - y) ** 2 - 2 * m * h + h ** 2)
            for s in S1:
                if 0 <= s <= 100:
                    wx, wy = get_nearest_wall(s, s)

                    if (wx - s) ** 2 + (wy - s) ** 2 + max(0, m - w) ** 2 >= m ** 2:
                        flag2 = True
                        for k in range(n):
                            if k != i:
                                if (s - xyh[k][0]) ** 2 + (s - xyh[k][1]) ** 2 \
                                        + max(.0, m - xyh[k][2]) ** 2 <= m ** 2:
                                    flag2 = False
                        if flag2:
                            flag = True
            for s in S2:
                if 0 <= s <= 100:
                    wx, wy = get_nearest_wall(s, 100 - s)

                    if (wx - s) ** 2 + (wy - (100 - s)) ** 2 + max(0, m - w) ** 2 >= m ** 2:
                        flag2 = True
                        for k in range(n):
                            if k != i:
                                if (s - xyh[k][0]) ** 2 + ((100 - s) - xyh[k][1]) ** 2 \
                                        + max(.0, m - xyh[k][2]) ** 2 <= m ** 2:
                                    flag2 = False
                        if flag2:
                            flag = True
        if flag:
            l = m
        else:
            r = m

    print(m)
```