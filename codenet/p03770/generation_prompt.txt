Voici un énoncé de problème :

Score :
1000
points
Problem Statement
Snuke arranged
N
colorful balls in a row.
The
i
-th ball from the left has color
c_i
and weight
w_i
.
He can rearrange the balls by performing the following two operations any number of times, in any order:
Operation
1
: Select two balls with the same color. If the total weight of these balls is at most
X
, swap the positions of these balls.
Operation
2
: Select two balls with different colors. If the total weight of these balls is at most
Y
, swap the positions of these balls.
How many different sequences of colors of balls can be obtained? Find the count modulo
10^9 + 7
.
Constraints
1 ≤ N ≤ 2 × 10^5
1 ≤ X, Y ≤ 10^9
1 ≤ c_i ≤ N
1 ≤ w_i ≤ 10^9
X, Y, c_i, w_i
are all integers.
Input
Input is given from Standard Input in the following format:
N
X
Y
c_1
w_1
:
c_N
w_N
Output
Print the answer.
Sample Input 1
4 7 3
3 2
4 3
2 1
4 4
Sample Output 1
2
The sequence of colors
(2,4,3,4)
can be obtained by swapping the positions of the first and third balls by operation
2
.
It is also possible to swap the positions of the second and fourth balls by operation
1
, but it does not affect the sequence of colors.
Sample Input 2
1 1 1
1 1
Sample Output 2
1
Sample Input 3
21 77 68
16 73
16 99
19 66
2 87
2 16
7 17
10 36
10 68
2 38
10 74
13 55
21 21
3 7
12 41
13 88
18 6
2 12
13 87
1 9
2 27
13 15
Sample Output 3
129729600


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#-----UnionFind-----(0-indexed)
import sys;sys.setrecursionlimit(10**9)
class UnionFind:
  def __init__(self,n):
    self.n=[-1]*n
    self.r=[0]*n
    self.siz=n
  def find_root(self,x):
    if self.n[x]<0:
      return x
    else:
      self.n[x]=self.find_root(self.n[x])
      return self.n[x]
  def unite(self,x,y):
    x=self.find_root(x)
    y=self.find_root(y)
    if x==y:return
    elif self.r[x]>self.r[y]:
      self.n[x]+=self.n[y]
      self.n[y]=x
    else:
      self.n[y]+=self.n[x]
      self.n[x]=y
      if self.r[x]==self.r[y]:
        self.r[y]+=1
    self.siz-=1
  def root_same(self,x,y):
    return self.find_root(x)==self.find_root(y)
  def count(self,x):
    return -self.n[self.find_root(x)]
  def size(self):
    return self.siz

from collections import defaultdict
n,x,y=map(int,input().split())
mod=10**9+7
f=[1]
for i in range(1,n+7):f.append(f[-1]*i%mod)
cw=[list(map(int,input().split()))for _ in range(n)]
if n==1:exit(print(1))
if len(set(c for c,w in cw))==1:exit(print(1))
for i in range(n):cw[i][0]-=1
miw=[10**10]*n
miwi=[0]*n
for i in range(n):
  c,w=cw[i]
  if miw[c]>w:
    miw[c]=w
    miwi[c]=i
mminc=miw.index(min(miw))
temp=10**10
for i in range(n):
  if i!=mminc:temp=min(temp,miw[i])
sminc=miw.index(temp)
u=UnionFind(n)
for i in range(n):
  c,w=cw[i]
  if c==mminc:tc=sminc
  else:tc=mminc
  if miw[c]+w<=x:u.unite(miwi[c],i)
  if miw[tc]+w<=y:u.unite(miwi[tc],i)
d=[0]*n
for i in range(n):
  if i==u.find_root(i):d[i]=defaultdict(int)
for i in range(n):
  c,w=cw[i]
  d[u.find_root(i)][c]+=1
ans=1
for i in range(n):
  if i==u.find_root(i):
    anss=1
    co=0
    for j in d[i]:
      anss*=pow(f[d[i][j]],mod-2,mod)
      anss%=mod
      co+=d[i][j]
    anss*=f[co]
    ans=(ans*anss)%mod
print(ans)
```