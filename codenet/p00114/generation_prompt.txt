Voici un énoncé de problème :

電子蝿
ある計算機学者が電子空間に棲息する電子蝿という奇妙な生命体を見つけました。電子蝿の行動を観察しているうちに、この空間の (
x
,
y
,
z
) 地点にいる電子蝿は、次に以下の規則で示される (
x'
,
y'
,
z'
)に移動することが分かりました。
ただし、
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
は電子蝿の個体ごとに定まる正の整数です。
A
mod
B
は正の整数
A
を正の整数
B
で割ったときの余りです。
さらに観察をすると、ある種の電子蝿は (1,1,1) に置いてからしばらくすると、必ず (1,1,1) に戻ってくることがわかりました。このような蝿を戻り蝿と名付けました
(1)
。
戻り蝿のデータを入力とし、(1,1,1) に戻ってくる最小の移動回数 (>0) を出力するプログラムを作成してください。なお 1<
a
1
,
m
1
,
a
2
,
m
2
,
a
3
,
m
3
< 2
15
とします。
(1)
a
1
と
m
1
,
a
2
と
m
2
,
a
3
と
m
3
がそれぞれ互いに素 (公約数が 1) である時に戻ります。
Input
複数のデータセットが与えられます。各データセットは以下の形式で与えられます。
a
1
m
1
a
2
m
2
a
3
m
3
入力は６つの 0 を含む行で終わります。データセットの数は 50 を超えません。
Output
各データセットごとに、(1,1,1) に戻ってくる最小の移動回数(整数)を１行に出力してください。
Sample Input
2 5 3 7 6 13
517 1024 746 6561 4303 3125
0 0 0 0 0 0
Output for the Sample Input
12
116640000


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from math import gcd

def get_loop(a, m):
  count = 1
  acc = a
  while acc != 1:
    count += 1
    acc *= a
    acc %= m
  return count

while True:
  a1, m1, a2, m2, a3, m3 = map(int, input().split())
  if not a1:
    break
  loop_a = get_loop(a1, m1)
  loop_b = get_loop(a2, m2)
  loop_c = get_loop(a3, m3)
  loop_ab = loop_a * loop_b // gcd(loop_a, loop_b)
  loop_abc = loop_ab * loop_c // gcd(loop_ab, loop_c)
  print(loop_abc)
```