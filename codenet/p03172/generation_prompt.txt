Voici un énoncé de problème :

Score :
100
points
Problem Statement
There are
N
children, numbered
1, 2, \ldots, N
.
They have decided to share
K
candies among themselves.
Here, for each
i
(
1 \leq i \leq N
), Child
i
must receive between
0
and
a_i
candies (inclusive).
Also, no candies should be left over.
Find the number of ways for them to share candies, modulo
10^9 + 7
.
Here, two ways are said to be different when there exists a child who receives a different number of candies.
Constraints
All values in input are integers.
1 \leq N \leq 100
0 \leq K \leq 10^5
0 \leq a_i \leq K
Input
Input is given from Standard Input in the following format:
N
K
a_1
a_2
\ldots
a_N
Output
Print the number of ways for the children to share candies, modulo
10^9 + 7
.
Sample Input 1
3 4
1 2 3
Sample Output 1
5
There are five ways for the children to share candies, as follows:
(0, 1, 3)
(0, 2, 2)
(1, 0, 3)
(1, 1, 2)
(1, 2, 1)
Here, in each sequence, the
i
-th element represents the number of candies that Child
i
receives.
Sample Input 2
1 10
9
Sample Output 2
0
There may be no ways for the children to share candies.
Sample Input 3
2 0
0 0
Sample Output 3
1
There is one way for the children to share candies, as follows:
(0, 0)
Sample Input 4
4 100000
100000 100000 100000 100000
Sample Output 4
665683269
Be sure to print the answer modulo
10^9 + 7
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def submit():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    modp = 10 ** 9 + 7
    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = 1

    for i in range(n):
        for j in range(1, k + 1):
            if j - 1 - a[i] >= 0:
                dp[i + 1][j] = dp[i][j] + dp[i + 1][j - 1] - dp[i][j - 1 - a[i]]
            else:
                dp[i + 1][j] = dp[i][j] + dp[i + 1][j - 1]
            dp[i + 1][j] %= modp
    print(dp[n][k])

submit()
```