Voici un énoncé de problème :

Score :
1100
points
Problem Statement
Let us consider a grid of squares with
10^9
rows and
N
columns. Let
(i, j)
be the square at the
i
-th column
(1 \leq i \leq N)
from the left and
j
-th row
(1 \leq j \leq 10^9)
from the bottom.
Snuke has cut out some part of the grid so that, for each
i = 1, 2, ..., N
, the bottom-most
h_i
squares are remaining in the
i
-th column from the left.
Now, he will paint the remaining squares in red and blue.
Find the number of the ways to paint the squares so that the following condition is satisfied:
Every remaining square is painted either red or blue.
For all
1 \leq i \leq N-1
and
1 \leq j \leq min(h_i, h_{i+1})-1
, there are exactly two squares painted red and two squares painted blue among the following four squares:
(i, j), (i, j+1), (i+1, j)
and
(i+1, j+1)
.
Since the number of ways can be extremely large, print the count modulo
10^9+7
.
Constraints
1 \leq N \leq 100
1 \leq h_i \leq 10^9
Input
Input is given from Standard Input in the following format:
N
h_1
h_2
...
h_N
Output
Print the number of the ways to paint the squares, modulo
10^9+7
.
Sample Input 1
9
2 3 5 4 1 2 4 2 1
Sample Output 1
12800
One of the ways to paint the squares is shown below:
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
Sample Input 2
2
2 2
Sample Output 2
6
There are six ways to paint the squares, as follows:
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
Sample Input 3
5
2 1 2 1 2
Sample Output 3
256
Every way to paint the squares satisfies the condition.
Sample Input 4
9
27 18 28 18 28 45 90 45 23
Sample Output 4
844733013
Remember to print the number of ways modulo
10^9 + 7
.


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
mod=10**9+7
n=int(input())
H=list(map(int,input().split()))

def solve(h):
    if not h:
        return 1
    elif len(h)==1:
        return pow(2,h[0],mod)
    N=len(h)
    a=[h[i] for i in range(N)]
    a=list(set(a))
    a.sort()
    comp={i:e+1 for e,i in enumerate(a)}
    data={comp[e]:e for e in comp.keys()}
    data[0]=0
    data[0]=1
    #print(comp)

    dp=[[0 for i in range(len(a)+1)] for j in range(N)]

    i=0
    if h[i+1]>=h[i]:
        id=comp[h[i]]
        id2=comp[h[i+1]]
        for j in range(id,id2+1):
            dp[i][j]=2
        for j in range(0,id):
            dp[i][j]=1
    else:
        id=comp[h[i+1]]
        for j in range(0,id):
            dp[i][j]=pow(2,h[i]-h[i+1],mod)
        dp[i][id]=2*(pow(2,h[i]-h[i+1],mod)-1)
        dp[i][id]%=mod
        id2=comp[h[i]]
        dp[i][id]+=2
        dp[i][id]%=mod

    for i in range(1,N-1):
        if h[i+1]>=h[i]:
            id=comp[h[i]]
            id2=comp[h[i+1]]
            for j in range(id,id2+1):
                dp[i][j]=(2*dp[i-1][id])%mod
            for j in range(0,id):
                dp[i][j]=dp[i-1][j]
        else:
            id=comp[h[i+1]]
            id2=comp[h[i]]
            for j in range(0,id):
                dp[i][j]=(pow(2,h[i]-h[i+1],mod)*dp[i-1][j])%mod
            for j in range(id,id2):
                low=data[j]
                up=data[j+1]-1
                dp[i][id]+=dp[i-1][j]*pow(2,h[i]-up,mod)*(pow(2,up-low+1,mod)-1)
            dp[i][id]%=mod
            dp[i][id]+=2*dp[i-1][id2]
            dp[i][id]%=mod

    ans=0
    id=comp[h[-1]]
    for i in range(0,id):
        low=data[i]
        up=data[i+1]-1
        ans+=dp[N-2][i]*pow(2,h[-1]-up,mod)*(pow(2,up-low+1,mod)-1)
        ans%=mod
    ans+=2*dp[N-2][id]
    ans%=mod
    return ans

ans=pow(2,H.count(1),mod)
check=[i for i in range(n) if H[i]==1]
check=[-1]+check+[n]
for i in range(len(check)-1):
    l,r=check[i],check[i+1]
    ans*=solve(H[l+1:r])
    ans%=mod

print(ans)
```