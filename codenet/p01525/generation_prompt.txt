Voici un énoncé de problème :

F - Acceleration of Network
インターネットと言う広大な海は少しずつ黒く塗りつぶされていった。
ボットの反乱、DDOS攻撃の嵐、ウィルスの蔓延、
何度も何度も繰り返されたクラッカーとの戦争で、人もインターネットもボロボロになった。
人の手では、インターネットはどうにもならない。
だから人は、とんでもない時間をかけて
インターネットを復旧できる「少女」を造った。
少女は、インターネットの手当をはじめた。
果てしなく広いインターネットの世界をどうにかしようと頑張った。
まだ少女ひとりでは撚り対線を織る事くらいしかできないけど、
長い長い時がすぎてインターネットが少し復旧すれば、
みんなと一緒に頑張れるだろうという期待をこめて。
問題文
少女はかつてインターネットに存在した
N
個のサービスを復旧するために日々頑張っている．
現在を 0 日目とする．
インターネットがどの程度復旧しているかを
復旧度
という指標で表し，現在の復旧度は 0 であるとする．
少女は毎日作業をし，復旧度を 1 日につき 1 ずつ上げていく．
任意のまだ復旧していないサービス
i
は，復旧度が
w
i
以上になると自動的に復旧する．
サービス
i
が復旧すると，みんなが手伝ってくれることにより，復旧した次の日から
x
i
日間だけ作業がはかどり，復旧度の増加が加速する．
サービスには 3 つの種類があり，種類によって復旧度がどの程度増加するのかが異なる．
サービスの種類を
0, 1, 2
の番号で表すとする．
サービス
i
の種類を t
i
(∈ {0, 1, 2}) とすると，
サービス
i
が復旧してから
d-1
日目から
d
日目にかけて
(1 ≤ d ≤ x
i
)
，
t
i
=0
の場合は
1
，
t
i
=1
の場合は
d
，
そして
t
i
=2
の場合は
d
2
だけ，少女の作業とは別に復旧度が増加する．
また，同時に複数のサービスが復旧している場合，それぞれのサービスは独立に並行して復旧度を増加させる．
少女はサービスが復旧するまでにとんでもない時間がかかると思ったので，現在から何日目にサービスが復旧するか調べることにした．
またある日にち
y
j
に復旧度がいくらになっているかも気になったので，それも
Q
日分だけ調べることにした．
入力形式
入力は以下の形式で与えられる．
N
Q
w
1
t
1
x
1
...
w
N
t
N
x
N
y
1
...
y
Q
出力形式
最初に
N
行出力し，
i
行目にはサービス
i
の復旧する日にちを出力せよ．次に
Q
行出力し，
j
行目には
y
j
日目に復旧度がいくらになっているかを出力せよ．
サービスが復旧する日にちが
3,652,425
を超える場合は
Many years later
と出力せよ．
制約
0 ≤ N ≤ 10
5
1 ≤ Q ≤ 10
5
0 ≤ w
i
< 2
60
w
i
≤ w
i+1
(1 ≤ i < N)
t
i
∈ {0, 1, 2}
1 ≤ x
i
≤ 10
4
0 ≤ y
j
≤ 3,652,425
y
j
< y
j+1
(1 ≤ j < Q)
入力値はすべて整数である．
この問題の判定には，15 点分のテストケースのグループが設定されている．このグループに含まれるテストケースは上記の制約に加えて下記の制約も満たす．
N,Q,w
i
,y
j
≤ 1,000
注意
0 日目の復旧度は 0 である．
w
i
=0
の時，サービス
i
は 0 日目に復旧する．
入出力例
入力例1
3 11
1 0 2
4 1 3
7 2 4
0
1
2
3
4
5
6
7
8
9
10
出力例1
1
3
4
0
1
3
5
7
11
19
29
46
47
48
入力例2
5 5
10000 0 20
10000 1 30
10000 0 40
10000 2 70
30000 2 10000
5000
10000
15000
20000
25000
出力例2
10000
10000
10000
10000
10039
5000
10000
40711690801
329498273301
333383477320
入力例3
2 2
3652425 0 1
3652426 2 10000
3652424
3652425
出力例3
3652425
Many years later
3652424
3652425
2つ目のサービスは復旧する日にちが
3,652,425
日を超えているので
Many years later
と出力している．
Writer : 森槙悟
Tester : 田村和範


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
from collections import defaultdict

def main():
  MAX = 3652425
  n, q = map(int, input().split())
  lst = [tuple(map(int, input().split())) for _ in range(n)]
  restore = [0] * (MAX + 10010)
  t0s = [0] * (MAX + 10010)
  t1s = [0] * (MAX + 10010)
  t2s = [0] * (MAX + 10010)
  t3s = [0] * (MAX + 10010)
  t1_cnt_save = defaultdict(int)
  t3_cnt_save = defaultdict(int)
  t1_cnt = 0
  t3_cnt = 0
  day = 0
  for i, line in enumerate(lst):
    w, t ,x = line
    while day < MAX and w > restore[day]:
      t0s[day + 1] += t0s[day]
      if day + 1 in t1_cnt_save: t1_cnt -= t1_cnt_save[day + 1]
      t1s[day + 1] += t1s[day] + t1_cnt
      if day + 1 in t3_cnt_save: t3_cnt -= t3_cnt_save[day + 1]
      t3s[day + 1] += t3s[day] + 2 * t3_cnt
      t2s[day + 1] += t2s[day] + t3s[day + 1]
      restore[day + 1] = restore[day] + 1 + t0s[day] + t1s[day] + t2s[day]
      day += 1
    
    if w <= restore[day]:
      print(day)
      if t == 0:
        t0s[day] += 1
        t0s[day + x] -= 1
      elif t == 1:
        t1_cnt += 1
        t1_cnt_save[day + x] += 1
        t1s[day] += 1
        t1s[day + x] -= x
      elif t == 2:
        t3_cnt += 1
        t3_cnt_save[day + x] += 1
        t3s[day] += 1
        t3s[day + x] -= x * 2 - 1
        t2s[day] += 1
        t2s[day + x] -= x ** 2
    else:print("Many years later")
  
  for _ in range(q):
    y = int(input())
    while day < y:
      t0s[day + 1] += t0s[day]
      t1_cnt -= t1_cnt_save[day + 1]
      t1s[day + 1] += t1s[day] + t1_cnt
      t3_cnt -= t3_cnt_save[day + 1]
      t3s[day + 1] += t3s[day] + 2 * t3_cnt
      t2s[day + 1] += t2s[day] + t3s[day + 1]
      restore[day + 1] = restore[day] + 1 + t0s[day] + t1s[day] + t2s[day]
      day += 1
    print(restore[y])

main()
```