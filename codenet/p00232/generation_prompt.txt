Voici un énoncé de problème :

人生ゲーム
太郎君は、おもちゃ屋さんに会津ホビー社製の人生ゲームを買いに行きました。人生ゲームは、マス目の書かれたボードとルーレットを使って遊びます。ボードには図のようにスタート地点とゴール地点が一つずつあり、それらはひとつながりのマス目でつながっています。最初に、コマはスタート地点のマスに置かれ、ルーレットを回して出た数によってコマを進めます。マスによっては、そこに止まったり通過したりすることでお金を得たり、コマの位置を変えたりするイベントマスがあります。最終的な勝敗は、コマがゴール地点に到達した時点の所持金の多寡で決まります。
この会社の人生ゲームの面白いところは、ルーレットの出る目の大きさ、ゴールまでのマスの数、イベントマスの配置がひとつひとつパッケージごとに異なるところです。それらはケースに書かれており、それを読むことで確認することができます。お金を最も得られる人生ゲームを選びたい太郎君は、得るお金の期待値が一番大きいものを買いたがっています。そこであなたは、太郎君のゲーム選びを手伝うことにしました。
ルーレットは、円周を
X
等分に区分され、それぞれに
V
1
、
V
2
、...、
V
X
という値が記入されているとします。ボードには、0 番、1 番、...、
Y
番と番号がふられたマス目があり、順番につながっています。マス目の中には、イベントマスと呼ばれる特別なマスが
Z
個あり、そこに到達すると特別な動作を行います。イベントマスのマス目の番号は
N
i
で与えられます。イベントマスには 1 ~ 3 の種類 (
E
i
) があり、それぞれ次の動作が行われます。
種類 (
E
i
)
特別動作
値 (
A
i
) の範囲
1
指定の値
A
i
だけ先へ進む
1~10
2
指定の値
A
i
の金額を得る
1~100
3
指定の値
A
i
の金額を支払う
1~100
最初の所持金は 0 円で、第 0 マス目からスタートし、第
Y
マス目に到達するとゴールとなります。ゴールを越えた場合もゴールと見なします。スタートとゴールにイベントは無く、1 マスに複数のイベントが重なることはありません。イベントによって進んだ先のマスのイベントは無視します。所持金が 0 円より少なくなる場合は 0 円とします。
例えば、ある人生ゲームで得られるお金の期待値は以下のように計算できます。
この例では、スタート、イベントマス(100 円入手) 、ゴールの 3 つのマスと、1 か 2 が出るルーレットからなる人生ゲームが表されています。まず、1 回目にルーレットを回した時、1 が出ればイベントマスに到達し、所持金は 100 円になります。一方、2 が出た場合はゴールに到達し、所持金は 0 円のままです。これらはどちらも 2 分の 1 の確率で起こります。
さらに、1 回目でイベントマスに到達した場合は 2 回目のルーレットを回しますが、どの値が出てもゴールに到達し、所持金はどの場合も 100 円です。
このように、全部で 3 通りのゴールの仕方があります。ゴールした時点の所持金に着目すると、0 円になる場合が 1 通りでその確率は 2 分の 1、100 円になる場合が 2 通りでその確率が 4 分の 1 です。この場合、ゴールでの所持金の期待値は、ゴールの仕方ごとの (所持金 × その確率) を足した値であり、この人生ゲームの期待値は 50 円になります。
ルーレットの情報とボードの情報を入力とし、ゴール時の所持金の期待値を出力するプログラムを作成してください。
Input
複数のデータセットの並びが入力として与えられます。入力の終わりはゼロみっつの行で示されます。各データセットは以下の形式で与えられます。
X
Y
Z
V
1
V
2
...
V
X
N
1
E
1
A
1
N
2
E
2
A
2
:
N
Z
E
Z
A
Z
X
(1 ≤
X
≤ 4)、
V
i
(1 ≤
V
i
≤ 10)、
Y
(1 ≤
Y
≤ 50)、
N
i
(1 ≤
N
i
≤
Y
-1)、
Z
(0 ≤
Z
≤
Y
-1)、
E
i
(1 ≤
E
i
≤ 3)、
A
i
(1 ≤
A
i
≤ 100) は整数で与えられます。
データセットの数は 100 を超えません。
Output
入力データセットごとに、最終的な所持金の期待値を１行に出力します。なお、所持金の期待値は小数点以下切り捨ての整数で出力してください。
Sample Input
1 2 0
1
1 2 1
1
1 2 100
1 2 1
2
1 2 100
2 2 1
1 2
1 2 100
4 5 3
1 2 3 4
1 1 2
2 2 100
4 3 60
0 0 0
Output for the Sample Input
0
100
0
50
20


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
def solve(X, Y, Z, V, E, A):
    dp = [[0.0] * 6001 for _ in range(Y + 11)]
    dp[0][0] = 1.0
    for i in range(Y):
        for j in range(5001):
            if dp[i][j] <= 0.0:
                continue
            for k in V:
                t = i + k
                if t > Y:
                    dp[Y][j] += dp[i][j]/X
                elif E[t] == 1:
                    dp[min(Y, t+A[t])][j] += dp[i][j]/X
                else:
                    dp[t][max(0, j+A[t])] += dp[i][j]/X

    s = 0
    for i in range(5001):
        if dp[Y][i] <= 0.0:
            continue
        s += i * dp[Y][i]
    print(int(s))

if __name__ == "__main__":
    import sys

    while True:
        X, Y, Z = map(int, input().split())
        if X | Y | Z == 0:
            sys.exit()
        V = list(map(int, input().split()))
        E = [0] * 100
        A = [0] * 100
        for _ in range(Z):
            n, e, a = map(int, input().split())
            E[n] = e
            if e == 3:
                A[n] = -a
            else:
                A[n] = a
        solve(X, Y, Z, V, E, A)
```