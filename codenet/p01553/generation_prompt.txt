Voici un énoncé de problème :

問題名 箱根駅伝
日本のお正月の風物詩に箱根駅伝があります。箱根駅伝は、各チーム 10 人の走者が中継所ごとに襷をつなぎながらゴールを目指すというものです。テレビの放送では中継所で各チームの通過順位と共に前の中継所からの順位変動が表示されます。そこで、それを見て前の中継所の各チームの通過順として考えられるものが何通りあるか答えてください。ありえた通過順の数は非常に大きくなりうるので、1,000,000,007 で割った余りで答えて下さい。
Input
入力は以下の形で与えられます
n
c
1
c
2
...
c
n
1行目にはチーム数を表す数字
n
(
1 ≤ n ≤ 200
) が、続く
n
行には 1 位から順に前の中継所からの順位変動
c
i
('
D
' なら順位が落ちてる、'
U
' なら順位が上がってる、'
-
' なら順位が変わってない) が書いてあります。
Output
前の中継所でありえた通過順が何通りかを、 1,000,000,007 で割ったあまりで 1 行で出力して下さい。
Sample Input 1
3
-
U
D
Output for the Sample Input 1
1
この中継所を 1 位、 2 位、 3 位で通過したチームのチーム名をそれぞれ A, B, C とすると、前の中継所の通過順として考えられるのは 1 位：チーム A, 2 位：チーム C, 3 位：チーム B の 1 通りのみです。
Sample Input 2
5
U
U
-
D
D
Output for the Sample Input 2
5
この中継所の通過順にチーム名を A, B, C, D, E とすると、前の中継所の通過順として考えられるのは {D, E, C, A, B}, {D, E, C, B, A}, {E, D, C, A, B}, {E, D, C, B, A}, {D, A, C, E, B} の5通りです。
Sample Input 3
8
U
D
D
D
D
D
D
D
Output for the Sample Input 3
1
Sample Input 4
10
U
D
U
D
U
D
U
D
U
D
Output for the Sample Input 4
608
Sample Input 5
2
D
U
Output for the Sample Input 5
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
#!/usr/bin/env python3

import sys
import math
from bisect import bisect_right as br
from bisect import bisect_left as bl
sys.setrecursionlimit(2147483647)
from heapq import heappush, heappop,heappushpop
from collections import defaultdict
from itertools import accumulate
from collections import Counter
from collections import deque
from operator import itemgetter
from itertools import permutations
mod = 10**9 + 7
inf = float('inf')
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))

# 参考にしました(参考というよりほぼ写経)
# https://drken1215.hatenablog.com/entry/2019/10/05/173700

n = I()
dp = [[0] * (n+2) for _ in range(n+1)]
# 今回の順位と前回の順位を結んだグラフを考える
# dp[i][j] := i番目まで見たときに, j個繋がっているときの場合の数
dp[0][0] = 1
for i in range(n):
    s = input()
    if s == 'U':
        # Uのとき，今回順位から前回順位に向かう辺は必ず下向きなので
        # i+1番目まで見たときに今回順位からの辺によってjが増加することはない
        # jが増加するのは前回順位からの辺が上に伸びている場合
        # このとき，対応するペアを今回順位の中からi-j個の中から選ぶ
        for j in range(n):
            dp[i+1][j] += dp[i][j]# 今回順位からも前回順位からも下へ伸びている場合
            dp[i+1][j+1] += dp[i][j] * (i - j)# 今回順位からは下へ，前回順位からは上へ伸びている場合
            dp[i+1][j+1] %= mod 
    elif s == '-':
        # -のとき，今回順位から前回順位に向かう辺は必ず同じ位置であり，
        # 前回順位から今回順位へ向かう辺も必ず同じ位置である
        # つまり，jが1だけ増加する
        for j in range(n):
            dp[i+1][j+1] += dp[i][j]
    else:
        # Dのとき，今回順位から前回順位に向かう辺は必ず上向きなので
        # i+1番目まで見たときに今回順位からの辺によって必ずjが増加する
        # 前回順位から今回順位へ向かう辺が上向きの場合は，両方ともjが増加するのでj+2
        # 前回順位から今回順位へ向かう辺が下向きの場合は，jが増加しないのでj+1
        for j in range(n):
            dp[i+1][j+2] += dp[i][j] * (i - j) * (i - j)# 今回順位からも前回順位からも上へ伸びている場合
            dp[i+1][j+2] %= mod
            dp[i+1][j+1] += dp[i][j] * (i - j)# 今回順位からは上へ，前回順位からは下へ伸びている場合
            dp[i+1][j+1] %= mod
print(dp[n][n])
```