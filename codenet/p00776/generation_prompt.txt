Voici un énoncé de problème :

Encryption System
A programmer developed a new encryption system.
However, his system has an issue that
two or more distinct strings are `encrypted' to the same string.
We have a string encrypted by his system.
To decode the original string, we want to enumerate all the candidates of the string before the encryption.
Your mission is to write a program for this task.
The encryption is performed taking the following steps. Given a string that consists only of lowercase letters ('a' to 'z').
Change the first 'b' to 'a'. If there is no 'b', do nothing.
Change the first 'c' to 'b'. If there is no 'c', do nothing.
...
Change the first 'z' to 'y'. If there is no 'z', do nothing.
Input
The input consists of at most 100 datasets.
Each dataset is a line containing an encrypted string.
The encrypted string consists only of lowercase letters, and contains at least 1 and at most 20 characters.
The input ends with a line with a single '#' symbol.
Output
For each dataset,
the number of candidates
n
of the string before encryption should be printed in a line first,
followed by lines each containing a candidate of the string before encryption.
If
n
does not exceed 10, print all candidates in dictionary order;
otherwise, print the first five and the last five candidates in dictionary order.
Here, dictionary order is recursively defined as follows.
The empty string comes the first in dictionary order.
For two nonempty strings
x
=
x
1
...
x
k
and
y
=
y
1
...
y
l
,
the string
x
precedes the string
y
in dictionary order if
x
1
precedes
y
1
in alphabetical order ('a' to 'z'), or
x
1
and
y
1
are the same character and
x
2
...
x
k
precedes
y
2
...
y
l
in dictionary order.
Sample Input
enw
abc
abcdefghijklmnopqrst
z
#
Output for the Sample Input
1
fox
5
acc
acd
bbd
bcc
bcd
17711
acceeggiikkmmooqqssu
acceeggiikkmmooqqstt
acceeggiikkmmooqqstu
acceeggiikkmmooqrrtt
acceeggiikkmmooqrrtu
bcdefghijklmnopqrrtt
bcdefghijklmnopqrrtu
bcdefghijklmnopqrssu
bcdefghijklmnopqrstt
bcdefghijklmnopqrstu
0


En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
ans=[""]
ans.pop()
s=""
w=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","}"]
x=[0]
x.pop()
def uni(seq):
    seen = set()
    seen_add = seen.add
    return [ x for x in seq if x not in seen and not seen_add(x)]

def check(a):
	global s
	global w
	n=len(a)
	# print "before ",a
	for i in range(26):
		if i==0:
			continue
		a=a.replace(w[i],w[i-1],1);
	# print "after ",a
	if a==s[0:n]:
		return True
	else:
		return False

def foo(a,n):
	# print a
	global ans
	global x
	if n==len(a):
		if check(a):
			ans.append(a)
		return
	sz=len(a)
	t=a+s[sz]
	if check(t):
		foo(t,n)
	if w[x[sz]]=="z":
		return
	t=a+w[x[sz]+1]
	# print t
	if check(t):
		# print t
		foo(t,n)

while True:
	s = raw_input()
	if s=="#":
		break
	ans=[""]
	ans.pop()
	x=[0]
	x.pop()
	for i in range(len(s)):
		for j in range(26):
			if w[j]==s[i]:
				x.append(j)
	# print s
	foo("",len(s))
	# ans=uni(ans)
	ans.sort()
	if len(ans)<=10:
		print len(ans)
		for i in range(len(ans)):
			print ans[i]
	else:
		print len(ans)
		for i in range(5):
			print ans[i]
		for i in range(5):
			print ans[len(ans)-5+i]
```