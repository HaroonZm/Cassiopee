# 解法概要：
# - 盤面はH行W列の正六角形の格子で与えられる。座標 (x, y)は
#   横方向x, 縦方向yを示す。y=0が一番下の行で、yが大きいほど上の行。
# - 操作は指定位置の周囲の6マスのブロックを時計回りに1つ回転させる。
#   周囲6マスが盤面外なら操作はスキップ。
# - 回転の後、以下処理を繰り返す：
#   (1) ブロックの落下処理  
#       図Fig.3のルールに従い落下できるなら落下させる(一番下まで一括は不可。1度の反復は一段の移動を判定し続ける。)
#   (2) 同色の3つ以上連結ブロックの消去  
#       消えたらブロックなし（'.'）になる。
#   落下か消去が1度に1つでも起これば(1)に戻る。
# - 操作が0の初期状態でも上記処理は行う。
# - 最終盤面を出力する。
#
# 六角形の隣セルの接続はy座標の偶奇で変わるので、隣の座標計算に注意。

import sys
sys.setrecursionlimit(10**7)

H, W = map(int, input().split())
# 入力はy=H-1行目が上、y=0行目が下のデータなので、
# y=0が下になるように読み替え
lines = [input() for _ in range(H)]
board = [list(line) for line in lines]
board.reverse()  # これで y=0が下行、y増加で上行になる

Q = int(input())
operations = [tuple(map(int, input().split())) for _ in range(Q)]

# 六角形の周囲6方向 (yが偶数行の場合と奇数行の場合)
# Fig.1参照: 我々は(0,0)が左下なのでy増加方向は上
# 上記のマスの位置から6方向を定義する
# y偶数行の周囲6つ（x,y）+ (dx,dy)
even_dirs = [(-1,0), (-1,1), (0,1), (1,0), (0,-1), (-1,-1)]
odd_dirs  = [(0,1), (1,1), (1,0), (1,-1), (0,-1), (0,0)]  # 後で評価

# 周囲6方向を方向として定義（y偶奇で変わる）
# 正しいのは以下（六角形の格子の偏り対処）：
# yが偶数の時の6方向
even_dirs = [( -1, 0), (-1, 1), ( 0, 1), ( 1, 0), ( 0,-1), (-1,-1)]
# yが奇数の時の6方向
odd_dirs  = [( 0, 1), ( 1, 1), ( 1, 0), ( 1,-1), ( 0,-1), ( 0, 0)]  # これは誤り。正しいものを後述

# 修正
# 正六角形左下が(0,0)、yは上下方向行とすると、
# y偶数行の周囲6方向は (dx,dy):
# 上に一つ右左ややずれる方向。奇数行は逆方向ずれる
# y偶数:
#  0:左    (-1,0)
#  1:左上  (-1,+1)
#  2:右上  (0,+1)
#  3:右    (+1,0)
#  4:右下  (0,-1)
#  5:左下  (-1,-1)
# y奇数:
#  0:左    (0,0)
#  1:左上  (0,+1)
#  2:右上  (+1,+1)
#  3:右    (+1,0)
#  4:右下  (+1,-1)
#  5:左下  (0,-1)
# ただし左(0,0)は自身の座標なのでこれではだめ。
# 正しい奇数行の方向は次の通り:
# y奇数:
#  0:左    (0,0)  -> 本来左は方向0 (-1,0)に相当。1つずらす形で、
#     したがって y奇数行の左は(+0,0)? -> 自身のマスではないため不正
# 
# 正確にはy偶数・奇数で
#   周囲6方向のdx,dyは以下である。(Z座標の立体配置で定義。)
# 俗にいうoffset coordinateのeven-q layoutに基づく
# 参考：https://www.redblobgames.com/grids/hexagons/#neighbors-offset
#
# 上記リンクで、even-q (q=x, r=y) で y方向がr
# even q-column (xが偶数列):
# - neighbors = [(+1,0), (0,+1), (-1,+1), (-1,0), (-1,-1), (0,-1)]
# 奇数列ではルール異なる
#
# しかしこの問題はx,y座標もらえるので、x方向横、y方向縦で
# 偏りを考えると、ここではyは行数なのでy軸方向
#
# 問題の座標と動きの関係をFig.1, Fig.2から光学的に判断する
# GitHubの解答例等も参照せず、自力で暫定実装しよう
#
# よって本問題での隣接6方向は、yが偶数と奇数で下記を採用(問題別対応)

odd_dirs = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (0, 0)]  # 誤りなので修正要

# 別解：yが偶数行の場合の6方向(左、左上、右上、右、右下、左下)
dx_even = [-1, -1, 0, 1, 0, -1]
dy_even = [0, 1, 1, 0, -1, -1]

# yが奇数行の場合の6方向
dx_odd = [0, 1, 1, 1, 0, -1]
dy_odd = [0, 1, 1, 0, -1, -1]

# 0から5の6方向として扱うが、必ず6つである

# それぞれがoffset座標の周囲6方向

def get_neighbors(x, y):
    # 与えられた座標の周囲6方向の座標リストを返す
    neighbors = []
    if y % 2 == 0:
        for i in range(6):
            nx = x + dx_even[i]
            ny = y + dy_even[i]
            neighbors.append( (nx, ny) )
    else:
        for i in range(6):
            nx = x + dx_odd[i]
            ny = y + dy_odd[i]
            neighbors.append( (nx, ny) )
    return neighbors  # 6つの座標リスト

def inside(x,y):
    return 0 <= x < W and 0 <= y < H

# 指定座標の周囲6つを時計回りに一つ回す操作を行う関数
def rotate_around(x, y):
    # 周囲6マス座標
    neighbors = get_neighbors(x,y)
    # 自身は回転しない。周囲6マスのブロックを時計回りに移動
    # ただし座標が盤面外なら操作しない
    # チェック：中心と周囲6マスすべて盤面内か
    if not inside(x,y):
        return  # 中心が盤面外なら無視（あってはならないが）
    for (nx, ny) in neighbors:
        if not inside(nx, ny):
            return  # 周囲に盤面外があれば回転しない

    # 周囲6つの色を抜き出す (盤面内なので全て取得可能)
    colors = []
    for (nx, ny) in neighbors:
        c = board[ny][nx]
        if c == '.':  # 空マスは'.'だが操作前は存在しないが注意
            colors.append('.')
        else:
            colors.append(c)

    # 時計回りに一つ回転させるとは、色を一つ右方向にシフト
    # [c0,c1,c2,c3,c4,c5] -> [c5,c0,c1,c2,c3,c4]
    colors = [colors[-1]] + colors[:-1]

    # 反映
    for idx, (nx, ny) in enumerate(neighbors):
        board[ny][nx] = colors[idx]

# 落下処理の判定と適用
# Fig.3のルール：
# ブロックAの位置からB, C, Dの位置のうち
# B, Dいずれか片方が存在しない場合、ブロックは存在しないと考える→落下可能とみなす
# Cのマスが存在しなければ落下しない
# B,C,DはFig.3での特定方向（以下にコード化）
#
# 落下は上記を満たせば一つ下に落ちる(マスCに移動)
# これをできる限り繰り返す。
#
# 盤面のいくつかの落下方向を定義し各ブロックについて判定
#
# y=0が下であることに注意

# Fig3を参考に下方向への落下関係：
# 落下方向は以下パターン6つ：
# Aの座標(x,y)に対して、その下に落下先と
# 「B,C,D」位置が以下のように定義されている（問題文Fig.3より）
#
# A(0)
# B,C,Dは(0基準からのoffset)
# 下方向移動方向は、y-1方向が下
#
# 対応する6パターン（落下方向）は以下。
#
# 方向番号とoffset(x,y)のリスト:
#  0: 下方向の落下
#  1: 右下方向の落下
#  2: 右方向の落下
#  3: 上方向（落下しない方向）
#  4: 左上方向（落下しない）
#  5: 左方向（落下しない）
#
# しかしただの6方向ではなく、
# 落下は垂直方向とその斜め2方向のうちいずれかの可否判定。
#
# 具体的方針：
# 各マスに対し「落下先候補」の3方向を定義し判定
#
# 最もポピュラーな落下判定方法：
#  1. 対象ブロックAの足元Cの座標
#  2. Cの左の隣接点B座標と右の隣接点D座標
#  3. B,C,Dの存在とブロックの有無から落下判定
#
# なので必要なもの：
# ・それぞれAから見て「落下先」がC
# ・B, Dの座標（Cの左右隣）が必要
# 
# 六角形盤面座標上の下方向で落下パターン3つを考える：
# 偶数行と奇数行で周囲座標が変わるため落下チェックはyの偶奇別に条件分岐
#
# 以下の実装方針では、それぞれ落下パターンで
# B,C,Dのオフセットを定義し、実際に盤面内かを判定し、
# 落下可能ならブロック移動を行う。

# y偶数の時の落下判定用offset（dx, dy）
# 方向0: 下方向
fall_dx_even = [(-1,-1),(0,-1),(1,-1)] # B,C,D
# 方向1: 右下方向
fall_dx_even_1 = [(0,-1),(1,-1),(1,0)]  # B,C,D
# 方向2: 右方向
fall_dx_even_2 = [(1,0),(1,1),(0,1)]    # B,C,D

fall_dx_even_list = [fall_dx_even, fall_dx_even_1, fall_dx_even_2]

# y奇数の時の落下判定用offset（dx, dy）
fall_dx_odd = [(0,-1),(1,-1),(1,-2)]  # B,C,Dの意味は同じ(調整必要)
# 奇数はx,y軸の座標系に適合するようオフセットを調整
# ただしこんな落下は難しいため
#
# 仕様を簡単にするため、落下は「下方向側の3マス」のうち真ん中が落下先C、と決め打ちして、
# これら3つの相対位置はy偶奇で変える
#
# 上で定義していないので、ここは以下の方式を採用する：
fall_offsets = {
    0: [(-1,-1), (0,-1), (1,-1)],
    1: [(0,-1), (1,-1), (1,0)],
    2: [(1,0), (1,1), (0,1)],
}

fall_offsets_even = fall_offsets
fall_offsets_odd = {
    0: [(0,-1), (1,-1), (1,-2)],
    1: [(1,-1), (1,0), (0,0)],  # これらは推測なので慎重に扱う必要あり
    2: [(1,0), (1,1), (0,1)],
}

# ここで落下判定とするため、定義通り使う
# 複雑なので実装では落下できるかどうかの基準は次でなくして、
# 代わりに問題文Fig3の説明通り：
# - Aから見て落下先はC
# - B,C,Dがない場合は落下できる（B,Dがない場合ブロックも存在しないと考える→落下可能条件を満たす）
# - Cが盤面外なら落下処理しない(落ちる先がない)

# 処理の実装方針：
# 各マスAについて3つの方向で落下判定を試みる。
# 落下可能なものがあれば一つ落下させ、処理を続行。
# 落下は1度の判定時に複数回させず、一つずつ移動させる。

# 六角形の左下基準座標に対し、落下判定の3方向（下側3方向）を問題仕様に合うように定義。

# 問題のFig.3より、
# Aから落ちる先（C）はその下（y-1）の1つのマス。
# BはCの左隣、DはCの右隣となる。

# 落下方向は3つあるが、yの偶奇でズレる。

# 以下のコードは落下試行の試み(落下のパターンは3パターン全て試す)
def can_fall_and_move():
    # 落下ができたらTrueを返し、移動を実行する
    # できなければFalseを返す
    for y in range(H):
        for x in range(W):
            c = board[y][x]
            if c == '.' or c is None:
                continue  # 穴、空マスは落下判定不要
            # 探す落下方向3方向を試す
            # y偶数奇数でoffsetを切り替えて判定
            # それぞれB,C,Dを取得し、条件を満たせば落下
            if y % 2 == 0:
                offsets = fall_offsets_even
            else:
                offsets = fall_offsets_odd
            for k in range(3):
                (bx,by) = (x + offsets[k][0][0], y + offsets[k][0][1]) if isinstance(offsets[k][0], tuple) else (x+offsets[k][0], y+offsets[k][1])
                (cx,cy) = (x + offsets[k][1][0], y + offsets[k][1][1]) if isinstance(offsets[k][1], tuple) else (x+offsets[k][1][0], y+offsets[k][1][1]) if isinstance(offsets[k][1], tuple) else (x+offsets[k][1], y+offsets[k][1])
                (dx,dy) = (x + offsets[k][2][0], y + offsets[k][2][1]) if isinstance(offsets[k][2], tuple) else (x+offsets[k][2], y+offsets[k][2])
            # 上の式は誤りで複雑なので修正する

    return False

# 上記は非常に複雑で間違い易いので以下の別実装を行う。

#