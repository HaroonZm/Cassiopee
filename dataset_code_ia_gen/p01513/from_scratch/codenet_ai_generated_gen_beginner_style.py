while True:
    N = int(input())
    if N == 0:
        break
    know = []
    for _ in range(N):
        line = input().split()
        M = int(line[0])
        if M > 0:
            info = list(map(int, line[1:]))
        else:
            info = []
        know.append(info)
    last = input().split()
    K = int(last[0])
    leaked = set(map(int, last[1:]))

    candidates = []
    for i in range(N):
        # i+1 番号の構成員が犯人の可能性を調べる
        if not leaked.issubset(set(know[i]) | {i+1}):
            # 漏洩した全員を知っていないなら犯人ではない
            continue
        
        # 仮にこの人が犯人であるとすると矛盾しないか調べる
        # 漏洩リストにある人は犯人から見て情報リークされたと考える
        leaked_from_cand = set()
        leaked_from_cand.add(i+1)
        leaked_from_cand.update(know[i])

        # 犯人が知っている全員の情報の一部だけ流出させた可能性がある
        # だから漏洩した全員は犯人が知っている中に含まれている必要がある(上でチェック済み)
        # そして、犯人でない他の候補は漏洩リストに含まれない人を流出させたとすると矛盾になる
        # すなわち他の候補の知っている情報は漏洩リストの外の番号と重ならないことが必要

        # ここでは単純に、他の候補の知っている人で漏洩リストにない番号がある場合矛盾とみなす
        okay = True
        for j in range(N):
            if j == i:
                continue
            # j番の知っている情報に漏洩リストにない番号があって、
            # それはj本人が漏洩したと考えると可能だが
            # 漏洩リストに入ってなければ矛盾
            # つまり、自分の知っている人が漏洩リストに全部含まれているか確認
            known_set = set(know[j])
            # j番の知っている中漏洩リストにないものが一つでもあれば
            # jは犯人候補外としてよい
            # 逆にj番が犯人候補になるためには
            # 漏洩リストはすべてjが知っている必要がある（または漏洩リストすべてjが流したなら）
            # 本問題設定から、犯人は自分の知っている情報の一部か全部を流出させる可能性あり
            # しかし漏洩リストにある情報がjの知らないものがあると矛盾になる
            # つまりjが犯人候補であるためには、漏洩リストはjが知っている情報の部分集合でなければならない
            # したがって、先に漏洩リスト⊆ 知っている人集合 と判定済み
            # ここは他の候補の知っている情報に漏洩リストにない番号があるかは重要ではない
            # よってこの判定は省く

            # しかし、漏洩していない情報を他の候補が知っていたとすると
            # もしその情報が漏れたら漏洩リストに入るはずだが入っていないという矛盾も議論すべきだが
            # 問題の指示が曖昧なので単純な判定とする

            # よって追加の矛盾は考えずOKでよい
            pass
        if okay:
            candidates.append(i+1)

    if len(candidates) == 1:
        print(candidates[0])
    else:
        print(-1)