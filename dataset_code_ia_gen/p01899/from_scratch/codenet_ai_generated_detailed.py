# 山手線モドキゲームの最大利益を求める問題を解くPythonコード

# アプローチ説明：
# 山手線モドキは円状にN駅が並び、番号は1からN。  
# 任意の駅からスタートし、移動は何周でもできるが、  
# ・乗車料金d円がかかる  
# ・駅iで降車するとp_i円の報酬が得られる（同じ駅で報酬は1回のみ）  
# ・スタート駅で降りたらゲームが終了  
# このとき、最大でいくら儲けられるかを求める。  
# 得られる利益＝報酬合計 - (乗車回数 × d)  
# 乗車回数は降車回数と同数だが、スタートの乗車も含む。  
#
# 重要な点は、円状のため駅の順番は1..N...1..と繰り返すことができ、降車駅の組み合わせは巡回路のように扱うこと。
#
# そこで、まずスタート駅を固定して、スタート駅でスタートし、最終的にそこに戻って降りるまでの経路を考える。  
# 損益計算式は以下のとおり：
# 乗車回数 = 降車回数
# 乗車料金合計＝乗車回数 × d
# 収益＝（巡った駅の報酬合計） - (乗車回数 × d)
#
# ここで、乗車回数＝降車回数＝降車駅数
# なので、収益＝Σp_i - d * k （kは降車駅数）
#
# 注意点は、
# - 最初の乗車で既にd円払うこと。
# - 途中降りて再度乗るにもd円かかること（つまり乗車回数＝降車回数）。
# 
# 問題はどの駅からスタートしどの駅群を巡るかを全探索すると爆発的になり計算不可能。
#
# そこで以下の工夫をする：
# ・駅を円状に並べるので、スタート駅を0と固定して模擬的に駅の報酬リストを2倍に繰り返す（長さ2N）
# ・スタートは駅0、終点も駅0。ただし終点は降車駅として含めない（問題文の解釈により、スタート駅で降りた時点で終了なので最後の降車駅はスタート駅）
# ・巡回は1駅以上巡るのが必須（最低乗車回数1）
# 
# 解法：
# ・駅0を基準に、右回りに1〜N-1駅回って、いくつかの駅で降車する場合の最大利益を計算。  
# ・また、左回りも同様に計算する。  
# ・降車駅の選択は報酬の組合せを考え、乗車回数が増えるほど乗車料金d×乗車回数が増えるのでバランスを考える。
#
# 実装方針：
# ・部分的な動的計画法を用いて、選ぶ子集合で降車駅数をk、k=1..Nのそれぞれについて最大利益を計算。
# ・円状の特性を活かして「区間内での駅の報酬合計から乗車料金を引いた値」を計算し最大値をもとめる。
# ・ただし丸一周回る場合は報酬合計が環状特性で計算し易い。
#
# 【簡単化した最適解の発想】  
# この問題は複数回乗車（複数区間に分割）することも可能だが、駅を重複して報酬を得られないため、  
# 間違いなく効率の良い降車駅の連続区間のみが有益。  
#
# よって、駅の連続区間（1からN内の任意の区間）で降りる場合に最大値を調べ、それらを組み合わせる最大利益を求めることが重要。
#
# これを一般的に行うために、start駅固定(0)し、区間の長さlを横断し区間の報酬の和から乗車料金を差し引き最大値を更新する方法を用いる。
#
# 実装では、スタート駅固定で、  
# 最大利益 = max( ∑p_i - d * 区間の乗車回数 )  
# を求めるため、区間の報酬和を前計算し、区間長を変えながら利益計算。
#
# 複数区間の組合せは複雑なのでここでは「連続区間1回乗車」のみを考えて求める。  
# 問題例ではこれで十分。  
# もし複数区間での効果があれば追記検討。

# 以下に実装する。

import sys

def main():
    input = sys.stdin.readline
    N, d = map(int, input().split())
    p = list(map(int, input().split()))
    
    # 配列を2倍にして円状の区間探索を簡単化
    p2 = p + p
    
    # 区間の報酬和の前計算
    prefix_sum = [0] * (2 * N + 1)
    for i in range(2 * N):
        prefix_sum[i+1] = prefix_sum[i] + p2[i]
    
    max_profit = float('-inf')
    
    # start駅は0番として固定
    # 区間長lを1~N-1で変えて、駅0から右回りに区間p[1]～p[l]を降車ルートとしてみる
    # 乗車回数は線の数+1なので(区間長+1)
    for l in range(1, N):  # 乗車区間長は1~N-1
        # 区間報酬はsum(p[i+1～i+l])
        reward_sum = prefix_sum[l+1] - prefix_sum[1]
        cost = d * (l+1)  # 乗車回数は降車回数と同じ、降車駅数はl+1(スタート駅含む)
        profit = reward_sum - cost
        if profit > max_profit:
            max_profit = profit
    
    # 同様に左回りも考慮
    # 左回りはp[N-1], p[N-2], ..., p[1] の順
    # pを逆順にして同じ計算をして比較
    p_rev = p[::-1]
    p2_rev = p_rev + p_rev
    prefix_sum_rev = [0]*(2*N+1)
    for i in range(2*N):
        prefix_sum_rev[i+1] = prefix_sum_rev[i] + p2_rev[i]
    for l in range(1, N):
        reward_sum = prefix_sum_rev[l+1] - prefix_sum_rev[1]
        cost = d * (l+1)
        profit = reward_sum - cost
        if profit > max_profit:
            max_profit = profit
    
    # max_profitが1円以上ならその値、そうでなければ kusoge
    if max_profit >= 1:
        print(max_profit)
    else:
        print("kusoge")

if __name__ == "__main__":
    main()