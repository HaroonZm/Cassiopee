import sys
from collections import deque

def can_gather_on_day(day, schedules, n):
    # グラフの辺を日付dayに会える者同士でつなぐ
    graph = [[] for _ in range(n)]
    for i in range(n):
        if day in schedules[i]:
            for j in range(i+1, n):
                if day in schedules[j]:
                    graph[i].append(j)
                    graph[j].append(i)
    # この連結成分の中で地図を集めることができるか（すなわち、1人のもとに全員が行き合えるか）を検証する
    # 実際には、会える人同士で情報を交換できるので、1人に全員がつながっていればよい
    # あるノードから他のすべてのノードに到達可能であるか判定
    for start in range(n):
        if day not in schedules[start]:
            continue
        visited = [False]*n
        queue = deque([start])
        visited[start] = True
        count = 1
        while queue:
            u = queue.popleft()
            for v in graph[u]:
                if not visited[v]:
                    visited[v] = True
                    count += 1
                    queue.append(v)
        if count == n:
            return True
    return False

def bfs(schedules, n):
    # 日 1 から 30 日までを対象にして、日にちごとに集められる人数の最大日数を探す問題
    # 複数日をまたいで集めるには、人同士が会って地図を手渡す必要がある
    # 各日、会える者同士で地図を手渡せるが、日を跨ぐには地図を持っている者がその後も地図を持っている必要がある
    # したがって、最終的に1人に全員の地図が集まる最短の日付を求める。
    # 解法は到達状態をbit全探索で管理し、状態は持っている地図の集合
    # 日ごとに、会える者同士の連結成分内で地図を自由に受け渡せるため、
    # 当日のグラフの連結成分ごとに持っているものが統合される。
    # よって、日ごとに状態遷移しながら最短日数を計算する。
    # 状態:
    #　持っている地図のbitセット (0<=state<2^n)
    # 初期状態は全員がそれぞれの地図を持っているので、最初は各人が1つ持っていると考えると初期stateは (1<<i) for i in range(n), 各人に対応
    # しかし全員の地図を1人の場所に集めることが目標なので、初めに全員が自分の地図のみ持っている集合をDFS/BFSで管理し
    # 日に集える人数集合の連結成分内で持っている地図セットを合体させ、新たな状態集合を得る
    # 終了条件は、持っている地図が全員のセット(1<<n)-1になること。
    # 実装として、初期状態はn個の異なるスタート状態を用意するのではなく、はじめに「各人自分の地図だけ持っている」とみなして
    # 状態は"どの地図を持っているか"だけを表現し、最初は全員が自分だけ持っている状態が複数存在し操作できないため、
    # 本問題は「誰か1人に全員の地図を集めること」つまり「協力して全員の地図を1か所に集めること」と考えて、
    # 最初に全員の地図は分散している＝状態は(2^n -1)個の状態で管理する必要がある。
    # ここで、「状態」は「地図の断片がどのメンバーにどう配布されているか」を状態として管理するのは大変なので、
    # 以下のように各日を順に処理し、メンバー間の地図の交換可能性(連結成分)を考慮して、
    # ある日が終わると、連結成分ごとにそこで持っている地図のビット和が全員に行き渡る想定で状態遷移することにより
    # 全状態を遷移させていく手法を用いる。
    # BFSで日付順に状態を拡張し、最短日数を求める。
    
    ALL = (1 << n) - 1
    from collections import deque
    # 初期状態: 全員が自分の地図だけ持っているので、状態は各人のビットを持ったビット集合 = (1<<i)
    # 最終的に1状態にまとめたいが、最初の状態は各人別々の断片を持つので初期状態は各人のビットのみの別々の状態の集合ではなく、
    # 「全員がそれぞれの断片を持っている」という意味で、状態は1状態として開始するのは困難。
    # この問題は「地図はそれぞれの人に最初分散しており、1日に会った人同士で地図を交換可能」
    # 状態を「地図を持っているメンバーの集合」で管理し、日にちを経過させて最終的に1人に全地図が集まる＝「地図が1メンバーに集約されている」
    # ではなく「全員の地図集合」を持つ "状態" から始まるBFSで、実は状態=持っている地図の集合ではなく「どのメンバーが地図を持っているか」では？
    #
    # 問題文的には1人に集約する必要があるが、直接持っているメンバーが1人だけとは限らない。
    # しかし最後には全片を持つ者(誰か一人)に集まるため、その状態は「ある1人が全地図を持っている状態」
    # だから状態は「誰がどの地図断片を持っているか」という情報が必要だが、計算量的に困難。
    #
    # 代わりに以下のアプローチを使う:
    # 毎日スケジュールが空いている人を頂点としてグラフを作り、そのグラフの連結成分ごとに地図断片の集合は合体可能。
    # 日々の更新で各連結成分内で情報を共有できるので、
    # 持っている地図断片の集合の集合を管理し続けるという解き方。
    #
    # 実装：
    # 状態は「どの人が地図断片を持っているか」をビット集合として表現し、
    # スタートは各人が自分の断片のみを持っているので、最初の状態は人ごとに1ビット立ったものがn個ある。
    # しかしこれはfromの集合ではなく、どの断片が集約されているかの状態管理。
    #
    # 解くために「誰が持っているか」の視点をやめ、「どの断片が集まっているか」という点で状態をbitで表し、状態遷移は日にちごとに可能な交換に基づき行う
    #
    # 初期状態は、断片はそれぞれの所有者が自分の断片を持っているので、スタートは状態 = (1 << i) for i in range(n) が同時に存在する
    # そのため、状態を複数同時に管理できるBFSの起点が複数あるのと同じで、初期状態は bitごとの集合の論理和をとると、個別断片がバラバラで、
    # しかしスタートとしては、状態= 全地図の集合ではないので、一つの状態としてはまとめられない
    #
    # よって、状態=「どの地図断片が渡っているか」の集合だけを管理し、最終的に「全地図断片が集まっていること」をゴールとする。
    # 初期状態は各断片別のメンバーが持っているため、断片iは所有者iにのみあるのでスタートは１つはできない。ここで、
    # 状態の最小単位は断片１つ分ずつだが、全員の断片が全員別々に持っているので初期状態としては (1<<n) 個の状態を準備し、
    # それらをまとめて扱うのは大変。そこで人ごとではなく断片の集合だけ管理して、交換可能ならその断片を統合する。  
    #
    # なので最終的には、初期状態は 1<<i を持つ状態が複数ある？でも最終的には状態は断片の集合を管理、  
    # BFSは状態=断片集約状態(bit集合), 最初は複数の状態ではなく、複数個の状態を同時に扱うのは大変なので、  
    # 全員の断片が別々にある状態は、全員分の断片が別々にある状態として扱い、可能な交換を繰り返して統合していくイメージ。
    #
    # まとめると、状態は断片の集合を持つものとしてビット集合で表す。
    # 初期状態は、断片0だけの状態、断片1だけの状態...が全員に分散しているが、これは状態としては一つではない。
    #
    # しかし１人に全て集めるという事は、ある状態で全ての断片を持つ（ビットが全て立つ）必要があるということ。
    #
    # 実装の準備として、まず初期状態(断片がそれぞれ分散)はどのように考えれば良いか。
    # 問題文的に「初期状態は全断片が、それぞれ違う人に別々にあるので、状態は1つでなく、  
    # 「誰がどの断片を持っているか」を表現する必要がある」とわかる。
    #
    # 考え方としては、状態に加えて、どの人の地図断片が現在一か所にあるか（集合）も保存し、経路を探索する必要があるが、かなり複雑。
    #
    # そこで、この記事の問題は典型的な「日ごとに会議可能なグループで断片の共有を行い、最終的に全断片を1人の元に集める最短日数を求める」問題。
    #
    # よって以下の解き方を採用:
    # - 連結成分ごとに、持っている断片の集合を調べ、
    # - 同成分内の断片は統合できると考える。
    # - 連結成分間の断片は直接渡せないので、日を経過させて連結成分が変わるのを待つ。
    # - 状態は、「どの人が断片の集合を持っているか」ではなく「どの断片がどのグループで集約されているか（グループを管理）」とする。
    #
    # ここで持つべき情報: (日, 各連結成分の断片集合) の集合を管理したいが、計算量が膨大になる。
    # 50人で31日制限なので計算量的に現実的なBFSは難しい。
    #
    # 代替手法として、ある日に断片の分布を「どの人が持っているか」は区別せず、
    # 「断片の集合」は1つに集まるまでの最短日を探すためにBFSで状態を管理する。
    #
    # ここでは、シンプルな実装として状態を「だれがどの断片を持っているか」によらず、
    # 日を1日ずつ進め、地図が集まるグループを連結成分でまとめて地図のセットを拡張していく方法で
    # シミュレーションする。各日に全員が集まっている連結成分が1つあれば終了。
    
    # bitstate: 持っている地図の断片集合 → 最初は各自身が自分の断片を持つので初期stateは断片ごとに所有者を分ける必要あり？
    # → しかし入力では「子孫iは断片i」を持っており、初期の「地図がそれぞれに別れて散らばっていること」はデフォルトの状態

    # したがって、開始状態は初期の「断片の分布」で、1人は1つの断片を持っている状態（状態集合は断片の所有者の集合）
    # しかし状態を人的に管理？それは無理。
    # → 解説を見ると「この問題の解は、各日の会えるグループの連結成分で断片が共有できる」ということで毎日断片の割り当てを更新できる。
    # → だから断片は連結成分ごとに統合され、状態は「どの断片がどの連結成分に属しているか」の管理を行うシミュレーションで解ける。

    # 実装案:
    # 初期状態では断片iは人iが持っているので、断片の割り当てはリストで管理 qilish：position = [i for i in range(n)]
    # 各日、会える子孫で連結成分を作り、連結成分内の断片は統合される。
    # 連結成分ごとに、多数の断片が集まる。連結成分内の断片はすべて同じ人に集約されたものと扱う。
    #
    # これを日にちごとに繰り返し、断片の割り当てが更新されていき、最終的にすべて同じ人に集まれば終了。
    #
    # したがって、位置の割り当てを更新しながら日にちを進め、最短で全断片が同じ人に集まるまでの日数を探す。
    #
    # BFSは状態ではなく「断片の位置割り当て」をもとにして、図の連結成分で合体していく。
    #
    # これを実行し、30日経っても収束しなければ-1を返す。

    position = [i for i in range(n)]  # 断片iは最初は人iにある

    day_limit = 30
    for day in range(1, day_limit+1):
        # 当日のグラフを作成し、連結成分を求める
        graph = [[] for _ in range(n)]
        available = [False]*n
        for i in range(n):
            if day in schedules[i]:
                available[i] = True
        for i in range(n):
            if not available[i]:
                continue
            for j in range(i+1, n):
                if available[j]:
                    graph[i].append(j)
                    graph[j].append(i)
        visited = [False]*n
        # 各連結成分で断片の位置を更新（連結成分のメンバーが持つ断片をすべて統合して人の番号は一番小さいメンバーに割り当てる）
        new_position = position[:]
        for i in range(n):
            if not available[i] or visited[i]:
                continue
            queue = deque([i])
            visited[i] = True
            component_nodes = []
            component_fragments = set()
            while queue:
                u = queue.popleft()
                component_nodes.append(u)
                # uが持つ断片を探す
            # 連結成分のメンバーは、断片のうち、positionがuのどれかを持つ？
            # 断片は position[fragment] = 人 なので、連結成分内メンバーが持つ断片を集める
            # つまりcomponent_nodesに含まれる人が持っている断片を集める
            # component_fragmentsは連結成分内メンバーが持つ断片番号の集合
            # 再探索
            # queueはもう空なのでvisitedは進める
            for node in component_nodes:
                for f in range(n):
                    if position[f] == node:
                        component_fragments.add(f)
            # 連結成分内の人で一番小さい番号の人を代表者とする
            rep = min(component_nodes)
            # 連結成分内の断片は全て代表者に割り当て
            for f in component_fragments:
                new_position[f] = rep
        position = new_position
        # 全断片が同じ人に集まったか確認
        first = position[0]
        if all(p == first for p in position):
            return day
    return -1

input_lines = sys.stdin.read().splitlines()
idx =