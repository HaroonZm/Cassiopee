while True:
    w, h = map(int, input().split())
    if w == 0 and h == 0:
        break

    # dp[i][j][k]: i番目の道路まで南北方向に進み、j番目の道路まで東西方向に進んだとき、
    # 直前の移動方向がk（0=なし, 1=東, 2=北）の通勤経路の数
    dp = [[[0]*3 for _ in range(h+1)] for __ in range(w+1)]
    dp[1][1][0] = 1

    for i in range(1, w+1):
        for j in range(1, h+1):
            for k in range(3):
                if dp[i][j][k] == 0:
                    continue
                # 東に進む場合
                if j < h:
                    # 直前の移動が北(2)なら曲がっているので次は曲がれない(東に曲がれない場合スキップ)
                    # 問題文では「曲がった後に1ブロックだけ進んで再び曲がることはできない」
                    # なので、曲がった直後は曲がれない。 この判定は直前の移動が異なる場合は曲がった。
                    # kが1=東なら同じ方向だから曲がってない。
                    # kが0=なしは最初なので曲がってない。
                    # kが2=北今回東に曲がろうとするので曲がっている。このとき曲がった直後なので次は曲がれない。
                    # 実際には曲がった直後は「曲がった」を記録し次は曲がらず直進できるように制御するのが正しいが、
                    # シンプルに「曲がった直後は曲がれない」をフラグで管理するのが良い。
                    # ここではkが直前の移動なので
                    # 曲がった直後かどうかは別のフラグを追加しないと厳しい。
                    # 初心者的解法として、直前の移動方向と前々の移動方向の情報を持つことは複雑なので、
                    # ここではk=0は直前移動なし、k=1は東で曲がっていない、k=2は北で曲がっていない
                    # 今回東の時、前回が北(2)なら曲がっているので今回は曲がれない、つまりパス
                    # そうでなければ更新
                    if k != 2:
                        dp[i][j+1][1] += dp[i][j][k]
                        dp[i][j+1][1] %= 100000
                # 北に進む場合
                if i < w:
                    # 同様に前回東なら今回北に曲がれない
                    if k != 1:
                        dp[i+1][j][2] += dp[i][j][k]
                        dp[i+1][j][2] %= 100000

    ans = (dp[w][h][1] + dp[w][h][2]) % 100000
    print(ans)