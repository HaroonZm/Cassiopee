import sys
import heapq
input=sys.stdin.readline

N,M,s,t=map(int,input().split())
d=list(map(int,input().split()))

# グラフ構築
# i次元からi-1,i-2,...1次元へは自由に移動可能（コスト0）
# 魔法はa_i次元からb_i次元に移動可能（コスト d[b_i-1] ただし呪いの免除に注意）

# 呪い免除の効果：i次元の呪いを受けたら、iより下の次元の呪いは受けない
# → つまり、i次元の呪いを受けたら、移動経路上で iより小さい次元のd_iは0になる

# 解釈：
# 最適解は、上昇移動（魔法使用）を何度か行い、
# 降下移動は自由でコスト0
# 呪いは降りた次元では受けないため、
# 呪いは上昇時に到達した次元の最大値に限られる
#
# よって、状態を「現在地の次元」「これまでに呪いを受けた最大の次元」として管理するのは重い。
#
# 代わりに次元ごとに最小コストを管理し、更新するとき呪い免除を適用する。

# 方針：
# dijkstra で以下の点を考慮
# ・下降移動は無料で任意のj < i に移動できる（一括で処理すると効率的）
# ・上昇は魔法分だけで、その魔法のコストは d[b_i-1] だが、
#   もしすでにそれより大きい次元の呪いを受けていれば、その次元は免除されるので
#   呪いは max(過去最大の呪いを受けた次元, 現在移動先次元) の d 値のうち最大をとっていけば良い
#
# しかし、免除のルールは「i次元の呪いを受けたら、それより小さい次元の呪いは受けない」ということなので、
# ダメージは最大の次元でしか発生しない。なぜなら最初の呪いを受けた時点でそれより下の呪いは全部免除される。
#
# → つまりコストは常に最大の呪いを受けた地点のd値になる
#
# したがって最大の次元の呪いを受けることの累積がコストだけど、
# 呪いの累積ではなく、最大ダメージの sum でないため注意。
#
# 例：
# sからtへの経路上で呪いを複数受けることは可能？
# 受ける呪いはそれぞれの「次元の呪い」を受けた時点でその次元および以上の次元でしか効かない。
#
# それゆえ、複数回の上昇を伴う移動中に受ける呪いの計算は
# それらの受けた次元の呪いダメージの最大値の合計と等しい


# したがって次元を頂点、魔法の移動を辺とし、頂点のd値を辺のコストと考える(damageは到達時)
# 降下は任意でできるので、その部分の遷移はコスト0で表す
#
# 降下は i 次元から j (j < i) へ自由移動可能→一方向辺、コスト0
#
# このグラフはN頂点、辺M+ (N-1) (降下部分)　
# dijkstraでsから始めて最小コストを求めればよい

# グラフの辺の構築
G=[[] for _ in range(N+1)]
for i in range(2,N+1):
    # 降りる辺（i->j, j=i-1）でよい
    G[i].append((i-1,0))
for _ in range(M):
    a,b=map(int,input().split())
    # 魔法はa->bへ d[b-1]ダメージ(cost)
    G[a].append((b,d[b-1]))

INF=10**15
dist=[INF]*(N+1)
dist[s]=0

hq=[(0,s)]
while hq:
    cost,v=heapq.heappop(hq)
    if dist[v]<cost:
        continue
    if v==t:
        print(cost)
        break
    for to,w in G[v]:
        ncost=cost+w
        if dist[to]>ncost:
            dist[to]=ncost
            heapq.heappush(hq,(ncost,to))