# 問題の概要と考え方：
# - 文字列Sの各文字に対して、移動方向が決まる（U, D, L, R）。
# - 魔法1：以降のUとDを逆転させる。
# - 魔法2：以降のLとRを逆転させる。
# - 魔法は各文字を読む直前に任意回数かけられるが、合計でK回まで。
# - 目的は、すべて読み終えた後の点Pのマンハッタン距離 |x| + |y| を最大化すること。
#
# 魔法の効果は累積的に作用し、i文字目以降の文字の解釈が上下反転・左右反転する可能性がある。
# 魔法の適用回数に制限があり、複数回かける、両方かけるのも可能（効果はパリティによる反転）。
#
# キーポイント：
# - 魔法1の適用回数の偶奇で上下の反転状態が変わる
# - 魔法2の適用回数の偶奇で左右の反転状態が変わる
# - よって魔法の状態は「上下反転フラグ」と「左右反転フラグ」の2ビットで管理できる
#
# 状態：
# - i: 現在の処理中の文字位置（0～|S|）
# - k: これまでに使った魔法回数 (0～K)
# - f1: 魔法1の反転状態 (0か1)
# - f2: 魔法2の反転状態 (0か1)
#
# DPの状態は dp[i][k][f1][f2] = (x, y) で、現時点での座標位置を管理。
# 同じ状態で複数候補があれば、マンハッタン距離が大きい方を採用。
#
# 遷移：
# - i文字目を読む直前に、魔法1, 魔法2を0回かけるか、あるいは何回かけてもよいが実質的な効果はフラグの反転になるので
#   → 魔法適用回数増加に注意しながら f1, f2 を0か1にトグルして遷移
# - 魔法は任意回数かけられるが、効果は状態の偶奇だけなので
#   → 実質的には魔法をかけるかどうか（適用するかしないか、魔法1だけかけるか、魔法2だけかけるか、両方かけるか）の4パターンのみ
# - もし合計でかけられる回数が足りなければその遷移はできない

# 最後にdp[|S|][k][f1][f2]の中で最大の|x|+|y|を求める

S = input()
K = int(input())

N = len(S)

# 各文字を読み込むときの座標変化を計算する関数
# f1が1なら上下反転（U <-> D）
# f2が1なら左右反転（L <-> R）
def move(ch, f1, f2):
    # 反転をかけた後の文字を決定
    if f1 == 1:
        if ch == 'U':
            ch = 'D'
        elif ch == 'D':
            ch = 'U'
    if f2 == 1:
        if ch == 'L':
            ch = 'R'
        elif ch == 'R':
            ch = 'L'
    
    if ch == 'U':
        return (0, 1)
    elif ch == 'D':
        return (0, -1)
    elif ch == 'L':
        return (-1, 0)
    elif ch == 'R':
        return (1, 0)

# 大きな負の値で初期化：未達成状態を意味する
INF = -10**9

# dp[i][k][f1][f2] = (x, y) のマンハッタン距離の最大値を管理するために
# ここでは座標ではなく、座標をタプルで保存し実際には距離で比較して更新を行う必要がある
# だが状態管理を座標にした場合更新が複雑
# よって、dpには座標の情報を保存し、同じ状態で距離最大化の更新を行う
#
# 実装のため効率的にするには、dpに直接座標の最大マンハッタン距離とx,y座標を保存し
# 遷移時にx,y座標も繰り返し計算する
#
# ここでは明示的に座標(x,y)をdp配列に保存
# 初期状態は dp[0][0][0][0] = (0,0)

dp = [ [ [ [None]*(2) for _ in range(2) ] for __ in range(K+1) ] for ___ in range(N+1) ]
dp[0][0][0][0] = (0, 0)

for i in range(N):
    ch = S[i]
    for k in range(K+1):
        for f1 in range(2):
            for f2 in range(2):
                if dp[i][k][f1][f2] is None:
                    continue
                x, y = dp[i][k][f1][f2]
                # 魔法のかけ方は4通り：
                # 0回かけない
                # 魔法1を1回かける
                # 魔法2を1回かける
                # 魔法1と魔法2を両方かける（1回ずつで合計2回）
                # これらでk回を超えなければ遷移を試す
                
                for add_magic1 in [0, 1]:
                    for add_magic2 in [0, 1]:
                        new_k = k + add_magic1 + add_magic2
                        if new_k > K:
                            continue
                        new_f1 = (f1 + add_magic1) % 2
                        new_f2 = (f2 + add_magic2) % 2
                        dx, dy = move(ch, new_f1, new_f2)
                        nx = x + dx
                        ny = y + dy
                        prev = dp[i+1][new_k][new_f1][new_f2]
                        if prev is None:
                            dp[i+1][new_k][new_f1][new_f2] = (nx, ny)
                        else:
                            # マンハッタン距離が大きい方を採用
                            if abs(nx) + abs(ny) > abs(prev[0]) + abs(prev[1]):
                                dp[i+1][new_k][new_f1][new_f2] = (nx, ny)

# 答えはdp[N][k][f1][f2]の中の最大の |x|+|y|
ans = 0
for k in range(K+1):
    for f1 in range(2):
        for f2 in range(2):
            if dp[N][k][f1][f2] is None:
                continue
            x, y = dp[N][k][f1][f2]
            dist = abs(x) + abs(y)
            if dist > ans:
                ans = dist

print(ans)