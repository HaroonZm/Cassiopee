# 問題概要:
# - L個のマスが一列に並ぶ。
# - N個の駒がそれぞれのマスに1つずつ置かれている。
# - 駒は左右どちらにも1マスずつ動かせる。ただし動かす駒は1回に1つだけ。
# - 動かす方向が駒の矢印の向きと一致すれば +1点、逆方向なら -1点になる。
# - 最大スコアが必ず存在するので、その最大スコアを求める。

# 考察:
# - 点数は「駒の移動距離 × 矢印と一致方向の移動数 - 逆方向の移動数」である。
# - 駒はどの向きにも動けるため、重心のような最終配置を選ぶ余地がある。
# - ある最終配置に全ての駒を移動させたときのスコアは、
#   (最終位置 - 元の位置) が 矢印方向なら +それだけ点数が増え、
#   逆方向なら減点となる。
# - 駒の矢印方向を0:左(-1),1:右(+1)として符号をつけると、
#   スコア = Σ( (最終位置_i - p_i) * 矢印_i ) = Σ( 最終位置_i * 矢印_i ) - Σ( p_i * 矢印_i )
# - p_iと矢印は固定なので、最大化したいのは Σ( 最終位置_i * 矢印_i )
# - 駒の最終配置は1..Lを使い、1マスに1つの駒、合計N個配置するので、N個のマスを選ぶ必要がある。
# - この合計を最大化するには、矢印が右(1)の駒はできるだけ右寄せ、左(0)の駒はできるだけ左寄せするのが有利。
# - 駒の集合を、左向き駒と右向き駒で分ける。
#   例えば左向き駒 k個には左端から k個のマスを割り当て（小さい番号）、右向き駒には右端から残りのマスを割り当て（大きい番号）。
# - 両方の駒をそれぞれのグループの序列でソートし、左向き駒はマスの小さい順、右向き駒はマスの大きい順に割り当てる。
# - これで最大スコアが得られる。

# 実装:
# 1. 入力を読み込む。
# 2. 駒を左向きリスト、右向きリストに分割。
# 3. 左向き駒はp_iで昇順ソート、割り当て先のマスは1..k (左端から)
# 4. 右向き駒はp_iで昇順ソート（位置のソートで問題ない）、割り当て先のマスは L-(m-1)..L （右端から）
# 5. スコア計算:
#    sum_{左向き} (割り当て先 - 元の位置)*(-1)
#    sum_{右向き} (割り当て先 - 元の位置)*(+1)
# 6. 合計を出力。

# 計算量:
# ソートはO(N log N)で十分高速。

import sys
input = sys.stdin.readline

N, L = map(int, input().split())

# 左向き駒の位置リスト
left = []
# 右向き駒の位置リスト
right = []

for _ in range(N):
    p, d = map(int, input().split())
    if d == 0:
        # 左向き
        left.append(p)
    else:
        # 右向き
        right.append(p)

# 左向き駒は位置昇順にソート
left.sort()
# 右向き駒も位置昇順にソート
right.sort()

score = 0

# 左向き駒は左端のマス1..len(left)に割り当てる
for i, p in enumerate(left):
    assigned_pos = i + 1
    # 矢印は左向きなので得点は -(assigned_pos - p)
    score += -(assigned_pos - p)  # = p - assigned_pos

# 右向き駒は右端のマスからlen(right)個割り当てる
# 右端はLなので、割り当てはL - (m - 1), ..., L
m = len(right)
for i, p in enumerate(right):
    assigned_pos = L - (m - 1) + i
    # 矢印は右向きなので得点は (assigned_pos - p)
    score += (assigned_pos - p)

print(score)