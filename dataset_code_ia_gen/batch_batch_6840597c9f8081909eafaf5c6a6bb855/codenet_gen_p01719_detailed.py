# 入力値を取得
n, d, x = map(int, input().split())
prices = [list(map(int, input().split())) for _ in range(d)]

# dp配列の定義
# dp[i] は i日目終了後に保持できる最大の所持金（現金のみ、株は持たない状態）
# 0日目はまだ取引していないので初期所持金 x
dp = [0] * (d + 1)
dp[0] = x

# 各日ごとに状態を更新していく
for day in range(1, d + 1):
    max_money = dp[day - 1]  # 何もしなかった場合の所持金（そのまま引き継ぐ）

    # 1日目からday日目までの株価から、株を買ってその日のうちに売れるか検討する
    # この問題の特徴は、日中の株価は変動しないため、同じ日の中での
    # 売買は出来るが、単に利益はその日の株価のみで計算される。
    # なので、日をまたいでの株保有も考慮する必要がある。
    #
    # ここで「任意の日に同じ日中に何度も取引可能」なので、
    # 結局は任意の日で株式単位を買い、任意の別の日で売ることで利益を得られる。
    #
    # dpで状態遷移を管理するため、前日までの状態から当日に株を売買して得られる最大の所持金を計算する。
    #
    # アプローチとしては、株を日を跨いで保持できるため、株の保有数の状態を持つと爆発的に組み合わせが増える。
    # しかし n, d は10と小さいため、DPで「どの日にどの銘柄を何単位持っているか」を管理できる（といっても多次元配列は大きい）。
    #
    # そこで、高速化と簡潔化のため、株式の最適売買は
    # 「日数が小さいので全探索」も可能だが、
    # 今回の制約から、最終日まで保有して売り切ることで最大化を目指す。
    #
    # しかし、「複数株式・複数日」での買いと売りの複雑な組み合わせを考慮するにはDPで「日数×所有株の組み合わせ」を持つ必要がある。
    #
    # 制約が小さいため、状態として「各株の保有数」を持ち、更新するDPにすることにする。
    #
    # 所持金,x と各株の保有数(整数) が状態になるが、所持金最大値が10^5以下で、株価も10^5以下、また取引単位は必ず整数なので
    # 状態数は爆発しそう。
    #
    # そこで、「dp[day][hold_0][hold_1]...[hold_{n-1}]」は計算不可能。
    # 
    # よって、持株は整数単位以上の任意の回数なので、単純に「持株は1単位」として燃やすとなる。
    #
    # 制約がすべて10で小さいので、全探索的に日毎に「前日の状態」から
    # 今日日に買う株、売る株を全通り探索する。
    #
    # 各状態は「(所持金, 各株保有数配列)」で管理。
    #
    # ただし、購入・売却を何回でも自由にできるので、同日中に何度も取引できる。
    # => 最終的にその日の株価p_i,jから最適な「現金と保有株数」の組み合わせを求めることになる。
    #
    # しかし状態数を減らす手法として、
    # 「持っているお金と保有株の状態から、最終日に利益を最大化する」というDPは状態空間が爆発的に増える。
    #
    # よってもう一つの別アプローチ。
    #
    # 【重要】
    # 鍵となるヒントは、株価は日中変動しないので自由に買って売れるため、
    # 一日の間に何回も売買可能で、複数株も保有可能。
    #
    # すると、「今日より明日の株価が高ければ、今日に買って明日に売る」のみ考えれば良い。
    # なぜなら株を複数単位でいくらでも取引可能、手数料なしなので利益が出るところはどんどん取引すればよい。
    #
    # よって、
    # day 日までの資金状態は関係なく、その日の株価 p_i,j と翌日の株価 p_{i+1},j を比較して、
    # p_{i+1,j} > p_{i,j} なら、その差額分だけ株の単位数を買い、翌日に売ることで利益を得られる。
    #
    # ここまで出た戦略を実装することにする。

# 持ち金の最大を保持する変数
money = x

# 各日について、明日より株価が安ければその日のうちに株を買い、明日に売ることを繰り返すことで利益を最大化
for i in range(d - 1):
    for j in range(n):
        # 株価の差がプラスなら売買で利益が取れる
        diff = prices[i + 1][j] - prices[i][j]
        if diff > 0:
            # 購入可能な株数は money // prices[i][j]（整数単位）
            max_units = money // prices[i][j]
            # 今日買って明日売ることで得られる利益は diff * max_units
            money += diff * max_units

print(money)