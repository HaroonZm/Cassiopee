# 入力例に従ってA君が座れる席の数を求めるプログラムを作成する

# 解法のポイント：
# 1. 一行目の席には座れない → i == 0 の席は除外
# 2. すでに生徒が座っている席 'o' は不可
# 3. 休憩中のうるさい生徒 'x' の近く(8方向すべて)は不可
# 4. 左隣右隣に人がいる席も不可。人とは 'x' または 'o' を指すと思われる（問題文「右隣か左隣に人がいると...」の"人"は' o 'の生徒であるが、周囲判定では'x'も考慮。隣の判定は 'o' または 'x' 両方含むべきだが問題文「休憩中うるさい生徒」と「それ以外の生徒」とが明確に区別されているため、隣隣判定で「人」とは 'o' のみ、隣に生徒がいるのがNG。休憩中うるさい奴は特別に8方向NG判定。）
# 5. その席自身が空席 '-' であること

# したがって座れる席とは、以下の条件を満たす席：
# - 1行目でない
# - '-'（空席）
# - 左右に 'o' がいない
# - 8近傍に 'x' がいない
# - その座席自体に 'o' や 'x' がいない（空席のみ）

# 実装の流れ：
# - 入力を受け取る
# - 休憩中の生徒 'x' の位置を把握し、その近傍をマークしておく（座れない場所）
# - 各空席について条件をチェックし、座れるか判定

# ここから実装

M, N = map(int, input().split())  # 行数 M, 列数 N

# 教室の座席情報を一行ずつ取得
seats = [input() for _ in range(M)]

# 座れない理由を判定するための補助配列
# 休憩中うるさい奴の近くはFalseで座れないとする
cant_sit_due_to_x = [[False]*N for _ in range(M)]

# 8方向の判定用ベクトル
directions_8 = [(-1, -1), (-1, 0), (-1, 1),
                (0, -1),           (0, 1),
                (1, -1),  (1, 0),  (1, 1)]

# 休憩中のうるさい奴 'x' の近傍を座れないようにマーク
for i in range(M):
    for j in range(N):
        if seats[i][j] == 'x':
            # その地点自身も座れない
            cant_sit_due_to_x[i][j] = True
            for di, dj in directions_8:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    cant_sit_due_to_x[ni][nj] = True

# 座れる席数を数える
count = 0

for i in range(M):
    for j in range(N):
        # 1. 1行目の席には座れない
        if i == 0:
            continue
        # 2. 空席 '-' 以外は座れない
        if seats[i][j] != '-':
            continue
        # 3. 休憩中うるさい奴の近くは座れない
        if cant_sit_due_to_x[i][j]:
            continue
        # 4. 左右に生徒 'o' がいると座れない
        # 左隣
        if j-1 >= 0 and seats[i][j-1] == 'o':
            continue
        # 右隣
        if j+1 < N and seats[i][j+1] == 'o':
            continue

        # 上記すべての条件を満たしたら座れる席
        count += 1

# 結果を出力
print(count)