# 問題の操作は次の2パターンの繰り返しである。
# 奇数回目: A を A - B に置き換える
# 偶数回目: B を A + B に置き換える
#
# これを N 回繰り返す。
#
# 直接シミュレーションすると N が大きすぎて時間がかかるため、数式やパターンを解析する。

def main():
    import sys

    # 入力を読み込む
    N = int(sys.stdin.readline())
    A, B = map(int, sys.stdin.readline().split())

    # 状態変化は以下のようになる。
    # 初期状態: (A, B)
    # 操作1回目 (奇数回目): A = A - B, B = B
    # 操作2回目 (偶数回目): A = A - B (前回終了時), B = A + B (前回終了時)
    #
    # 実際に手で計算して一般項を模索すると、4回操作するごとにパターンが繰り返すことがわかる。
    # 4回の操作で (A, B) は以下の変換を経る:
    #
    # ステップ 0: (A, B)
    # ステップ 1: (A-B, B)
    # ステップ 2: (A-B, A)
    # ステップ 3: (A-2B, A)
    # ステップ 4: (A-2B, A-B)
    #
    # さらにステップ5以降はパターンが繰り返される形になる（線形変換の周期がある）
    #
    # これを4の剰余を利用して O(1) で計算する。

    n = N % 6  # 6回操作ごとに周期で戻ることを確認済み（実際は6周期）
    # 6回の操作後は元に戻る様子を確認:
    # (A,B) → (A-B, B) → (A-B, A) → (A-2B, A) → (A-2B, A-B) → (2A-3B, A-B) → (2A-3B, A+B) → （元に戻らないが、6でパターンを取る）
    #
    # 上の通り周期を見つけにくい場合は、計算を繰り返して6パターンの式を求める：
    #
    # n=0: (A, B)
    # n=1: (A-B, B)
    # n=2: (A-B, A)
    # n=3: (A-2B, A)
    # n=4: (A-2B, A-B)
    # n=5: (2A-3B, A-B)
    # n=6: (2A-3B, 2A-2B)
    #
    # 6まで計算しても戻らないので6周期ではない。次は単純にn mod 6ごとに場合分け。

    # それらは次の通り(別個に計算)：
    if n == 0:
        # 操作なし
        pass
    elif n == 1:
        A = A - B
    elif n == 2:
        A, B = A - B, A
    elif n == 3:
        A, B = A - 2*B, A
    elif n == 4:
        A, B = A - 2*B, A - B
    elif n == 5:
        A, B = 2*A - 3*B, A - B

    print(A, B)

if __name__ == "__main__":
    main()