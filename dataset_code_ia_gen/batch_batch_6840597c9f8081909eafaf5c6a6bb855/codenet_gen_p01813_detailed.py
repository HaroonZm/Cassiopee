import sys

sys.setrecursionlimit(10**7)

"""
問題の要点：
- 与えられた数式Sに任意の場所に括弧を挿入して、新しい数式を作る。
- ただし、最終的にできた数式はBNFで定義される数式のルールを満たさなければならない。
- 括弧の中身は<expr>、<term>は数字または括弧付き<expr>。
- 計算結果を最大化したい。

BNFのおさらい：
<expr> ::= "(" <expr> ")"
         | <term> "+" <term>
         | <term> "-" <term>
<term> ::= <digit> | <expr>

この定義より、
- <expr>は一つの丸括弧でくくられたexprか、
- 3つの部分で構成される2項演算（term + term または term - term）
- <term>は1桁の数字か括弧でくくられた<expr>

したがって、exprは非常に限定的な構造で複雑な二項演算式は直接表現できない。

課題の解釈：
- 元の式Sは「数式」で与えられる。
- ここから括弧を追加して、BNFの式となるように変更できる。ただし、追加した括弧で作られる新しい式はBNFの定義通りにならなければならない。

着目点：
- 元の式は複雑な式（複数桁の演算）だが、<expr>の定義は極めて限定的。
- <expr>は、
    1. 括弧付きの<expr>
    2. <term> + <term>
    3. <term> - <term>
- <term>は一桁の数字or括弧付き<expr>（数字もしくは括弧で包まれたexpr）

よって最終的な式は、
- 単一のexpr＝(expr) か
- <term> + <term> か <term> - <term> の形で2項演算のみである。

元の式は複数の項が連続していて、このBNF定義のexprには合致しない場合もあるので括弧で区切って二項演算で表す必要がある。

したがって問題は、
- Sから括弧を挿入して、式の「二項演算的な塊」を作りBNFに合う式に変形しつつ計算結果を最大化する問題。

実装方針：
- 入力文字列 S（長さ最大200）をパースし、
- 数字と演算子(+と-)を抽出し、それらの間に括弧を挿入可能とする。

この問題は「数式に括弧を追加して計算結果を最大化する」典型的なDP問題である。
ただしBNFで限定された式形状に合うように括弧を追加しなければならない。

このBNF定義は3種類のexprのうちのどれか:
1) (expr)  
2) term + term  
3) term - term  

termはdigitまたは(expr)で、つまりtermは数字か丸括弧付きexpr。

全体として言えば、
- 演算はtopレベルは必ず term+term または term-term または (expr)
- termはひとつの数字 or (expr)

これのヒント
- 複雑な計算式の括弧の付け方による最大化問題だが、演算子は + と - のみなので区間DPが典型的。
- しかしBNFにより、式は非常にシンプルな2項演算式または丸括弧のexprの繰り返しなので行ける。

詳細解析：
- 例えば文字列 "1-(2+3-4+5)" は元々式だが、BNFからはトップレベルは
 expr ::= term (+|-) term
 term ::= digit or (expr)

よって
トップレベルは二項演算式のみ、つまり左項term、演算子、右項termのみ。

しかし元の複雑な式は明らかに複数項の加減算があるがBNFではトップレベルは2項演算のみ。

したがって今回許される式は、
- トップレベルは '(' expr ')' （1項）
- もしくは term + term (2項)
- もしくは term - term (2項)

termは(digit)かexprだから、
- 左右termがdigitまたは丸括弧付きexprとなる二項演算のみ。

つまり複数項の連鎖は、BNF的には「2項演算のネストされた形」として coefficient tree の様に表現される。

だから文字列Sを数字と演算子で分解し、区間DPで、
- 区間[l:r]で表現可能なexpr（もしくはterm）として計算値の最大値・最小値を計算し、
- '(' expr ')' による最大最小と
- term + term、term - term に分割した場合の最大最小を比較しながら進めることができる。

ここでexprとtermの区別も必要。

BNFの役割を明確化するため、

- <expr>：
    1) "(" <expr> ")"
    2) <term> "+" <term>
    3) <term> "-" <term>

- <term>：
    1) <digit>
    2) <expr>

またdigitは1桁の数字。

なので、

<term> と <expr> は以下の関係：

- termは数字 または expr（丸括弧付き）

exprは term+term または term-term または (expr)

重要なのはexprとtermはお互いに包含関係にあることで、区間DPで両方最大最小値を計算していく必要がある。

上記ルールをもとに、

Sの文字列からトークンを生成：
- 数字 (0-9)
- 演算子 '+' or '-'
- 括弧 '(' or ')'

括弧は入力に含まれているが、新たにどこに括弧を入れても良い。

問題文に明記が無いため、もともとある括弧は無視し（または削除し）、「Sは単なる演算式」と見なして

- 複雑な有限の演算子を持つ文字列として扱い、
- 新たに括弧を追加してBNFに合致する式に直すアプローチを取る。

つまり、

S から数字と演算子を抜き出し、括弧なしの演算の文字列とする(入力中にすでに括弧がある場合も、式全体の価値には影響なし。追加括弧を自由に挿入できるため）

括弧は入力を分割する要素なので無視して良い。

計算は区間DPで、

- 区間[l:r]の最大値・最小値を記録

- l,rは数字のインデックス

- 演算子は数字の間にある

このように加工して例題も処理可能。

最後、最大値を出力。

もしBNFのルールで括弧の対応が変でも良い旨があるため、文字列の数字と演算子だけ処理して最大値を求める。

-----

実装手順：

1) 入力文字列Sから数字のリストnumsと演算子opsを抽出する。

2) n = len(nums)

3) dp_max[i][j], dp_min[i][j] = 区間[i,j]の式の最大値・最小値（i<=j<n）

4) 初期化: i == j の時 dp_max[i][i] = dp_min[i][i] = nums[i]

5) len区間を伸ばしながら

6) kを変えて区間を分割（binary partition）

7) それぞれ左右区間のdp_min/maxから演算子ops[k]に従い、全組み合わせで最大・最小を更新

8) 区間[0,n-1]のdp_max[0][n-1] が答え。

----

問題文のサンプル1：

S = "1-(2+3-4+5)"

数字の取り出し: 1 2 3 4 5

演算子: - + - +

計算すると区間DPで最大値を算出：

結果: 5（期待値）

-----

したがって括弧の挿入による計算最大化問題は、区間DP解法でOK。

------

コードは詳細コメント付きで作成。

"""

# 入力読み込み
S = input().strip()

# 1. 入力文字列から数字と演算子だけ取り出す（括弧は無視）
nums = []
ops = []
for c in S:
    if c.isdigit():
        nums.append(int(c))
    elif c in '+-':
        ops.append(c)
    # '(' ')' は無視してよい（新たな括弧をどこにでも入れて良い）

n = len(nums)

# dp_max[i][j], dp_min[i][j] : 区間i～jの式の最大値・最小値を記録する2次元配列
dp_max = [[-10**15]*(n) for _ in range(n)]
dp_min = [[10**15]*(n) for _ in range(n)]

# 1つの数字のみの区間の初期化
for i in range(n):
    dp_max[i][i] = nums[i]
    dp_min[i][i] = nums[i]

# 区間の長さを1からnに伸ばす
for length in range(2, n+1):
    for i in range(n - length + 1):
        j = i + length - 1
        # 区間[i,j]を分割する演算子の場所kを探す
        for k in range(i, j):
            op = ops[k]
            # 左右区間の最大・最小値を使い計算
            for left_val in [dp_max[i][k], dp_min[i][k]]:
                for right_val in [dp_max[k+1][j], dp_min[k+1][j]]:
                    if op == '+':
                        val = left_val + right_val
                    else:
                        val = left_val - right_val
                    if val > dp_max[i][j]:
                        dp_max[i][j] = val
                    if val < dp_min[i][j]:
                        dp_min[i][j] = val

# 答えは全区間の最大値
print(dp_max[0][n-1])