# 解説：
# この問題は、無限に続く囚人たちがいて、N回の操作を行うものです。
# 操作は以下の通り：
# 1. 番号0の囚人を釈放する（その囚人の元の番号を求めるのが目的）。
# 2. k, 2k, 3k, ... 番目の囚人を処刑する（元の番号でなく、操作後の繰り返し番号で判定）。
# 3. 残った囚人に0から順に番号を振り直す。
#
# 問題は無限囚人がいる中で、N回目に0番の囚人として釈放される者の「元の番号」を求めること。
#
# 大きな制約N, k は10^5まで、答えは10^{18}以下。
#
# この問題は「Josephus問題」の変形に近いものと考えられますが、
# 直接シミュレーションは不可能なので、再帰的な式を利用します。
#
# つまり、操作のたびに番号付けが変わるため、元の番号と操作後の番号の関係を関数f(n)で表すことを考えます。
#
# 定義：
# f(N) := N回目に釈放される囚人の元の番号
#
# 仮定：
# f(1) = 0  # 1回目は0番目を釈放するので元は0
#
# N回目操作では、
# - 前回の生存者の中から0番目が釈放される。
# - 生存者数は無限なので、処刑後の残った者はある数列になる。
#
# 数学的に、回答を導く公式は以下の通りです。
#
# 実は、処刑される者の番号は、現在の番号がkの倍数の者なので、
# 生存者の番号は0から始まる連続した番号のうちkの倍数を除いたものです。
#
# 残りの生存者の元番号は、N回操作すると、
# f(N) = (f(N-1) / (k-1)) * k + (f(N-1) % (k-1))
#
# これをN回繰り返すことで、最終的な元の番号が求まります。
#
# これをイテレーションで計算すれば、効率的に処理可能です。
#
# 以下はコードです。

import sys
sys.setrecursionlimit(10**7)

def main():
    import sys
    input = sys.stdin.readline

    N, k = map(int, input().split())

    # f = 0は1回目釈放される囚人の元の番号
    f = 0
    for _ in range(N):
        # fを(k-1)で割った商と余りから次のfを計算
        f = (f // (k -1)) * k + (f % (k -1))
    print(f)

if __name__ == "__main__":
    main()