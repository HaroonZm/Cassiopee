q = int(input())
S = []
for _ in range(q):
    p, c, n = input().split()
    p = int(p)
    n = int(n)
    S = S[:p] + [c]*n + S[p:]
    
    # check if S is in the language
    # Language defined by S -> SS | (S) | )S( | Îµ
    
    # We try to check the balance with a stack-like approach:
    # But parentheses can close in reverse order too: a ')' can be closed by '('
    # So we must check if the string can be fully reduced by applying the rules
    
    # Let's try a simple approach:
    # Repeatedly replace occurrences of (S) or )S( with empty string until no change
    # Or split into two parts and check recursively
    
    # But it's too slow for q up to 1e5 and length potentially huge.
    # Since the problem requests beginner style and simple code, do a brute force parse
    
    # To keep simple, implement a recursive parser with memoization on substrings
    
    from functools import lru_cache
    
    s = ''.join(S)
    
    import sys
    sys.setrecursionlimit(10**7)
    
    @lru_cache(None)
    def parse(i,j):
        # check if s[i:j] can be generated by S
        if i == j:
            return True
        length = j - i
        # try SS
        for k in range(i+1,j):
            if parse(i,k) and parse(k,j):
                return True
        # try (S)
        if length >= 2 and s[i] == '(' and s[j-1] == ')':
            if parse(i+1, j-1):
                return True
        # try )S(
        if length >= 2 and s[i] == ')' and s[j-1] == '(':
            if parse(i+1, j-1):
                return True
        return False
    
    if parse(0,len(s)):
        print("Yes")
    else:
        print("No")