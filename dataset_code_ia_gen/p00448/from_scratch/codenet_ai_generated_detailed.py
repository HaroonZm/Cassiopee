# おせんべい問題の解法:
# - Rは最大10、Cは最大10000なので、Rが小さくCが大きいことを利用する。
# - 横方向の裏返し操作は行のビット反転、縦方向の裏返しは列のビット反転。
# - 初めに地震で裏返った煎餅の配置が与えられる。裏返し操作は「行の一括反転」と「列の一括反転」で行う。
# - 行反転は任意の行を選んで一度だけ実施、列反転も同様。
# - 狙いは「表側がちょうど焼ける煎餅の枚数」を最大化すること。
# 
# 解法のポイント:
# - 行の裏返しは最大10行なので、全部の行の裏返しパターンは2^R (最大1024)通りで頑張れる。
# - 1回の横操作としてパターンを決定した時、列の反転が「どの列を反転すると最大になるか？」を効率的に計算。
# - 各パターンで変化した行列において、列ごとに「裏返し前の状態と異なるビットが何個か」を数え、
#   その列を反転するかしないか選び最大値を得る。
# - 全パターンを試し最大値を求める。

import sys

def main():
    while True:
        R, C = map(int, sys.stdin.readline().split())
        if R == 0 and C == 0:
            break

        # 行ごとの状態をビット列として表現
        # 1なら表, 0なら裏
        # 各行のC列の煎餅を整数のビットとして格納する図
        # ただし、Cが最大10000でPython標準intでは問題ない。
        rows = []
        for _ in range(R):
            line = list(map(int, sys.stdin.readline().split()))
            # ビット列に変換(Rが小さいけどCは大きいので配列で複数ビットに分けるよりintで管理)
            # ただしCは最大10000なのでintで管理可能 Pythonは任意精度
            val = 0
            for b in line:
                val = (val << 1) | b
            rows.append(val)

        max_result = 0

        # 2^R通りの行の反転パターンを全探索
        for row_flip_mask in range(1 << R):
            # 行のビットを反転する
            flipped_rows = []
            for i in range(R):
                if ((row_flip_mask >> i) & 1) == 1:
                    # 反転：全ビット反転 → 1になる部分は裏返し前は0
                    flipped_rows.append(((1 << C) - 1) ^ rows[i])
                else:
                    flipped_rows.append(rows[i])

            # 各列について、col_bit=1の個数（表の数）を計算する。
            # ここでどの列を反転(縦の裏返し)すべきか判断する。
            # 列の反転は列ごとに独立して決められるので、
            # その列で表側にあたる枚数が少ない場合、列を反転すれば増やせる。

            # ただし C=10000は大きいのでビット演算でパフォーマンス向上を狙う。
            # Pythonでビット単位で集計するのは遅いがRは10なので、小さく分割して列ごとにカウントしてもOK。

            # 各列ごとに0～R-1行のbitを抽出し、それぞれの位置のビット1の数を数える方法を採る。
            # これを効率よく行うために、列を１ビットずつ処理
            # ビットを左から順に扱っているため、最右ビットが一番下位bit。

            # 右から0番目ビットが一番右の列
            # ここでは1<< (C-1-j) の重い処理をさけるため、Cが大きいのでビット全体から逐一取り出すのは重い。
            # 代替策として:
            # 右端からビットを数えるため、何ビット目かのbitを取得するには
            # (val >> pos) &1,  pos=0は一番右列

            # したがって、C列の列ごとに0～C-1のbit位置を順に計算し、行の中でbitを抽出し集計

            # 列ごとに1の数をカウント
            one_counts = [0] * C
            for i in range(R):
                val = flipped_rows[i]
                # Rは小さいので1つのループでC回bit抽出
                # ただしC最大10000なのでここが重い可能性あり。最適化考慮。
                # しかしPythonのビット演算で高速化は限定的。工夫として
                # val >> pos &1をループでやらずにbytesや別扱い方法でも良いが問題ないと仮定。
                #
                # ここでは一気にビット列を文字列で扱い、毎列加算とかできるがメモリ面で不安がある。
                # 
                # 最も単純な方法を採用。
                for pos in range(C):
                    if (val >> pos) & 1 == 1:
                        one_counts[C - 1 - pos] += 1

            # 縦反転は列ごとに独立なので、各列で (1にするか0にするか選択)
            # 反転しない場合：そのまま1の数 = one_counts[col]
            # 反転する場合: 裏返しなのでR - one_counts[col]
            # 最大値を選択し加算
            total = 0
            for cnt in one_counts:
                total += max(cnt, R - cnt)

            if total > max_result:
                max_result = total

        print(max_result)

if __name__ == "__main__":
    main()