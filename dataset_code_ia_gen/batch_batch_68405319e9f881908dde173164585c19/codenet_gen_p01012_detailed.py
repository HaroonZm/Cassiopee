# 問題の概要：
# プラナリア（平面上の長方形体）をx回水平方向にm:nの比率で切断し、
# 続けてy回垂直方向にk:lの比率で切断する。
# それぞれの切断はすべての断片に対して行われる。
# こうしてできた断片が元の完全なプラナリアに再生する確率は
# （断片の幅）×（断片の高さ）として求められる。
# 各断片が再生する期待値を足し合わせたものを求める。

# アプローチのポイント：
# 1. 水平方向の切断では、長さを (m/(m+n)) と (n/(m+n)) に分割し、それをx回繰り返す。
#    つまり、x回の切断の結果、水平方向には 2^x 個の断片ができる。
#    断片の幅の分布は、マルチプルに基づく組み合わせで計算できる。
#
# 2. 同様に垂直方向の切断はy回行い、断片の高さがk:lの比で分割される。
#
# 3. 各方向の断片の長さの分布は、それぞれ二項分布的な扱いになる。
#    例えば、水平方向でi回m側を選び、x-i回n側を選ぶ断片の幅は
#    (m/(m+n))^i * (n/(m+n))^(x-i)
#    このような断片に現れる確率は二項係数から出る。
#
# 4. よって、断片の期待値は水平方向で幅の期待値（もちろん1）×垂直方向で高さの期待値（もちろん1）。
#    ただし、完全再生の期待値は断片の面積の期待値。断片数分の面積和の期待値。
#    つまり断片ごとの面積の和の期待値になる。
#
# 5. 数学的に展開すると、(m/(m+n))^(2i)などの二乗項が入るため、
#    二項展開の和で期待値を計算する。

# 実装では、
# - 水平方向の長さの2乗の和を計算（断片幅の二乗の和）
# - 垂直方向の高さの2乗の和を計算（断片高さの二乗の和）
# - 期待値 = それらの積（断片サイズの2乗和水平方向 × 垂直方向） 
# 断片数 = 2^(x+y)
# 確率的に期待値は (断片数) × (断片1つの面積^2) = 水平成分の和 × 垂直成分の和

# したがって、この問題は「同じ操作でできた断片の長さの二乗和」を両方向で計算し、
# その積を求めれば良い。

from math import comb

def planarian_regeneration(m: int, n: int, x: int, k: int, l: int, y: int) -> float:
    # 水平方向の切断時の長さの総和は always 1
    # 断片の長さの確率分布は二項分布に基づくが、我々は断片の長さの二乗の総和が必要

    # 水平方向切断の長さ二乗和計算
    # Sx = Σ_{i=0..x} C(x,i) * (m/(m+n))^{2i} * (n/(m+n))^{2(x-i)}

    denom_h = m + n
    p_h_m = m / denom_h
    p_h_n = n / denom_h
    
    sum_h = 0.0
    for i in range(x + 1):
        # C(x,i)
        c = comb(x, i)
        length_squared = (p_h_m ** (2 * i)) * (p_h_n ** (2 * (x - i)))
        sum_h += c * length_squared

    # 垂直方向切断の長さ二乗和計算
    denom_v = k + l
    p_v_k = k / denom_v
    p_v_l = l / denom_v

    sum_v = 0.0
    for i in range(y + 1):
        c = comb(y, i)
        length_squared = (p_v_k ** (2 * i)) * (p_v_l ** (2 * (y - i)))
        sum_v += c * length_squared

    # 切断回数0の場合、切断していないので和は1になるように自然になる。

    # 期待値は、断片数は 2^{x+y}, 各断片の面積の期待値は和の積
    # この計算は断片1つの面積の二乗和の合計になっているためこのままでOK

    expected = sum_h * sum_v

    return expected


def main():
    import sys
    data = sys.stdin.read().strip().split()
    m, n, x = map(int, data[0:3])
    k, l, y = map(int, data[3:6])

    ans = planarian_regeneration(m, n, x, k, l, y)

    # 許容誤差10^-6まで求めよという問題文より、小数6桁で表示
    print(f"{ans:.6f}")


if __name__ == "__main__":
    main()