import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

N, M, L = map(int, input().split())
K = list(map(int, input().split()))
S = list(map(int, input().split()))

# 累積和を計算
S_cumsum = [0] * (M + 1)
for i in range(M):
    S_cumsum[i + 1] = S_cumsum[i] + S[i]

# 閉環の反発力を求める関数
def repulsion(a, b):
    if a <= b:
        return (S_cumsum[b] - S_cumsum[a - 1]) // L
    else:
        # a > b の場合は範囲が環状なので二つに分ける
        return (S_cumsum[M] - S_cumsum[a - 1] + S_cumsum[b]) // L

# 反発力行列を作る（隣接する音符の反発力）
# ここでiとjは音程の値ではなく、音程の番号の間の反発力を求める関数に渡すための音階
# しかし問題文ではa ≤ bの形で定義されているので repulsionはそれに従う

# しかし隣り合う音符の音程a,bの反発力は (S_a + ... + S_b)//L ここでa ≤ bなので a,b入れ替える必要がある
def repulsion_edge(a, b):
    if a > b:
        a, b = b, a
    return repulsion(a, b)

# dpテーブルを用意
# dp[bit][v] := bitで表された部分集合において最後に配置した音符がvのときの最小精神力
# 音符は0-based index
# bitは2^Nで大きすぎるので部分集合全探索は無理
# Nは最大2000なので、全順列は計算不可。TSPの状態管理は無理。
# そこで何か工夫が必要。

# 問題を見ると、音程は1～M（最大10）である。
# 音程の種類は多くて10個。
# 音符数は2000。
# ここで音階Mが小さいことに注目する。

# 使う音符は自由に順番を決められるが、
# 最小化すべきは「隣接音符間の反発力の合計」であり、これは音符を円環に配置しているため、
# 最後の音符と最初の音符の間も反発力が加算される。

# 音符は同じ音程のものを複数個持ちうる。音符同士の区別は順序付けくらいであって、
# 最終的に配置順序を決めることが目標。

# 音符には音程があり、同じ音程の音符は区別しないで良いのか、順序のみで区別？

# 問題文：「音符をどのような順番で並べるかは彼女の自由」→順番を決めることが目標。

# 制約のN=2000なので全順列無理。
# M=最大10なので音程の種類は少ない。
# 各音符は音程1～Mの値を持つ。

# 解法は、「音程ごとの個数は変わらないが、並べ方で精神力を最小にする」問題なので、
# DPは「音程の数」だけで表現するのが現実的。

# 音程の個数を数える
from collections import Counter
counter = Counter(K)

# 音程ごとの個数をリスト化
counts = [counter[i+1] for i in range(M)]

# dp[mask][last] := maskで表される音程の集合に対し、最後がlast(音程番号0..M-1)のときの最小精神力
# ここでmaskは 「各音程を何個配置したか？」の情報を持てないため、
# 全配置数Nなので多次元のDPとしては、
# dp[cnt1][cnt2]...[cntM][last]としても爆発的に大きい。

# しかし各音程の個数は最大2000なので、多次元DPは不可能。

# 問題の最大Nは2000。Mは最大10。
# なので、dpテーブルの形は
# dp[pos][last]：posは何番目の音符か、lastは最後に並べた音符の音程
# 配置したい順序は円環状なので、始点はどこでも良い。始点固定して順番を決めれば良い。

# しかし並べる音符はN個あり、N=2000でpos軸を作ると状態は2000×M=20000。

# ただし、全ての音符は使わなければならない。
# 各posでは、まだ使っていない音符の中から1つ選ぶ。
# つまり、何を選んだか？を管理することがないと重複選択になる。

# 重複の管理は、使用回数を数えること。なので多次元DP？

# この問題は音符を順番決めるTSPのような問題だが、辺の重さは音程間の値。

# 音程が10個なので、音程の個数合計がNであるが、DPは音程ごとの残数を状態として持つしかない。

# 音程の残り個数を持つ多次元DP (M=10)は状態数が約N^M=2000^10で不可能。

# => ここで「音程の個数は使わなければならない」「音符は同音程で区別しない」「反発力は隣り合う2つの音程のみに依存」
# つまり「周回路の重みの合計は，隣り合う音程間のペアの重みの和」

# この時「音程の個数を決めて，それらを輪で並べる順序を決める」問題は
# 巡回セールスマン問題（TSP）に似ているが、頂点は「音程」の種類だけ

# ただし、１つの音程は複数個の連続した音符に分割できるが、
# 各ノードは複数回通る必要がない。

# しかし、同じ音程の音符は連続して並べても分割してもよい
# （問題文は明示していないが、反発力は2つの隣接音符の音程で決まる）

# 連続した同じ音程の音符の「区間」の扱いではなく、
# 隣り合う音程の組み合わせを考慮すればよい。

# そこで、以下の考え方をする：
# 連続する同じ音程の音符はまとめて考えると、その隣との反発力は変わらない。
# なので、同音程の音符は連続させて配置する。

# 音程の並べ方を決めることは、M種類の「かたまり」を輪状に並べる順列問題に帰着し、
# 各かたまりの長さはcounts配列で与えられている。

# 次に、この輪の中で消費される精神力は、
# それぞれのかたまり間の反発力 × かたまり間の数で決まる。

# 多重セット巡回順序問題で、同音程かたまりが複数あるが同じ音程は連続で固めるのが最適。
# つまり、音程の順序を決定し、その順番で全音符を並べる。
# その時、反発力は音程ペアごとの反発力に countsの最小個数分がかかる（隣にある音符の区間分？）

# しかし実際は、魔方陣は「音符を輪の上に並べる」ので反発力は隣り合う各ペアごとに反発力を計算し、
# その合計になる。

# 回答例の計算例からわかるとおり、反発力は隣接２つの音符の音程間の和分のSを計算し、それをLで割り切った整数。

# なので、最終的に反発力は
# ∑(隣接2音符間の反発力)

# これを最小化する並べ方は、音程の順序を決定すべきであり、
# 各音程の個数は固定で、すべて並べる必要あり。

# 問題の制約下で全順列探索は無理なので、
# 「音程の種類は最大10で、各音程のかたまりを並べる」問題にして、
# 各かたまりは連続して配置するものと仮定してTSPを解く。

# TSPの頂点数はM(<=10)なら計算可能。

# 反発力は各隣接ペアの反発力で、かたまりの境界音程ペアの反発力で決まるが、
# かたまり内の「隣接音符間の反発力」は同音程のみなので
# 各かたまり中の内部の反発力は一定で計算可能（同じ音程同士だからa=bなので反発力はS[a]/L）。

# よって、 全体の精神力は以下の和：

# 1) 各かたまり内の反発力 * (かたまり内音符数 - 1)
# 「同じ音程の音符間の反発力は、隣接ペアごとに計算し、かたまり長さ-1分加算」

# 2) 各かたまり間の反発力 * 1 (境界の隣接ペア)

# かたまり間の反発力は隣接する音程ペアの反発力。

# 以上から、TSPの重みは「かたまり間反発力」で重みのみ設定し、
# 頂点ごとの「内部コスト」は別計算し最後に足す。

# 具体的に計算すると、

# 各音程 i の内部コスト = repulsion(i, i) * (counts[i] - 1)
# i = 1..M

# これを各かたまりの内部反発力として足す。

# TSPの重みは、i->j の辺の重みは repulsion(i, j)
# 並べ方の順序の辺和

# ここで、環状なので閉路の辺和の最小化を求めるTSPを解く問題。

# 最後に内部コストの合計を足す。

# まとめると、
# 音程の種類 M の完全グラフで TSP を解き、辺の重みは repulsion(i,j)=[(S_i+...+S_j)/L]
# ここで i,j は音程の添字（1-based）

# repulsion(i,j) は (S_a + ... + S_b)//L , a ≤ b を満たすように定義済み。

# これで最小閉路和を求めれば良い。

# 末尾から先頭に戻る辺も含む。

# 音程は1-basedで与えられているので調整。

# DP状態は dp[mask][last] 最小化

INF = 10**15
dp = [[INF] * M for _ in range(1 << M)]

# 各音程の内部反発力計算
internal_cost = [0] * M
for i in range(M):
    # 同じ音程間は範囲が1つなので repulsion(i+1, i+1)
    # 同じ音程間の反発力は (S_i)//L で、counts[i]-1回存在する(隣接ペア数)
    cost = repulsion(i+1, i+1)
    internal_cost[i] = cost * (counts[i] - 1)

# 辺の重み計算（repulsion between different音程）
edge_cost = [[0] * M for _ in range(M)]
for i in range(M):
    for j in range(M):
        if i == j:
            edge_cost[i][j] = 0
        else:
            edge_cost[i][j] = repulsion_edge(i+1, j+1)

# 以下、TSP DP

# 初期化
for i in range(M):
    if counts[i] > 0:
        dp[1 << i][i] = 0

for mask in range(1 << M):
    for u in range(M):
        if dp[mask][u] == INF:
            continue
        for v in range(M):
            if (mask & (1 << v)) == 0 and counts[v] > 0:
                nxt = mask | (1 << v)
                nd = dp[mask][u] + edge_cost[u][v]
                if dp[nxt][v] > nd:
                    dp[nxt][v] = nd

ans = INF
full_mask = 0
for i in range(M):
    if counts[i] > 0:
        full_mask |= (1 << i)

for i in range(M):
    if counts[i] == 0:
        continue
    # 閉路なので最後から最初に戻る辺も追加
    for j in range(M):
        if counts[j] == 0:
            continue
        if dp[full_mask][i] == INF:
            continue
        cand = dp[full_mask][i] + edge_cost[i][j]
        if cand < ans:
            ans = cand

# 最後に各かたまりの内部コストを足す
ans += sum(internal_cost)

print(ans)