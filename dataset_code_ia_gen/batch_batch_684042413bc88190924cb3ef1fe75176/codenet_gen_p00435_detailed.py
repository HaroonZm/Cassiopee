# 解説:
# 問題は、3文字ずつアルファベットをずらすシーザー暗号の復号である。
# 大文字アルファベットのみが対象で、'D' は 'A'、'E' は 'B' と戻す必要がある。
# つまり、「変換後の文字」から3文字戻す操作をすれば元の文字列になる。
#
# 手順:
# 1. 入力文字列を取得。
# 2. アルファベット文字を1つずつ処理。
# 3. 各文字コードを取得し、'A'=65として3文字分マイナスした結果を26文字内に丸める。
# 4. 復号した文字列を構築。
# 5. 結果を出力。

s = input().strip()

result = []
for c in s:
    # 'A' を0としてインデックス化
    idx = ord(c) - ord('A')
    # 3つ戻す (26文字循環)
    original_idx = (idx - 3) % 26
    # 元の文字に戻す
    original_c = chr(original_idx + ord('A'))
    result.append(original_c)

# 復号した文字列を出力
print("".join(result))