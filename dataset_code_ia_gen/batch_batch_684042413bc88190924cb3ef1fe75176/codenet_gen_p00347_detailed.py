# 入力された島の格子状の区画の損得情報から、先攻と後攻のそれぞれのスコア差の絶対値を計算するプログラム

import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

W, H = map(int, input().split())
score = [list(map(int, input().split())) for _ in range(H)]

# ゲームの流れと領地の決定：
# 駒は左上(0,0)から右下(H,W)まで移動、
# 移動ルールは南（下）か東（右）へのみ
# 駒の軌跡が境界線となり、
# その境界線より北東側が先攻の領地、
# 南西側が後攻の領地となる

# 先攻プレーヤーと後攻プレーヤーは交互に移動し、それぞれ自分のスコア差が最大になるように動かす

# DPで状態を考える
# dp[i][j] := (i,j)地点からゴール(H,W)までのゲーム展開でのスコア差の最大値
# 差 = (先攻のスコア) - (後攻のスコア)
# 盤面のマスs[i][j]は領地領域のどちらかに属するため、
# 勝負中の定義として、境界線確定部分を含め境界の北東側は先攻の領地、
# それ以外は後攻の領地とされる。この境界の決定を利用して差分を計算する

# アルゴリズムのポイント：
# - 盤面上の(i,j)は区画の左上の座標で頂点の座標ではないことに注意
# - 駒の軌跡は頂点(格子点)の移動パスであり、区画(マス目)の境界線として働く
# - dpは軌跡上の頂点を扱うため、サイズは(H+1)×(W+1)
# - そのため区画のスコア配列scoreはH×Wで、
#   頂点(i,j)が決まるとその頂点の北東側と南西側の領域が決まる

# 差分計算の工夫：
# 先攻・後攻が交互に動くため、現在のターンを判定し、
# 動くごとにその区画のスコアを差分に取り込む形に直す
# 差分化した配列を利用して差のDP計算を行うことで解ける

# 具体的処理方法（参考: AtCoderの典型問題のDP手法）
# 差分をとってdpを行う方法 (先手が最大化、後手が最小化)
# 差分配列を作成し、頂点ごとにdpを計算

# 差分配列(d)
# d[i][j] = スコアの(i,j)区画の得点を先手側有利に変換
# つまり、駒の移動回数 (i+j)の偶奇により先手か後手のターンを特定し
# 先手ターンなら +score[i][j]
# 後手ターンなら -score[i][j] とする

d = [[0]*W for _ in range(H)]

for i in range(H):
    for j in range(W):
        # (i+j)の偶奇でターンを判定
        if (i + j) % 2 == 0:
            # 先手のターン：先手の得点として加算
            d[i][j] = score[i][j]
        else:
            # 後手のターン：後手の得点として減算（先手にとってはマイナス）
            d[i][j] = -score[i][j]

# dpテーブル (H+1)x(W+1)
# dp[i][j] := (i,j)地点からゴール(H,W)まで移動するときの差の最大値
dp = [[0]*(W+1) for _ in range(H+1)]

# ゴール地点は(末端)なので0で初期化
# そこから逆順に計算

for i in reversed(range(H+1)):
    for j in reversed(range(W+1)):
        # ゴール地点以外で処理
        if i == H and j == W:
            continue

        # dp[i][j]から移動できる方向は「南」or「東」のみ
        
        candidates = []
        # 南に移動できるとき
        if i < H:
            # 南方向の移動ではd[i][j]の区画の差分を加える。
            # 今のdpは頂点上の状態なので、南に下がるなら区画(i,j)を通ることになる
            # → d[i][j]を足してその先のdpと比較
            candidates.append(dp[i+1][j] + d[i][j])
        if j < W:
            # 東方向の移動
            candidates.append(dp[i][j+1] + d[i][j])

        # 先手の番は(i+j)が偶数、後手の番は奇数
        # 先手は差を最大化、後手は差を最小化
        if (i + j) % 2 == 0:
            dp[i][j] = max(candidates)
        else:
            dp[i][j] = min(candidates)

# dp[0][0]が先手と後手のスコア差となる。
# 絶対値を出力

print(abs(dp[0][0]))