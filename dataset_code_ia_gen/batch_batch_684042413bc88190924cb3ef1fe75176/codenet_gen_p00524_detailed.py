import sys
import heapq

def main():
    input = sys.stdin.readline
    N, M, X = map(int, input().split())
    H = [0] * (N + 1)
    for i in range(1, N + 1):
        H[i] = int(input())

    # グラフの隣接リストを作成（双方のエッジを格納）
    graph = [[] for _ in range(N + 1)]
    for _ in range(M):
        A, B, T = map(int, input().split())
        graph[A].append((B, T))
        graph[B].append((A, T))

    # Dijkstra法による最短時間探索（状態：(木の番号, 現在の高さ)）は不可
    # なぜなら高さの範囲が非常に広いため、高さを状態に持つことが不可能。
    # 代わりに、Dijkstraで「木にいるときの最短時間」を管理し、
    # 木に到達したときに高さを調整してから次の木へ飛ぶという方法を考える。

    # しかし、飛び移る際の高さ制約が厳しく、(h - t) >= 0 かつ (h - t) <= H[next]
    # を満たす必要がある。
    # 木iの高さ範囲は[0, H[i]]、JOI君は木ごとに好きな高さに上下できるが、
    # 飛び移ると高さが (現在の高さ - t) になる。
    # つまり飛び移りの前に高さを調整しておき、飛び移って次の木に着地した高さが条件を満たす必要がある。

    # ここでのポイントは「木にいるときの高さをXに固定できる」ということ。
    # 木にいる間は上下に自由に移動できるが、時間がかかる。
    # よって、初期状態では木1の高さはX。木iに到着したら、まず飛び移った時の高さ h_j を計算。
    # 木iに着地後、必要な高さに移動する時間を考慮する。
    # つまり実質的には頂点ごとの「最短時間」を管理し、
    # 頂点間の移動時間は「飛び移り時間 + 高さ調整時間」。

    # Dijkstraの距離配列
    dist = [float('inf')] * (N + 1)
    dist[1] = abs(X - H[1])  # 最初の木でXメートルの位置にいるので、頂上H[1]まで登る時間はabs(H[1]-X)
    # ただし実は問題文は「木1の高さXメートルの位置からスタート」という意味なので、木1の現在位置はX。
    # 最終的には木Nの頂上である高さH[N]に行くことになる（高さ調整は木に着いた後に自由に可能）
    # だから初めの距離は0（スタート地点の高度X）としておく。

    # 上記考察に訂正：
    # 初期は木1の高さXメートルにいるので距離は0（時間0秒）
    dist[1] = 0

    # 優先度付きキューに初期状態を格納（時間, 木番号, 現在の高さ）
    # しかし状態空間が無限大なので、状態 (木, 高さ) を管理するのは不可
    # よって高さを状態に含めるのはできない。
    # 解決策として、「各木に到着した時の最短時間」を管理し、飛び移る前に木で高さ調整するので、
    # 高さを特定の値に固定し、必ず次の木の高さに合わせた飛び移りをすることを考慮する。

    # 具体的には
    # 木iの高さH[i]で着地したときに時間を最小化するには、飛び移った時の高さ = H[next] + t であること
    # だが飛び移った時の高さ = h_j = h_i - t
    # h_jは飛び移り前の高さ h_i - t
    # もし木iの高さ以下に高さ調整可能なので、その高さを合わせられる。

    # つまり、飛び移り時間と到着後の高さ調整時間を合わせることで、木iとj間の移動コストは
    # コスト = 飛び移り時間 t + 木jの高さまで移動する時間 (H[j] - (h_i - t))
    # h_iを最適化すると結局、距離は dist[i] + t + max(0, H[j] - (h_i - t)) + max(0, (h_i - t) - H[j])
    # 複雑なので、観察すると、
    # 木iに到達したときは高さはH[i] (木iの頂上) にいることに固定し、その状態をもとに次に飛び移る。
    # 飛び移ると、
    # 到着時の高さ = H[i]
    # 飛び移る時間 t 秒
    # 飛び移る瞬間高さはH[i]で固定（上下移動済みの状態）
    # 飛び移り先での高さ = H[i] - t

    # この高さが0 <= H[i] - t <= H[next]を満たさなければ移れない。

    # 次の木では高さ(H[i] - t)からさらに上下可能で時間差分はabs(H[next] - (H[i] - t))

    # まとめると、
    # dist[next] の更新は、
    # dist[next] = min(dist[next], dist[i] + t + abs(H[next] - (H[i] - t)))

    # 初期は、木1の頂上H[1]に居るのではなく高さXにいる。
    # だから初期距離はXメートルから木1の頂上H[1]に上がる時間 abs(H[1] - X) も含めて距離として考慮すべき。

    # 整理後、
    # dist[1] = abs(H[1] - X)

    # 各辺について、
    # 条件：0 <= H[i] - t <= H[next]
    # 更新式： dist[next] = min(dist[next], dist[i] + t + abs(H[next] - (H[i] - t)))

    # Dijkstraによりこれを実装する。

    # ここで注意点は
    # dist[i] は木iの頂上にいるときの最短時間として解釈される。

    # よって初期状態は、
    # 木1の頂上に到達するまでの時間は abs(H[1] - X)

    dist = [float('inf')] * (N + 1)
    dist[1] = abs(H[1] - X)

    hq = [(dist[1], 1)]
    while hq:
        cur_dist, v = heapq.heappop(hq)
        if dist[v] < cur_dist:
            continue
        if v == N:
            # 木Nの頂上に到達した最短時間を出力
            print(cur_dist)
            return
        for nxt, t in graph[v]:
            # 飛び移ることが可能かチェック
            height_after_jump = H[v] - t
            if height_after_jump < 0:
                continue
            if height_after_jump > H[nxt]:
                continue
            # 次の木の頂上に移動するための時間
            cost = t + abs(H[nxt] - height_after_jump)
            nd = dist[v] + cost
            if dist[nxt] > nd:
                dist[nxt] = nd
                heapq.heappush(hq, (nd, nxt))
    print(-1)

if __name__ == "__main__":
    main()