# 解説:
# JOI商店街にはN個の店があり、それぞれJ,O,Iのスタンプを持っている。
# 新たに１つ店を入れる場所はN+1箇所（入口と店1の間、店1と店2の間、…、店Nと出口の間）
# 新店舗もJ、O、Iのいずれかのスタンプを用意することができるため、
# 場所とスタンプの組み合わせは3*(N+1)通り。
#
# 問題は、新店舗をどこにどのスタンプで入れた場合に、J→O→Iの順で
# スタンプが押された3つの店を選ぶ組み合わせの総数（商品券をもらえる選び方）が最大になるかを求めること。
#
# 重要ポイント：
# 商店街は一方通行で番号が小さい店から大きい店へしか通れない。
# スタンプラリーは、3つの店を選ぶ順番も番号順。
# 組み合わせ総数は「Jを押した店i < Oを押した店j < Iを押した店k」となる(i<j<k)の総数。
#
# 解法:
# 新店舗を挿入した結果の文字列を全て実際に作って数え上げるのは計算量的に不可能（N=10万なので）。
#
# 効率的に求めるために、元の配列をもとに
# - 「各位置iにJがある場合、iより前にあるJの数＝J_count_before[i]」
# - 「各位置iにOがある場合、iより前にあるJの数＝sum_J_before[i]」
# - 「各位置iにIがある場合、iより前にあるOの数＝sum_O_before[i]」
#
# しかしこれも複雑なので、以下の戦略で計算する。
#
# 「もとの店配列を一旦数え、J-O-Iの三連コンビの総数を求める」
# 新しい店を入れた時、挿入位置によって配列が変わるが、
# 新しい店が含まれる場合の三連コンビを貪欲に数える。
#
# ここでは、元の配列と新しい店の位置で分けて考える。
# 3つの店のうち新店舗をどの位置に選ぶかは3通り（J,O,I）
# 新店舗がJなら、新店より後ろでOとIを選ぶ必要がある。
# 新店舗がOなら、前にJ、後ろにIが必要。
# 新店舗がIなら、前にJとOが必要。
#
# それぞれのパターンで、
# pre_J[i] := 位置iまでにあるJの数
# pre_O[i] := 位置iまでにあるOの数
# pre_I[i] := 位置iまでにあるIの数
#
# post_J[i] := 位置i以降にあるJの数
# post_O[i] := 位置i以降にあるOの数
# post_I[i] := 位置i以降にあるIの数
#
# これらを使って、たとえば新店舗がJで位置pに入る場合は、
# 新店舗のJを選び、そこより後ろにあるOとIを選ぶ組み合わせ数は
# (あとで挿入位置を考慮したOとIの数）から求められる。
#
# 全パターン試して最大値を求める。
#
# 注意：文字列長が大きいので必ずO(N)で計算可能な方法を実装すること。
# int64を使用し、オーバーフローに注意。

import sys

def main():
    input = sys.stdin.readline
    N = int(input())
    S = input().rstrip()

    # 各文字の個数を数える
    # pre_X[i]: 0～i-1 までのXの数
    pre_J = [0] * (N + 1)
    pre_O = [0] * (N + 1)
    pre_I = [0] * (N + 1)

    for i in range(N):
        pre_J[i + 1] = pre_J[i] + (1 if S[i] == 'J' else 0)
        pre_O[i + 1] = pre_O[i] + (1 if S[i] == 'O' else 0)
        pre_I[i + 1] = pre_I[i] + (1 if S[i] == 'I' else 0)

    # 後ろからの累積和
    post_J = [0] * (N + 2)  # N+1位置も考えるので1多く
    post_O = [0] * (N + 2)
    post_I = [0] * (N + 2)
    for i in range(N - 1, -1, -1):
        post_J[i + 1] = post_J[i + 2] + (1 if S[i] == 'J' else 0)
        post_O[i + 1] = post_O[i + 2] + (1 if S[i] == 'O' else 0)
        post_I[i + 1] = post_I[i + 2] + (1 if S[i] == 'I' else 0)

    # 元の組み合わせ数を計算
    # (i < j < k かつ S[i]=='J', S[j]=='O', S[k]=='I') の総数
    # 2重ループを避けるために dp使う
    # 方法: O(N)で計算
    # Jの位置をスキャンし、
    # それより右側のOとIの組み合わせ数を累積的に計算

    # まずOポジションごとのIの数を計算
    # Oの位置j ごとに、jより後ろのIの数は post_I[j + 1]
    # これらを累積してO-i組の数を計算
    o_i_acc = [0] * (N + 1)  # iはOのindex
    for i_ in range(N):
        o_i_acc[i_ + 1] = o_i_acc[i_] + (post_I[i_ + 2] if S[i_] == 'O' else 0)

    # 次にJの位置iから、iより後のO-I組の数を求める
    ans_original = 0
    for i_ in range(N):
        if S[i_] == 'J':
            # Jの次の位置から後ろのO-I組
            # Oの位置は j > i_
            # したがって、O位置jは (i_+1)からNまで
            # o_i_accはOの位置毎にI数累積
            val = o_i_acc[N] - o_i_acc[i_ + 1]
            ans_original += val

    # 次に、新しい店を挿入する場所は N+1箇所
    # 位置pは0～Nまでの整数で考え、pは新しい店のindex（挿入位置）
    # p=0は入口と店1の間、p=1は店1と店2の間、... p=Nは店Nと出口の間

    # 新しい店のスタンプはJ,O,Iの3種類

    max_ans = ans_original  # 新店を入れない場合の最大数（比較用）

    # 新店を入れたときの総数を考える:
    # 新店がJの場合:
    # 新店のJはp番目（0~N）に挿入。
    # その後ろでO-Iが選ばれる必要がある。
    # つまり、新店のJは必ず最初で揃えられるので、
    # 新店位置p以降のO-I組の数を計算 → pより後のOの位置 j > p のO-I組
    #
    # Oの位置とI数累積は元はN個だが、新店の挿入による影響を計算しなければならない。
    #
    # ただし新店は1つだけで、それがどのスタンプか。
    #
    # 新店を入れてできる配列長はN+1。
    #
    # 新店は位置pに入るが、元の店のインデックスは0~N-1。
    #
    # 新店の位置を基準に元のインデックスがずれることに注意。
    #
    # ここでは簡単化のため、元の店と新店を区別し、3パターン検討し、
    # 新店をJ,O,Iどれにしたときの各組み合わせ数を計算する。
    #
    # 計算は新店影響を含めて行うため、p位置を境に左右のO,I,Jの個数を計算。
    #
    # 元の配列で、新店を入れたときのp以降やp以前の文字数はそれぞれの累積和から計算可能。
    #
    # 以下アプローチで計算する：
    #
    # 新店がJの時:
    #   新店のJ（位置p）
    #   pより右側(>p) のOとIから組を作る => (O数)*(I数)のように考えられる?
    #
    # 新店がOの時:
    #   Jが左（<p）
    #   新店のO（位置p）
    #   Iが右（>p）
    #   組み合わせ数は J数*I数
    #
    # 新店がIの時:
    #   Jが左(<p)
    #   Oが左(<p)
    #   新店のI（位置p）
    #   組み合わせ数は J数*O数
    #
    # さらに元の店だけでできる組み合わせ(選ばない新店を利用しない)
    # も考慮に入れて最大値をとる。
    #
    # これらを計算するために、pの位置で区切った左側右側の各文字数を計算する。

    for p in range(N + 1):
        # 挿入位置pの左側の元の店は indices = 0～p-1
        # 右側は indices = p～N-1 (元のインデックス)
        # 左側のJの数
        J_left = pre_J[p]
        O_left = pre_O[p]
        I_left = pre_I[p]
        # 右側のJ,O,Iの数
        J_right = pre_J[N] - pre_J[p]
        O_right = pre_O[N] - pre_O[p]
        I_right = pre_I[N] - pre_I[p]

        # 新店がJの場合：
        # 新店はJで位置pに入る。
        # 選び方数は、
        # 「新店のJ」を1番目に選び、
        # 2番目に選ぶOは位置>p、
        # 3番目に選ぶIは位置>O位置>p
        #
        # よって、pより右のOとIの組み合わせ数の合計。
        # pより右の店の中で (O_i < I_k)となる組み合わせ数を前計算しておく。
        #
        # 元の件と同様の考え方で、pより右側で「O位置 j,k>p に対する O...I 組み合わせ数」を計算
        # p以降の配列の長さは N - p
        # 元配列をスライスして行うのは遅いので、前計算で実装。
        #
        # なので、O位置 jについて p < j <= N の範囲の O-I 組み合わせ数を求める → 累積配列から計算

        # pより先頭からのindexはずれるので、そのまま使うと困る。
        # そこで、p位置の新店挿入により、元の配列の店も右にずれる。

        # しかし、新店は単一の位置pに挿入されるだけなので
        # 新店挿入後、元の文字は以下のように移動する：
        # - 元のindex < p ⇒ unchanged
        # - 元のindex >= p ⇒ index +1 にずれる

        # 新店を挿入した結果のインデックスで考えると、
        # p位置は新店の位置
        # 元の配列の0～p-1番目の店は0～p-1のまま
        # 元の配列のp～N-1番目の店はp+1～N番目にずれる
        #
        # つまり、p以降の元の店のスタンプ位置は+1される。

        # それにより、p以降のOの位置、Iの位置も+1される。
        # よって「O-I組み合わせ数」もインデックスシフトを考慮する。

        # 事前計算してあるo_i_accは 元の0〜NのO位置とIの位置に基づいている。
        # 挿入後の位置での計算は o_i_accを用いるためインデックス変換が必要

        # 元配列のOある位置を元のインデックスで調べる
        # 新店挿入後のOの位置 =
        #   元のO位置 < p → そのまま
        #   元のO位置 >= p → 元のO位置 + 1
        #
        # Iについても同様

        # 組み合わせ計算は「Jの位置 i < Oの位置 j < Iの位置 k」
        # 新店のJはp番目。OとIはp+1以降の位置。

        # このため、p+1からN+1までのインデックスでのO-I組み合わせ数を求めたい。

        # o_i_accは元のインデックスでのO位置昇順に対してIの累積和を計算済み。
        # 昇順にOの位置を並べ、その位置に対応したIの数を足し合わせたもの。

        # よく考えて計算しなおす方法：
        # 1) 新店挿入後の配列は長さN+1。
        # 2) 新店挿入後、元の店の位置は以下のとおり：
        #    元のインデックス i < p → 新配列の位置 i
        #    元のインデックス i >= p → 新配列の位置 i+1

        # 3) このとき、新店の位置pはj or o or iの場合にそれぞれ使う。

        # そこで、新配列におけるOの位置のリストとIの位置のリストを考える。
        # 新店は文字列に入るため、OまたはIの場合は新店が追加される。

        # ただし新店がJの場合はOとIは新店位置pの後ろにいる元の店のみ。

        # したがって、新店がJの場合は、
        # 元の店のOの位置が >= pのものは新配列で+1されてpより後ろに配置される。
        # Oの位置は [O_i for O_i in 元のO位置] を作り、
        # pより後ろのOを用いてI組を計算。

        # o_i_accはO位置に対応したIの数累積だが、Oの位置をリストで持ち、
        # pより後のOの組み合わせを取り出す。

        # この計算を効率的に行うため、OとIの位置のリストがほしい。

    # 以上より、Oの場所とIの場所をリスト化しよう。
    O_pos = []
    I_pos = []
    for i_ in range(N):
        if S[i_] == 'O':
            O_pos.append(i_)
        elif S[i_] == 'I':
            I_pos.append(i_)
    # O_pos, I_posは昇順

    # さらにI_posの個数を、O_posのindexの位置から後ろのIの数を数えるために
    # 位置比較を高速化。
    #
    # O_iが与えられたら、
    # I_jはI_pos配列の中でO_i < I_jであるI_jの個数を二分探索で求める
    # これらを累積してo_i_accを作った。

    import bisect

    # O毎の Iの数を保持
    o_i_ = []
    for o_p in O_pos:
        # I_posの中で o_p < I_pos[j]となるjの個数 = len(I_pos) - (o_p以下の最大index+1)
        idx = bisect.bisect_right(I_pos, o_p)
        o_i_.append(len(I_pos) - idx)

    # o_i_accを再作成（1-indexed）
    o_i_acc2 = [0]
    for val in o_i_:
        o_i_acc2.append(o_i_acc2[-1] + val)

    # 「新店がJ」で位置pに入れた時のOとIの組み合わせ数計算関数
    def OI_count_after_p(p):
        # pより後にあるOのindexはO_pos上でpを超えるものだけ
        # O_posは昇順なので二分探索で開始indexを求める
        idx =