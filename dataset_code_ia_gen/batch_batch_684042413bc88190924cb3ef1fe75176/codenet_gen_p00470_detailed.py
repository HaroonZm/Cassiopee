# 入力された w, h に対して JOIさんの通勤経路の個数を求めるプログラム
# 東または北にのみ進み、かつ連続して曲がることはできない条件の下で経路数を数える
# 結果は 100000 で割った余りを出力する

MOD = 100000

def main():
    import sys
    input = sys.stdin.readline

    # dp配列:
    # dp[i][j][k] = 交差点(i,j)に到達し直前の移動方向がkの経路数
    # k = 0 : 最初状態（まだ移動していない）または曲がっていない状態
    # k = 1 : 直前の移動方向が東（横方向）
    # k = 2 : 直前の移動方向が北（縦方向）
    #
    # ここの「曲がった直後は次の交差点で曲がれない」という規則は直前に曲がったかどうかを管理する必要がある。
    # つまり、曲がった直後の移動方向は前回の移動方向と同じでなければならない。
    #
    # よって、実際には「連続して曲がらない」ように前回の移動方向記憶と曲がったかどうかで制御する必要がある。

    # 状態を拡張して、
    # dp[i][j][k][l]
    # k: 前回の移動方向 0(初期), 1(東), 2(北)
    # l: 曲がった直後のフラグ 0(曲がっていない),1(曲がった直後)
    # 曲がった直後の時は次は曲がれない(つまり同じ方向にしか進めない)
    # 曲がっていない時は曲がっても良い

    while True:
        line = input()
        if not line:
            break
        w,h = map(int, line.split())
        if w == 0 and h == 0:
            break

        # dp初期化
        # サイズは (w+1) x (h+1) x 3 x 2
        dp = [[[[0]*2 for _ in range(3)] for _ in range(h+1)] for _ in range(w+1)]

        # 出発点(1,1)に最初状態としてセット
        dp[1][1][0][0] = 1

        for i in range(1, w+1):
            for j in range(1, h+1):
                for k in range(3):   # 前回の移動方向
                    for l in range(2):  # 曲がった直後フラグ
                        val = dp[i][j][k][l]
                        if val == 0:
                            continue
                        # 移動可能方向は東と北のみ
                        # 東へ(横方向=1)
                        if i < w:
                            # 今の移動方向は1(東)
                            if k == 0:
                                # まだ移動していない状態なので曲がりしていない状態で走れる
                                dp[i+1][j][1][0] = (dp[i+1][j][1][0] + val) % MOD
                            else:
                                if l == 1:
                                    # 直前で曲がった直後であれば、曲がれないので今の移動方向は前回の移動方向と同じでなければならない
                                    # 曲がった直後は次も同じ方向に進む必要あり
                                    if k ==1:
                                        dp[i+1][j][1][0] = (dp[i+1][j][1][0] + val) % MOD
                                    # k!=1なら進めない
                                else:
                                    # 曲がっていない状態なら曲がるのもOK
                                    if k ==1:
                                        # まっすぐ進むと曲がった直後フラグは0
                                        dp[i+1][j][1][0] = (dp[i+1][j][1][0] + val) % MOD
                                    else:
                                        # k!=1なら曲がったことになるので曲がった直後フラグ1
                                        dp[i+1][j][1][1] = (dp[i+1][j][1][1] + val) % MOD
                        # 北へ(縦方向=2)
                        if j < h:
                            # 今の移動方向は2(北)
                            if k == 0:
                                dp[i][j+1][2][0] = (dp[i][j+1][2][0] + val) % MOD
                            else:
                                if l == 1:
                                    # 曲がった直後は次も同じ方向でないと進めない
                                    if k == 2:
                                        dp[i][j+1][2][0] = (dp[i][j+1][2][0] + val) % MOD
                                else:
                                    if k == 2:
                                        dp[i][j+1][2][0] = (dp[i][j+1][2][0] + val) % MOD
                                    else:
                                        dp[i][j+1][2][1] = (dp[i][j+1][2][1] + val) % MOD

        # 終点(w,h)における全状態の合計
        ans = 0
        for k in range(3):
            for l in range(2):
                ans = (ans + dp[w][h][k][l]) % MOD

        print(ans)

if __name__ == "__main__":
    main()