import sys
sys.setrecursionlimit(10**7)

def main():
    N = int(sys.stdin.readline())
    A = [int(sys.stdin.readline()) for _ in range(N)]

    # ケーキは円形に並んでいるのでインデックスを環状に扱う
    # 状態をbitで管理すると2^2000で扱えないため、ビットマスクDPは不可。
    # 制約を考えると、全ての手番をシミュレートするのは困難。
    # 方針：最初の1ピースをJOIくんがどれを取るか全探索
    # その後の展開はIOIちゃんが最大の取れるピースを常に取るので決定的
    # JOIくんは自分のターンに好きな取れるピースを取れるので、その中で最大の合計を求める

    # 実装方針詳細（シミュレーション）：
    # - 各初期選択(i)でシミュレーション開始
    # - 取り除かれたピースをTrueで管理
    # - 最初にJOIくんがiを取り、
    # - それ以降はIOIとJOIが交互にとる。
    # - 取り得るピースは少なくとも隣接するどちらかが取られているピース
    # - IOIは取れるピースの中で最大のものを取る(決まりきり)
    # - JOIは取れるピースの中からえらべるので全部試すのは多すぎて無理なので最善を見つける。
    #
    # 多面展開問題(ミニマックス)となるため、メモ化した再帰で探索する。
    # 状態：取られたピースの集合(or取られていないピースの集合)をbitで管理できないので、
    # インデックスの集合で管理は困難
    #
    # よって、線形構造に分解した状態を保持：取ったピースの集合を表現するbitset(2^Nは無理)
    #
    # しかしN=2000でbitmaskは絶対無理。別の手法が必要。

    # 考え方別アプローチ：
    # この問題はJOIとIOIが交互にピースを取るゲームであり、
    # IOIは取れる中で最大のピースを取る決まり手、
    # JOIは取れる中を自由に選べる。
    #
    # 整合性のある考えは、初期状態から始めて取り除く条件で、
    # 常に「連続区間」で選べるピースが広がる形を利用して、
    # 区間DP(動的計画法)を使う。
    #
    # 区間DPの典型例は、円環状の領域の取り合いゲーム。
    # そこで、円を一周の切り口をずらして線形化し、長さNの店舗を長さ2Nに伸ばし、
    # 区間DPを使用。
    #
    # しかし今回のルールは「両隣に少なくとも一方取られている」条件でしか取れない。
    #
    # 重要な観察：
    # - 最初にJOIが1ピースとる → そのピースは取られている
    # - 次にIOIは、周囲のどちらか隣が取られているピースのみ取れる
    # - つまり、常に取り得るピースは「取り終わったピースの両側の隙間」のすぐ隣のピースになる
    #
    # この特徴を生かす：
    # 円を切り開いて線形化した配列のうち、現在JOIとIOIが取れる候補は、
    # 取り終わったピースに隣接する未取得のピースのうち少なくとも片方が既に取得済みであるもの。
    # そこに次第に周辺へ展開していく。
    #
    # よってこの取り合いは、
    # 円状配列をあるピースで切断して線形化した後、
    # 左から右に選ばれたピースの「前後で」選べるピースが増えるゲームに似ている。
    #
    # このことから、取り合いは線形区間DPで近似できると考える。
    #
    # 具体的には、
    # DP[l][r]: 区間[l,r]のピースだけがまだ残っている状態で
    # 現在JOIのターンかIOIのターンかによって得点を最大化する。
    #
    # しかしこの問題のルールは通常の区間分割ゲームとは少し異なる。
    #
    # 今回の規則のゲームは、実は
    # 隣接ピースが取られているピースに隣接していないとダメなので、
    # つまり常に"端"のピースを取ることに相当する。
    #
    # JOIとIOIはゲームのターン毎に「端」から選ぶ。
    #
    # 一見すると、区間[l,r]から左端か右端のピースをとるゲームに似ている。
    #
    # 完全一致ではないが、この仮定で試すと
    # 区間DPで状態を管理できる。
    #
    # つまり、
    # - DP[l][r]: 区間[l,r]にまだ残っているピースがあり、
    #   次に取る人(ターンフラグ)が最大化可能なJOIの合計得点を格納する。
    # - ターンはJOI(0) or IOI(1)の2値で持つ。
    # - IOIは最も大きいピースをとるので、区間の両端で
    #   左右どちらの方が大きいかでIOIの取り得るピースを判別し、
    #   IOIは必ず大きい方を取る。
    #
    # 右端または左端しかとれない状態に制限してDP解を作成する。
    #
    # 円形のため、N個のどのピースをスタートにするか決めて
    # そこからN個分の線形配列として考え、最適を取る。
    #
    # これにより計算量はO(N^3)となるが、
    # 条件的に最適化でO(N^2)に収まることが期待できる(N<=2000はギリギリ)
    #
    # 実装：
    # - 配列Aを2倍に拡張して円環を線形化。
    # - 各開始点s(0<=s<N)を試す。
    # - DPテーブルDP[l][r][turn](turn 0=JOI,1=IOI)を
    #   区間[l,r]での次にとる人の最大点を計算。
    # - 最初のJOIの手番はs～s (1ピースのみ)
    # - 以降区間内でターンを繰り返し、端からピースを取るルールに従う。
    #
    # IOIが最大のピースを取るので、両端どちらを取るかはIOIが決定している。
    # JOIは好きに選べるので、JOIは両端のどちらをとるか選び最終得点を最大化。
    #
    # あとは出力で最大のJOI得点を出す。

    INF = 10**15

    # Aを2倍にして円環状に扱う
    AA = A + A

    ans = 0

    # turn == 0 : JOIのターン
    # turn == 1 : IOIのターン

    # DP[l][r][turn] : 区間[l,r]に残っているピースから次の人のターンで取ったときの
    # JOIの合計得点の最大値を格納
    # N<=2000だが、この3次元配列は非常に大きい
    # これはメモリ制限大でアウト
    #
    # そこで2次元DPとし、turnは関数の再帰呼び出しで対応し
    # 配列は3次元使わずに済む。
    #
    # しかしDP計算量はO(N^3)

    # turnをパラメータに含むメモ化再帰
    from functools import lru_cache

    @lru_cache(None)
    def dp(l, r, turn):
        # 区間[l,r]にまだピースが残っている状態、
        # 次の手番はturn(0=JOI,1=IOI)
        length = r - l + 1
        if length == 0:
            return 0

        # 両端のピースの大きさ
        leftA = AA[l]
        rightA = AA[r]

        if turn == 0:
            # JOIのターン
            # JOIは取り得る端2つのピースから好きな方を選べる
            # どちらを取っても良いので2つ試す
            # 自分の得点に取ったピースの大きさを足して次のターン(IOI)
            take_left = leftA + dp(l+1, r, 1)
            take_right = rightA + dp(l, r-1, 1)
            return max(take_left, take_right)
        else:
            # IOIのターン
            # IOIは取れるピースの中で最大のものを取る
            # 取り得るのは端の2つなので、それらのうち大きい方を選ぶしかない
            if leftA > rightA:
                # IOIは左端を取る
                return dp(l+1, r, 0)
            else:
                # IOIは右端を取る
                return dp(l, r-1, 0)

    # 円環状なので開始点を0～N-1までずらして試す
    # initial JOIの手番で1ピースだけ取った状態を開始点として区間を設定
    # 取り始めている区間は[l,r]＝[s,s]、残りは区間の外
    #
    # しかし上のDP定義は残ったピースの区間を[l,r]としているため
    # 開始時は[l,r]= [0, N-1]
    # だがJOIが最初にとるピースを任意に選べる問題のため、
    # 実は
    # JOIが最初に1ピース目としてs番目をとる場合、
    # dpを呼ぶ区間はs+1から s+N-1までの区間（残りのN-1個）に相当
    # ここでは残りN-1個のピースを順に取るゲームとしてシミュレートする。
    #
    # よって、JOIが最初にsを取ったことでJOI点数=AA[s]、
    # 残り区間は[s+1, s+N-1]
    # IOIのターンからスタート

    for s in range(N):
        joi_score = AA[s] + dp(s+1, s+N-1, 1)
        if joi_score > ans:
            ans = joi_score

    print(ans)

if __name__ == "__main__":
    main()