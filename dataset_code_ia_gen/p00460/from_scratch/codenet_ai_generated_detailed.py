# 問題解析およびアプローチ
# 
# 条件から作るべきビンゴカードは N行N列 の二次元配列である。
# 
# 条件を整理すると：
# 1. カードは N×N のマス目。
# 2. 各マスには異なる正整数 (1以上M以下) が書かれている。
# 3. すべての数字の合計は S。
# 4. 各列は上から下に向かって昇順に並んでいる。つまり、縦に単調増加。
# 5. 各マスの整数はその左の列のどの整数よりも大きい。つまり、列 i のすべての数字は列 i - 1 のどの数字よりも大きい。
# 
# 具体的に条件5から、
# 列 i はすべて、列 i - 1 の最大値より大きい値で構成される必要がある。すなわち、各列は数の区間で明確に分離されている。
# 
# そこで、一意性（全数字異なる）と昇順条件を利用して、さらに縦並びは昇順なので各列は昇順な増加列、各列の値の範囲は左の列の最大値より大きい連続する整数集合から選ぶ。
# 
# アプローチ
# 
# ・カード全体を N 本の列の配列として捉える
# ・各列は昇順な N 個の異なる整数の集合
# ・列 i は、その前の列の最大値より大きい値を使う必要があるため、これらの N 本の長さNの列は連続的な増加列で、また全体の数字は単調増加になる
# ・つまり、カード全体は単調増加な長さ N^2 の配列を N 個の部分列に分割し、各部分列が長さ N の昇順列。
# 
# ・入力
# N, M, S
# 
# 求めるべきは：
# 「数字は異なり 1～M の中から N^2 個 選び合計 S で、N 行 N 列に分けて、
# 　それぞれの列が昇順で、かつ列 i は列 i-1 の数値より全て大きい、
# 最大のカードの枚数」
# 
# 等価に考えると
# 
# ・1～M の数字集合から N^2 個を選び、単調増加な配列 (長さ N^2) を作る
# ・その配列を N 個に均等に分割（列に分割）
# ・各列は長さ N の昇順列
# ・かつ、全体の和がS
# 
# まとめると
# ・長さ N^2 の strictly increasing sequence a[0]<a[1]<...<a[N^2-1] があって、
# 　a[i+1] > a[i]
# 　かつ
# 　∀ j in [1...N-1], min{a[j*N ... j*N+N-1]} > max{a[(j-1)*N ... (j-1)*N+N-1]}　←　これは strict increasing 全体により自動的に満たされる
# 　（つまりぶつかり無し）
# ・sum(a) = S
# ・すべて a[i] in [1..M], distinct
# 
# よって単純に
# N^2 個の異なる数字の strictly increasing sequence のうち和が S、最大値は ≤ M
# 
# さらにこの数字の並びに制約なし（strictly increasing sequence，つまり単に長さ N^2 の部分集合で要素が昇順に並んでいる）
# 
# よってモデル化は
# ・1..M の数字の中から N^2 個選ぶ
# ・和が S
# を満たす組み合わせ数
# 
# これがビンゴカードの枚数に一致する。
# 
# 
# 方針：
# 集合から大小順に選ぶので、ほぼ
# 「M 個のうちから N^2 個選ぶ組み合わせで和が S となるパターン数」
# 
# よってDP的に「数字を1からMまで見て、k 個選び和が w の通り数」を数える
# 
# 制約は
# N ≤ 7 → N^2 ≤ 49
# M ≤ 2000
# S ≤ 3000
# 
# DPの状態数は
# dp[pos][selected][sum]
# pos : 0~Mまで数字を考えたところ
# selected : 選んだ数字数 (0~N^2)
# sum : 現在の和 (0~S)
# 
# この DP は
# dp[pos][selected][sum] = dp[pos-1][selected][sum] + dp[pos-1][selected-1][sum - pos] (posを選ぶ場合)
# 
# 計算量的に
# pos: 2000
# selected: 最大49
# sum:最大3000
# これでメモリは重いが工夫すれば十分可能（time, memory は注意）
# 
# 実装ポイント：
# ・dp は 2D (selected, sum) のみで遷移（posを進めるごとに更新）
# ・dp初期状態 dp[0][0] = 1
# ・MOD 100000
# 
# ・入力複数ケース対応
# 
# 以下実装。

import sys
input = sys.stdin.readline

MOD = 100000

while True:
    line = input().strip()
    if not line:
        break
    N, M, S = map(int, line.split())
    if N == 0 and M == 0 and S == 0:
        break

    total = N * N
    # dp[selected][sum] = 選んだ数字数 selected 個で和が sum となる組み合わせ数
    # 初期化
    dp = [[0] * (S + 1) for _ in range(total + 1)]
    dp[0][0] = 1

    for x in range(1, M + 1):
        # x を使うか使わないか選ぶ
        # 使う場合: dp[selected][sum] += dp[selected-1][sum-x]
        # 使わない場合は dp に変化なし
        # 逆順で更新しないと二重カウントになる
        for selected in range(total - 1, -1, -1):
            for sum_ in range(S - x + 1):
                if dp[selected][sum_] != 0:
                    dp[selected + 1][sum_ + x] = (dp[selected + 1][sum_ + x] + dp[selected][sum_]) % MOD

    print(dp[total][S] % MOD)