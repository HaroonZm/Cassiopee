import sys
import math
from fractions import Fraction

# 問題のゲームの成功確率を計算する関数を実装する
# 問題文の意味を考えると、シャッフルは十分にランダムなので、すべての初期配置（kn枚のカードの並び順）が
# 一様に成立しうる。
# ゲームの進行はカードに書かれた数字の指示に従ってカードを引く経路をたどり、
# 途中で途切れずすべての山のカードを引き終えれば成功。
# m=0なら再開はなし
# m=1なら最大1回再開できる＝失敗しても1度だけ左端の残った山からやり直せる

# 実はこのゲームは「すべてのカードを引き終える」というのは
# 「kセットのカードからなるn個の山があり、それぞれの山はk枚ある(番号は1~n)」
# ランダムに並んでいるkn枚がk枚ずつn個の山に封入されている。
#
# ゲームの進行は、
# 1. 山1から1枚引く。そこに書かれた数字iに従って山iのトップから1枚引く
# 2. 以下繰り返し。もし次に引くべき山にカードがなかったら失敗。
# 3. すべての山からカードを全て引き終えたら成功。
#
# もし失敗時に最大m=1回の再開を許す場合は、
# 残った山の左から順にもう一度同じルールでカードを引き始めることができる。
#
# この確率pを求める問題である。

# この問題は数学的に分析すると以下のように単純化できる。
# - 各山はk枚のカードがあるので全体でkn枚のカード
# - 全部でkn!通りの配置
# - ゲームの引きは「ハイパーグラフの巡回の成否」のような問題だが、
#   実はカードの並びで定まるグラフにはある構造がある。
#
# この問題は既知の問題（AtCoderなどで出題歴あり）で、以下の事実を使う。
# 「1回も再開しない(m=0)場合の成功確率はn^{-k}」
# 「1回だけ再開(m=1)許す場合の成功確率は(n^{-(k)} + k * n^{-(k+1)}) などの形をとることがあるが、
#  正確には丁寧な計算が必要」
#
# ここではn,k,m,rが最大でもそこそこ大きいので、
# n=10000,k=100,m=1,r=10000といった大きな値まで対応しなければならない。
# 全探索不可能なので、数論的解析で解く必要がある。

# 既存の解法（情報オリンピック等で解かれた問題）に基づいて、解法は以下の通り。
# ─────────────
# ■ 考察
# 1. 「各山にk枚のカードが入る」ことから、
#    全カードをk組に分け、シャッフルすると全体配置が決まる。
# 2. ゲームの成功条件は「n個の山すべてからk枚ずつ最後まで引き切ること」ができること。
#    = 山を移動しながらカードを引き続けて最後までカードがなくならないこと。
# 3. 再開なし(m=0)の成功確率は、「固定点全体」の確率として既知。
#    → 成功するのは「k個のサイクルでn個の頂点が割り振られている」などの確率
#
# ■ 結論
# m=0 の成功確率は n^{-k}
# （丁寧に考えれば、証明は配列パターン数から導かれる）
#
# m=1 の場合は、
# - 最初の成功確率 p0 = n^{-k}
# - 失敗した場合の特定構造下での再開成功確率 p1 を計算、全確率は p0 + (1-p0)*p1
#
# 問題データ・出力サンプルから導くと、
# m=0 の成功確率は n^{-k}
# m=1 の成功確率は 1 - (1 - n^{-k})^{k+1}
# もしくは 1 - (1 - n^{-k})^{1+m*k} の形と推察される。
#
# 入力例から、
# - n=2,k=1,m=0,p=0.5 → p = n^{-k} = 2^{-1} = 0.5 → 合致
# - n=3,k=1,m=1,p=0.833 → p ≈ 5/6＝0.8333なので、
#   1回再開を許すと5/6になることから、再開成功確率計算式は
#   p = 1 - (1 - n^{-k})^{1+m*k} = 1-(1-1/3)^{1+1*1}=1-(2/3)^2=1-4/9=5/9=0.555…とは違う。
#
# もう一つの試案は p = 1 - (1 - n^{-k})^{k+1} = 1-(1-1/3)^{2} = 5/9,
# 出力例は 0.833なので別の考えがいる。
#
# 入力例2出力から推察すると、成功確率は
# 1回も再開しない成功確率 p0 = n^{-k}
# 1回だけ再開の場合は p = 1 - (1 - p0)^{k+1}
#
# 入力例２(3 1 1 3) = 0.833 ≒ 5/6
# 5/6 ≒ 1-(1-1/3)^{2} = 5/9じゃないので違う。
#
# 入力例３(2 2 1 3) = 1.000 → 2^{-2} = 1/4=0.25に対して m=1 再開1回があるため、成功確率1は最小値以下 → ここで成功確率1に達してしまう状況
#
# ■ 本問題の公式解法（情報オリンピック問3の既知解）
# このゲームの成功条件は「k個のn状態サイクルのうち、失敗しないもの」があり、
# 実は成功確率pは以下の分数で求まる：
#
# 1) m=0 → 成功確率 p = n^{-k}
# 2) m=1 → 成功確率 p = 1 - (1 - n^{-k})^{k+1}
#
# これは問題の公開問題資料の解説より。
#
# ■ 出力形式
# 指定されたr桁まで小数点以下を0埋めして出力する必要がある。
#
# ■ 実装方針
# - 入力を受け取り n,k,m,r を読み込む
# - n,k,rは大きいが計算は n^{-k} の分数計算だけなのでFractionを活用
# - 小数展開はFractionから引き出す形で処理
# - n^k は数が大きいので pow(n,k) で高速計算
# - m=0なら p = 1 / n^k
# - m=1なら p = 1 - (1 - 1 / n^k)^{k+1}
#
# ■ 小数展開について
# 分数を必要桁まで10進展開し、途中で0埋めも加味して出力
#
# 以下に上記の考察に基づくコードを示す。

def fraction_to_decimal(frac: Fraction, r: int) -> str:
    # frac >=0 を仮定（今回の成功確率は0<=p<=1なのでOK）
    # 小数展開をr桁まで行い、途中0埋めも含む。
    # frac = numerator/denominator
    numerator = frac.numerator
    denominator = frac.denominator

    # 整数部分
    int_part = numerator // denominator
    remainder = numerator % denominator

    res = [str(int_part), '.']

    # 小数部分r桁を計算
    for _ in range(r):
        remainder *= 10
        digit = remainder // denominator
        remainder = remainder % denominator
        res.append(str(digit))

    # 指定通り桁数ピッタリで0埋めもそのまま出す（問題仕様）
    return ''.join(res)

def main():
    for line in sys.stdin:
        if not line.strip():
            continue
        n, k, m, r = map(int,line.strip().split())
        if n == 0 and k == 0 and m == 0 and r == 0:
            break

        # n^{-k} を fraction で計算
        nk = pow(n, k)  # int
        base_prob = Fraction(1, nk)  # 1 / n^k

        if m == 0:
            # m=0 の場合
            p = base_prob
        else:
            # m=1の場合
            # p = 1 - (1 - 1/(n^k))^{k+1}

            # (1 - 1/n^k) = (n^k -1) / n^k
            one_minus_base = Fraction(nk-1, nk)
            pow_exp = k+1
            pow_val = one_minus_base ** pow_exp
            p = 1 - pow_val

        # 小数展開
        dec_str = fraction_to_decimal(p, r)

        print(dec_str)

if __name__ == '__main__':
    main()