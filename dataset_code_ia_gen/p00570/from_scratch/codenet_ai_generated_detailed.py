# JOI君の部屋に来客がある時間帯を連結して考え、ストーブをつける回数を抑えつつ
# ストーブをつけている時間の合計を最小化する問題。
#
# それぞれの来客は [T_i, T_i+1) の時間に滞在する。
# 時間はソートされているので、隣接する来客間の隙間の長さを計算し、
# その隙間を無視して一続きの区間としてストーブをつけることで、消費回数を減らせる。
#
# ストーブの点火回数は K 回までなので、区間は最大 K 個に分割可能。
# 最初は各来客ごとに別区間（= N 区間）だが、
# 隙間の長さが小さい順から(最大 N-K 個)つなげることで区間を減らし、
# ストーブをつける回数を抑えられる。
#
# アプローチ：
# 1. 来客の滞在時間の区間は [T_i, T_i + 1) で、N 個の区間が存在する。
# 2. 区間間の隙間は (T_{i+1} - (T_i + 1)) = T_{i+1} - T_i - 1
# 3. この隙間を潰す（区間をつなげる）ことはK回以内の点火で済ませるための手段である。
# 4. まず全区間を別々に置いた時の合計時間は N (各来客1時間分)。
# 5. 隙間を詰めることで（つまり隙間の長さ分を合計から引く）合計時間を減らせる。
# 6. 最大で N - K 個の隙間を詰められるので、隙間の長さ小さい順に詰めていく。
# 7. 詰められる隙間の長さの総和を引いた時間が最小のストーブ稼働時間となる。
#
# 例外：
# - 隙間が0や負の場合（区間が重なるか連続）は詰める価値あり

import sys

def main():
    input = sys.stdin.readline
    N, K = map(int, input().split())  # 来客数とマッチの本数（点火回数の上限）
    T = [int(input()) for _ in range(N)]  # 来客の到着時刻 T_i

    # 全ての来客ごとにストーブをつけると
    # トータルの点火回数はN回で時間は単にN（各1時間）
    # これをK回点火に抑えるために区間をつなげる（隙間を削減）

    # 区間間の隙間長さを計算（N-1個）
    gaps = []
    for i in range(N - 1):
        # 次の来客の開始時刻 -（前の来客の退室時刻）= T_{i+1} - (T_i + 1)
        gap = T[i+1] - T[i] - 1
        # 隙間は0以上（連続または空く）
        gaps.append(gap)

    # 現状、全区間別々に点火すると、トータルのストーブ稼働時間は各区間1時間ずつ合計N時間
    total_time = N

    # 区間の個数を K 個にしたい = N 個の区間を N-K 個隙間でつなぐことができる
    # 点火回数を抑えるためにつなぐ隙間長を大きいものから詰めると良いが
    # ここでは逆に隙間が小さい順に詰めていくのが正しい：
    # - 小さい隙間をつなぐとその分の無駄なストーブ時間を省け、
    # - 点火回数を抑えながら時間短縮につながる
    # 実は隙間が大きいほど詰めてはいけない（大きい隙間は無理に繋ぐと余計に時間発生）
    # よって、隙間の大きい順に切る（区間を分割）し、
    # 点火回数をKに収めるために (N-K) 個の隙間を選んで区間をつなぐ。
    #
    # 実装としては隙間を全て降順ソートし、上位 (K-1) 個の隙間をそのままにし、
    # 残り (N-K) 個の隙間を詰める（つまり時間を短縮）する。

    # 隙間のリストを降順にソート
    gaps.sort(reverse=True)

    # 最も大きい (K-1) 個の隙間を区切りとして残す
    # 小さい隙間を詰めて、時間短縮効果を得る
    # 詰める隙間は残りの (N-1 - (K-1)) = N-K 個

    # 短縮できる時間は小さい隙間の合計（つまり全隙間から最大K-1個を引く分）
    # 隙間が負のことは問題文から無いが、念のためmax(0, gap)で扱っておく

    # (N-K) 個の隙間の合計を全部詰めて減らせる時間として計算するために
    # 一旦全隙間の合計から最大K-1個の大きい隙間の合計を引く

    total_gap = sum(gaps)
    largest_gaps_sum = sum(gaps[:K-1]) if K > 1 else 0

    # 詰められる区間の合計隙間 = total_gap - largest_gaps_sum
    time_saved = total_gap - largest_gaps_sum
    # マイナスになることはないはずだが念のため
    if time_saved < 0:
        time_saved = 0

    # 最終的なストーブ稼働時間は
    ans = total_time + time_saved  # total_timeはNだが詰める分だけ増えるのではなく減る...

    # ここでtotal_timeはNであるが、実は起動を減らす＝時間短縮ではなく、
    # 隙間分だけストーブをつけっぱなしにする時間が減るため、
    # 正確には元々ストーブを点けた区間の全長は
    # Σ区間の長さ + Σ隙間（すべて区間をつなげた場合）= (最後のT + 1) - 最初のT = T_N + 1 - T_1
    # 実際には最初にストーブつけて、最後に消すまでずっとつけるときの時間なので、
    # 点火回数に制限があるため区間を分割しなければならない。
    #
    # 純粋に全部の区間をつなぐとストーブ稼働時間は
    # (T[N-1] + 1) - T[0]
    #
    # だから解き方は次の通り：
    # 1. すべてつなげた時の稼働時間 = (T[N-1]+1) - T[0]
    # 2. そこから分割した回数分の隙間を足し戻すことで稼働時間が増加。
    # 3. 隙間を降順ソートしそのうち大きいものから(K-1)個選んで区間を分けることで
    # 点火回数K回になる。
    #
    # よって、実際の答えは：
    # (T[N-1]+1 - T[0]) + sum of (K-1) largest gaps

    min_time = (T[-1] + 1) - T[0] + sum(gaps[:K-1]) if K > 1 else (T[-1] + 1) - T[0]

    print(min_time)

if __name__ == "__main__":
    main()