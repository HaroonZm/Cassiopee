# 問題の要約と考察：
# n個の頂点があり、無向辺を追加していくとき、グラフの直径がちょうどdになるようにしたい。
# 直径dとは、全頂点間の最短距離の最大値がdということ。
# 多重辺や自己ループは認められない。
# このとき、張ることができる最大の辺の本数を求める。
#
# 直径dのグラフの最大辺数を求める問題。
#
# アプローチ：
# - 直径が1の時は、完全グラフになるので辺の最大数は n*(n-1)/2
# - 直径がn-1の時は、最も長い距離がn-1のパス型（連結リスト）で、最大の辺数はn-1
#   → これは最小本数だが、直径をdに保ったまま辺を追加できるかが問題
#
# 具体的な考察：
# 直径がdになるグラフで最大の辺数を考えるには、
# ある頂点間の距離がdであるようなペアが必要で、そのようなペアを壊さずに辺を張る。
#
# 解法の鍵は、
# 「直径dのグラフを作る」つまり「任意の2点間の距離が最大dで、その中に距離dのパスが存在する」。
#
# この問題はAtCoderの典型問題で、
# 最大辺数は以下の通り：
#
# - d=1の時：完全グラフ → n(n-1)/2
# - d>1の時：
#   半径 (radius) は少なくとも ceil(d/2)
#   直径dとなる最小の木はパス (n-1辺)
#   そこへ辺を追加すると直径は縮むかもしれない。
#
# AtCoder問題の解答例より：
#
# 以下の式で求められる：
#
# 最大の辺数 = (n-d)*(n-d-1)/2 + d*(n - d) + (d - 1)
#
# 意味：
# - 最長距離dの経路をパスで確保 → d本の辺
# - そこから離れた(n-d)点は、「直径経路上の点」にすべて隣接させる（距離を縮めない限界まで）
# - (n-d)*(n-d-1)/2 は残りの点同士で作れる完全グラフの辺数
#
#
# 関数を実装して計算する。

import sys

def max_edges(n: int, d: int) -> int:
    # 直径が1なら完全グラフ
    if d == 1:
        return n * (n - 1) // 2
    
    # d >= 2 のとき
    m = n - d
    # (n-d)個の頂点間の完全グラフの辺数 + (n-d)*d + (d-1)
    # (d-1): 長さdのパスの辺数はd本だが、計算上端点に1本ずつの辺を重複して数えているので調整
    return m * (m - 1) // 2 + m * d + (d - 1)

def main():
    input_line = sys.stdin.readline()
    n, d = map(int, input_line.strip().split())
    print(max_edges(n, d))

if __name__ == "__main__":
    main()