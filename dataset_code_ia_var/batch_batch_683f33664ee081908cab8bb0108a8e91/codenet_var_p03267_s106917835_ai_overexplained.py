# 開始：標準入力から整数Lを受け取る
L = int(input())  # input()は標準入力から文字列を得るため、int()で整数に変換する

# 辺(edge)を格納するためのリストを初期化する
edges = []  # edgesはグラフの辺を格納するリスト。各要素は[始点, 終点, コスト]のリストとなる

# 最初の頂点番号を1番にする
v = 1  # vは現在扱っている頂点番号
base = 1  # baseは現在までに到達できる範囲を表す（2のべき乗）

# 2のべき乗による区間を作り上げていく
while base * 2 <= L:  # baseを2倍してもLを超えない間は繰り返す
    # 辺 1: コスト0の辺を追加
    edges.append([v, v+1, 0])  # 頂点vから頂点v+1へコスト0で進む辺
    # 辺 2: コストbaseの辺を追加（baseは2,4,8,...と増えていく）
    edges.append([v, v+1, base])  # 頂点vから頂点v+1へコストbaseで進む辺
    # base, v を更新し、次の頂点へ。baseは2倍されて2,4,8...となる
    base *= 2  # baseを2倍に更新（次の2のべきへ）
    v += 1  # 頂点番号も1つ大きくする

# 最後に到達する頂点（ゴール）を決める
end = edges[-1][1]  # 最後の辺の終点をendとする

# まだL-base（残りのコスト）分進む必要がある
rest = L - base  # 残りの距離（L-base）をrestとする

# 残り(rest)を2進数で分解し、それぞれのビットが1立っている部分を確認する
for i in range(19):  # 2**18 = 262144 で、Lは10^6くらいまで大体カバーされる
    # restのiビット目が1かどうか判定
    if (rest >> i) & 1:  # 右にiビットシフトして1とANDを取ることで、iビット目が1か調べる
        num = 2 ** i  # 2のi乗を計算して現在の区間長とする
        # i+1番目の頂点（＝その2**iの区間の開始）からendへのコストを持つ辺を作る
        edges.append([i+1, end, L-rest])  # i+1番目からゴールまで、コストはL-rest。L-restは始点となる頂点から進んだ距離
        rest -= num  # この分を引いて、restを次のループのために更新する

# 最後に頂点数と辺数を出力する
print(v, len(edges))  # 頂点数v、辺数はedgesの長さ

# 辺の各要素を出力する
for i in range(len(edges)):  # edgesリストの長さ分だけ繰り返し
    print(*edges[i])  # *を使うことでリストの要素を空白区切りで出力する（例：1 2 0）