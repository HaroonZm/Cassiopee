def solve():
    # Importing islice to get a slice (subsequence) from an iterator, and tee to create independent iterators from one iterable
    from itertools import islice, tee

    # Read two integers from a single line of input, separated by spaces.
    # The first integer, k, will be used likely as the period or length of a certain array or sequence.
    # The second integer, q, represents the number of queries or test cases we will process.
    k, q = map(int, input().split())

    # Read k space-separated integers from the next line of input and unpack them into a list 'd'.
    # The asterisk '*' causes the 'map' results to be unpacked into the list.
    *d, = map(int, input().split())

    # The next lines will handle multiple queries (q times).
    # For each query, we will effectively "clone" the list 'd' using itertools.tee to prevent iterator exhaustion,
    # because map() is lazy and 'd' could be reused for multiple iterations in each query.
    for g in tee(d, q):
        # For each query, read three integers from the input:
        # n: the length or number of iterations/steps of a process (including the starting one)
        # x: the starting value
        # m: a modulus value controlling some modulo operation
        n, x, m = map(int, input().split())

        # For the whole sequence 'g', apply 'lambda x: x % m' to effectively wrap every element with mod m.
        # This means every element of g is replaced by its remainder when divided by m.
        g = map(lambda x: x % m, g)

        # Because map objects (iterators) can only be passed over once, use 'tee' to create three independent iterators.
        # g1: for summing the full period
        # g2: for summing the leftover part after full periods
        # g3: for checking which offsets are zero modulo m, to count something special later
        g1, g2, g3 = tee(g, 3)

        # Calculate rep and rest:
        # rep: the number of full cycles of k elements we will go through as steps (n - 1) // k
        # rest: the number of leftover elements (steps) after these full cycles (n - 1) % k
        rep, rest = divmod(n - 1, k)

        # Calculate the last value reached after (n-1) increments by elements of g:
        # - Initially, start at value x.
        # - Add (sum of one 'k' cycle) * number of full cycles 'rep'
        # - Add the sum of the (possibly incomplete) partial cycle (the first 'rest' elements)
        last = x + (sum(g1) * rep) + sum(islice(g2, 0, rest))

        # Now, count:
        # eq is the number of times when an element in g (the sequence) is 0,
        # for both fully repeated sections and the possible leftovers.
        # For each index in 0..(k-1):
        #   - For each complete cycle, that position is included 'rep' times.
        #   - If index < rest, the position comes up one extra time in leftovers.
        # For all such times, count how many of them have a g value of zero.
        eq = sum(
            rep + (1 if i < rest else 0)  # Number of appearances of g3[i]
            for i, gg in enumerate(g3)    # For each element and its index
            if gg == 0                    # But only if g3[i] (the value % m) is zero
        )

        # The answer is calculated as follows:
        # (n - 1): total increments performed (we consider steps from 0 to n-1)
        # - eq: subtract the number of zeros encountered, as those don't change anything after mod
        # - (last // m - x // m): for the starting value x and end value last,
        #     counting by how many multiples of m were passed over the total process
        # The resulting formula is the answer for the current query.
        ans = (n - 1) - eq - (last // m - x // m)

        # yield allows this function to be a generator: we can iterate over its results without storing all at once
        yield ans

def main():
    # For all answers generated by solve(), print them, separating each answer with a newline.
    print(*solve(), sep='\n')

if __name__ == '__main__':
    # Only run main() if the script is being run directly, not imported as a module
    main()