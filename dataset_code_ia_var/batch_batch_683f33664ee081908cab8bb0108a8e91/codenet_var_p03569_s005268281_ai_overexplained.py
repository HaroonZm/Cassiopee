def codefes17qc_c():
    # この関数は、与えられた文字列を適切に加工して、
    # どれだけ'x'を挿入すれば回文になるかを計算する。
    # 入力がすでに'x'以外で回文にできない場合は -1 を出力する

    # 入力値の取得。
    # input() 関数で標準入力から1行読み込む（データ型はstr）
    # str()は不要だが、明示的に文字列化している
    s = str(input())

    # 'x'以外を抽出して、元の単語から'x'をすべて削除した文字列 'nox' を作成する
    # 例: s = "xabax" → nox = "aba"
    nox = s.replace('x', '')  # .replaceは全ての'x'を''(空文字)に変換する

    # noxを反転（逆順）した文字列 noxrev を作成
    # Pythonのスライス [::-1] を使うと逆順になる
    noxrev = nox[::-1]

    # nox（'x'を除いたもの）が回文でない場合、どう頑張っても回文にできないため-1を出力して終了する
    if nox != noxrev:
        # 回文でなければ-1を出力し、関数を終了させる（return）
        print(-1)
        return

    # ここから実際に必要な'x'の数を数える処理に入る

    # srevは元のsを反転させた文字列
    srev = s[::-1]

    # 挿入した'x'の数を管理するための変数
    ins = 0

    # iは元の文字列sの現在のインデックス、jはsrev（反転文字列）のインデックス
    i, j = 0, 0

    # 2つのインデックスを使って先頭から比較する
    # ループ条件: どちらかのインデックスが末尾に到達したら終了
    while i < len(s) and j < len(s):
        # s[i] == srev[j] ならそのまま次へ進む
        if s[i] == srev[j]:
            # どちらのインデックスも1つ進める
            i += 1
            j += 1
        else:
            # どちらかにだけ'x'が現れた場合、それを挿入したとみなして数を増やす
            # まず、s[i]が'x'でなく、srev[j]が'x'なら
            if s[i] != 'x' and srev[j] == 'x':
                # xを挿入したとカウントし、jを1進める
                ins += 1
                j += 1
            # 次に、s[i]が'x'で、srev[j]は'x'でない場合
            if s[i] == 'x' and srev[j] != 'x':
                # xを挿入したとカウントし、iを1進める
                ins += 1
                i += 1

    # ループが終わってもどちらかが残っている場合（補助的にxだけが残るケース）、
    # そのぶんも挿入回数に加算する
    ins += len(s) - min(i, j)  # iとjのうち小さい方まで到達しているので、残りの回数だけ足す

    # ここまでで x を2倍カウントしているので最終的な答えは半分
    ans = ins // 2  # //は整数除算。小数点以下切り捨て。

    # 答えを出力
    print(ans)

# 関数をそのまま実行する（ユーザー入力を受け付けて答えを返す）
codefes17qc_c()