import itertools  # itertoolsはイテレータの生成に関する便利な標準ライブラリです。今回は使われていませんが、省略せず記載します。
import math  # mathモジュールは数学的な関数を提供します。ここでは小数点切り上げ(ceil)を行うために使います。

# ユーザーからの入力を1行取得し、空白で区切ってリストとして分割します。例: "3 4 5\n" → ["3","4","5"]
# map関数で各要素をint型に変換し、その結果をリストにします。つまり、N, A, Bは整数のリスト[3,4,5]のように格納されます。
N, A, B = list(map(int, input().split(" ")))

# hsはN個の要素からなるリストです。for _ in range(N)によりN回繰り返しが行われます。
# 各繰り返しで、input()によりユーザーから1行ずつ整数を受け取り、intで数値型に変換して格納します。
hs = [int(input()) for _ in range(N)]

# 二分探索を行うための初期値の設定
OK = 10 ** 10   # 魔法を非常に多く使った場合、この値以上ならバグらない範囲で十分大きい数に設定しています。
NG = 0          # 魔法を全く使わない状態の回数を初期値としています。

# OKとNGの間に1以上の差があれば、まだ探索範囲があるため、whileループを継続します。
while OK - NG > 1:
    # OKとNGの中間の値を現在の仮の答え(target)として二分探索します。
    target = (OK + NG) // 2  # //は整数除算。小数点以下を切り捨てることで整数値を求めます。

    s = 0  # この変数では、各敵に対して必要なA魔法の合計回数を計算します。毎回0にリセットします。

    # 各敵のHPについて繰り返します。hsは敵の体力値リストです。
    for h in hs:
        # それぞれの敵について、target回だけBダメージを全体に与えた場合、残りHPをA魔法で倒す必要がある回数を求めます。
        # 残りHPは h - target * B です。これを(A-B)ずつ削っていく必要があるので、(A-B)で割っています。
        temp = (h - target * B) / (A - B)
        # ダメージは整数回分しか与えられないので、tempが小数の場合は切り上げて必要回数にします。
        # 例えばtemp=1.2のとき、1回では倒せないので2回必要です。
        temp = math.ceil(temp)
        # 最小値は0回です。まだtarget回で十分倒している時はtempが負になる可能性があるので、maxで0を使って0未満にはなりません。
        # sにtemp(その敵に必要なA魔法の追加回数)を加算します。
        s += max(temp, 0)

    # 合計s回のA魔法が必要だった場合、target回で足りるかを判定します。
    if target >= s:
        # target回で全ての敵を倒せる場合は、「答えとしてtarget回は十分」なので
        # 今回のtargetをOK（十分に倒せる）側に割り当て、探索範囲を狭くします
        OK = target
    else:
        # target回では倒せない場合は、target回は答えにならないので
        # NG（まだ不十分）側に割り当て、探索範囲を狭くします
        NG = target

# ループが終了した時、OKは条件を満たす最小回数になっています
print(OK)  # 最小値を出力します