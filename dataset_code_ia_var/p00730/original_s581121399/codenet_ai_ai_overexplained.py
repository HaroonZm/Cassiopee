# 入力からN,W,Dの値を受け取る
# N: 切る回数
# W: 全体の幅（横の長さ）
# D: 全体の高さ（縦の長さ）
N, W, D = map(int, input().split())

# Wが0でない限り（すなわち、終端入力に到達していない限り）ループを繰り返す
while W:
    # すべての長方形の情報を格納するリストcpを初期化する
    # それぞれの要素は4つの整数を持つリスト：[始点x座標, 始点y座標, 横の長さ, 縦の長さ]
    # 2*N+1個の長方形を最大で管理可能 ※切るたびに1つ増えるため
    cp = [[0, 0, 0, 0] for _ in range(2 * N + 1)]  # 全部を0で初期化

    # 最初の1枚，全体を表す長方形をセット。左上が(0,0)で、サイズは幅W、高さD
    cp[0] = [0, 0, W, D]

    # N回にわたり領域を2分割していく
    for time in range(N):
        # 次の操作に関する入力。どの長方形を、どこで切るか
        # P: 今回切る長方形（リストcpの何番目か、1-indexed）
        # S: 切断する箇所（長方形の外周に沿って回した長さで指定、0が左上角）
        P, S = map(int, input().split())
        P -= 1  # リストは0-indexedなので、合わせる

        # P番目の長方形の情報を取り出す
        ta = cp[P]

        # 切る位置Sを、外周の長さで割った余りをSとする。
        # つまり始点から見て、外周を一周回るので循環する。
        S %= (ta[2] + ta[3]) * 2  # ta[2]:横長さ, ta[3]:縦長さ

        # どの辺で切るかを判定
        # 切る辺や位置によって二つに分割される長方形が変わる
        # 切った後、それぞれの始点座標と長さを手計算で求めている

        # 上辺（長方形の上側の辺）で切る場合
        if 0 <= S < ta[2]:  # Sが横幅以内→上辺
            if S < ta[2] / 2:
                # 切った左側（短い方）を先に格納
                cp[time + 1] = [ta[0], ta[1], S, ta[3]]
                # 切った右側（残り）を次に格納
                cp[time + 2] = [ta[0] + S, ta[1], ta[2] - S, ta[3]]
            else:
                # 逆順に格納
                cp[time + 1] = [ta[0] + S, ta[1], ta[2] - S, ta[3]]
                cp[time + 2] = [ta[0], ta[1], S, ta[3]]

        # 右辺（長方形の右側の辺）で切る場合
        elif S < ta[2] + ta[3]:  # Sが横幅+高さ以内→右辺
            S -= ta[2]  # 右辺での切断位置（この辺に来るまでに横幅ぶん進んだ）
            if S < ta[3] / 2:
                # 上側
                cp[time + 1] = [ta[0], ta[1], ta[2], S]
                cp[time + 2] = [ta[0], ta[1] + S, ta[2], ta[3] - S]
            else:
                # 下側
                cp[time + 1] = [ta[0], ta[1] + S, ta[2], ta[3] - S]
                cp[time + 2] = [ta[0], ta[1], ta[2], S]

        # 下辺（長方形の下側の辺）で切る場合
        elif S < ta[2] * 2 + ta[3]:  # Sが横幅*2+高さ以内→下辺
            S = ta[2] - (S - ta[2] - ta[3])  # 下辺で左から右へ進む。反時計回りなので減らす
            if S < ta[2] / 2:
                cp[time + 1] = [ta[0], ta[1], S, ta[3]]
                cp[time + 2] = [ta[0] + S, ta[1], ta[2] - S, ta[3]]
            else:
                cp[time + 1] = [ta[0] + S, ta[1], ta[2] - S, ta[3]]
                cp[time + 2] = [ta[0], ta[1], S, ta[3]]

        # 左辺（長方形の左側の辺）で切る場合
        else:
            S = ta[3] - (S - ta[2] * 2 - ta[3])  # 左辺で下から上へ進む。反時計回りなので減らす
            if S < ta[3] / 2:
                cp[time + 1] = [ta[0], ta[1], ta[2], S]
                cp[time + 2] = [ta[0], ta[1] + S, ta[2], ta[3] - S]
            else:
                cp[time + 1] = [ta[0], ta[1] + S, ta[2], ta[3] - S]
                cp[time + 2] = [ta[0], ta[1], ta[2], S]

        # 切った元の長方形（インデックスP）をリストから削除
        del cp[P]

    # 全ての切断操作が終わったあとの長方形群の面積計算
    # cpに残っている全ての長方形について面積を計算し、ansliというリストに格納
    ansli = []
    for el in cp:
        # 長方形の面積は「横の長さ*縦の長さ」
        ansli.append(el[2] * el[3])

    # 面積を昇順ソート
    ansli.sort()

    # 全ての面積を空白区切りで1行出力
    print(*ansli)

    # 次の入力セット（N, W, D）を受け取る
    N, W, D = map(int, input().split())  # W=0の入力が来たらwhileが終了してプログラムも終了