#=============================================================================
# サイクル検出 AOJ2891の解答例（日本語コメントを詳細化したもの）
#=============================================================================

# 標準ライブラリの queue モジュールをインポートします。
# queue モジュールは FIFO, LIFO などのキュー構造を提供します。
import queue

# 標準入力から整数 N を読み込みます。
# int(input()) により、ユーザから入力された値（文字列）を整数型に変換します。
N = int(input())

# グラフ構造（隣接リスト）を初期化します。
# [[ ] for _ in range(N)] で、N 頂点のそれぞれに空リストを割り当てます。
# Graph[i] は頂点 i（0-index）の隣接頂点リストを持ちます。
Graph = [[] for _ in range(N)]

# 各頂点の次数（辺の接続数）を管理するリストを初期化します。
# 最初は全ての頂点の次数は 0 です。
deg = [0 for _ in range(N)]

# queue.Queue() で FIFO キューを作成します。
# 木を切り取るときに葉となる頂点（次数が 1 の頂点）を格納します。
que = queue.Queue()

# 各頂点がサイクル内にあるかどうかを表すリストを初期化します。
# 最初は全て True（サイクル内にいる可能性あり）と仮定します。
circle = [True for _ in range(N)]

# N 回ループして、各辺の情報を入力として受け取ります（無向グラフ）。
for _ in range(N):
    # 2 つの整数 a, b を１行の入力から読み取ります（空白区切り）。
    # map 関数はイテレータを返すので、tuple または unpacking で値を取得します。
    a, b = map(int, input().split())
    
    # 問題文は頂点番号が 1 始まりなので、Python の 0 始まりに合わせて -1 します。
    a -= 1
    b -= 1
    
    # 頂点 a の隣接リストに b を、頂点 b に a を追加します（無向グラフなので双方向）。
    Graph[a].append(b)
    Graph[b].append(a)
    
    # 頂点 a, b の次数も 1 ずつ増やします。
    deg[a] += 1
    deg[b] += 1

# すべての頂点について次数が 1 であれば葉と見なして、キューへ追加します。
# また、そのような頂点をサイクルに含まれないものとして False にします。
for v in range(N):
    # 頂点 v の次数が 1 であれば葉ノードです。
    if deg[v] == 1:
        # キューに v を追加します。
        que.put(v)
        # 葉は必ずサイクルに含まれません。
        circle[v] = False

# キューを使って葉の除去を繰り返すことで、連結成分から木部分を引き剥がします。
# これにより最終的にサイクル部分のみが残ることになります。
while not que.empty():
    # キューから次の頂点 v を取り出します（幅優先探索の要領）。
    v = que.get()
    # 頂点 v に隣接する各ノードに対し操作します。
    for nv in Graph[v]:
        # v を除去することで隣接ノードの次数を 1 つ減らします。
        deg[nv] -= 1
        # 減らした結果、隣接ノードの次数が 1 になれば、それもまた葉になったとみなします。
        if deg[nv] == 1:
            # その頂点 nv を新たな葉としてキューに追加します。
            que.put(nv)
            # その頂点はもはやサイクルに含まれません。
            circle[nv] = False

# クエリ数 Q を入力から取得します。
Q = int(input())

# Q 回のクエリを処理します。
for _ in range(Q):
    # 各クエリで 2 つの整数 a, b を読み込みます。
    a, b = map(int, input().split())
    # 頂点 a, b がともにサイクル内部（cut で残ったまま）かどうか判定します。
    # （circle 配列は 0-index なので a-1, b-1 とします）
    if circle[a - 1] and circle[b - 1]:
        # 両方ともサイクル内部ならば 2 を出力します。
        print(2)
    else:
        # そうでなければ 1 を出力します。
        print(1)