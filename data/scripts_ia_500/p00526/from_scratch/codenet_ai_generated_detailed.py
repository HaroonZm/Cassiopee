import sys

def main():
    input = sys.stdin.readline
    N = int(input())
    bulbs = list(map(int, input().split()))

    # 交互列の判定基準：
    # 隣接する電球の状態が交互ならば異なる値であること。
    # 交互列の長さを求めるには、隣接が同じでない区間の長さを求めれば良い。

    # 何も操作しない場合の最大交互列長さを求める関数
    def max_alternating_length(arr):
        max_len = 1
        current_len = 1
        for i in range(1, len(arr)):
            if arr[i] != arr[i-1]:
                current_len += 1
                max_len = max(max_len, current_len)
            else:
                current_len = 1
        return max_len

    # 電球の状態を0か1としている。
    # 機械の操作は1回のみ、指定した区間[L, R]内の電球の状態を反転(0->1, 1->0)する。
    # 操作後に最長の交互列を作る。

    # 操作しない場合の最大交互列も候補なのでまず求める
    answer = max_alternating_length(bulbs)

    # 操作は区間反転 => 指定区間を反転すると、その区間の電球状態はすべて反転する
    # 最も効率よく最大交互列を伸ばすことができる区間を探す必要がある。

    # 考え方：
    # 「操作後に長い交互列ができる」ということは、
    # 操作した区間の反転によって連続して壊れていた交互並びが繋がる、または
    # 操作した区間の先端や後端の接合部で交互列が伸びる可能性がある。
    #
    # 交互な電球列は隣り合う電球が異なることなので、
    # * 交互列区間を分割し、その区間端で機械を使うことで隣接区間と繋ぐことを考える
    #
    # 実際は複雑だが、大きなポイントは
    # 機械は区間反転1回のみなので、それ以外は元のまま。
    # → 交互な状態の変わる場所(隣接電球が同じ)の連続区間がボトルネック。

    # アプローチ：
    # 入力を元に「隣接の違い」を示す配列を作る：
    # diff[i] = (bulbs[i] != bulbs[i-1])
    # diffは長さN-1の配列で、Trueなら隣同士が異なり交互列を続けることができる、
    # Falseならそこから交互列は切れる。
    #
    # また反転するとその区間のbulbsは反転し、その結果diffの値もその区間間で反転する影響を受ける。
    #
    # diffの扱いは複雑なので、もう少し直接的な方法を考える。

    # より簡潔にするために、電球の状態の座標圧縮的な概念ではなく、
    # 操作後の状態で交互列を伸ばす問題とする。

    # それぞれの位置iについて、「機械を区間の一部に含めて状態を反転させたときの
    # 交互列の伸ばし方」を考えるのは計算量的に困難。

    # そこで以下のアイデア：
    # 機械を使わない場合の最大交互列長answerがある。
    # 使う場合は1回の区間反転でしかもその区間は連続している。
    #
    # 電球列において、交互列が途切れる箇所の直前と直後の電球を反転することで、
    # 交互列をつなげてより長い交互列とする事を目指す。

    # したがって、交互でない位置（隣接が同じ）に注目し、その区間を反転することで
    # その地点の交互特性を逆転させ、連続する交互列をつなげることが可能。

    # 具体的には：
    # まず交互列区間の開始・終了位置を求めて、
    # 交互列区間は隣接が常に異なる連続区間である。
    # その区間間の切れ目は隣接電球が同じである境界。
    # 反転機械をその境界周辺にかけると交互列が伸びる可能性が高い。

    # 詳細な手順：
    # 1) 交互列の区間を列挙
    # 2) 各区間の番号iについて、区間iと区間i+1の境界を考え
    #    境界の前後の電球を含む最小区間を反転して両交互列区間を繋げられるか検討する
    #
    # 3) 機械を使う区間は1回だけ使えるので、どの境界のどの範囲に使うかを
    #    すべての交互区間の境界間で試すのは O(N) 程度可能。

    # まず交互列区間の開始終了を抽出
    intervals = []
    start = 0
    for i in range(1, N):
        if bulbs[i] == bulbs[i-1]:
            # ここで交互状態が途切れるので区間を作る
            intervals.append((start, i-1))
            start = i
    intervals.append((start, N-1))

    # intervalsは交互列区間の[start, end]のリスト
    # 各区間は1つ以上の長さがある（少なくとも1）

    # 機械を使わない場合の最大交互列長はすでに answer に入っているが、
    # intervalsの中には最大区間もあるはず。

    # 境界で繋げる可能性があるのは隣接するintervalsの境界、
    # すなわち interval[i] の終端 +1 == interval[i+1] の始端 という関係。

    # これら境界の電球を反転することで接続できる交互列の長さを計算する

    # 交互列区間を繋げる最小区間は
    # interval[i].end .. interval[i+1].start の範囲
    # ただし、その境界の電球の反転だけでは変わらず、
    # 境界部分の電球を含めた反転区間の設定により交互列が繋がるか判定しないといけない。

    # そこで各区間の長さと境界電球の状況を利用して考える。

    # 交互列区間同士は以下の条件を満たす
    # intervals[i]の最後電球 bulbs[intervals[i][1]]
    # intervals[i+1]の最初電球 bulbs[intervals[i+1][0]]
    # これらが等しいので次の区間につながらない。

    # 機械を使うことでこの範囲を反転し、反転の効果で両区間が交互につなげることが可能かを考える。

    # 交互列の性質上、
    # 操作区間は連続なので反転区間は1区間である。
    # その区間をendpoint付近に取ると隣り合う区間をつなげやすい。

    # 1) 反転区間を境界の電球だけにする
    # 2) 反転区間を境界の左右数個含める広い区間にする

    # より簡単にするためには、
    # 各電球に対し「機械で反転するかしないか」の状態で得られる交互性を
    # かつ区間反転は1回のみ使えることから、
    # 区間反転した影響を交互列の評価に反映する必要がある。

    # ここからはよりアルゴリズム的な手法にする。
    #
    # 以下の参考解法は
    # 「反転区間を1回だけ使う」
    # という条件を満たす中で
    # 「左右に伸びる可能性の最大の交互列を求める」
    #
    # 解法アイデア：
    # 配列に対して「交互列の長さ」を前から、後ろからそれぞれ計算し、
    # 前から見た交互列の長さ配列 l[i]　(電球 i を終端としたときの最大長)
    # 後ろから見た交互列の長さ配列 r[i]　(電球 i を始端としたときの最大長)
    #
    # 反転区間 [L, R] を指定したとき、
    # 反転によって電球の0/1が入れ替わる。
    #
    # 理想的には「反転区間の中身を交互列としてみなす」かつ
    # 「反転区間の左右端を既存交互列と継ぎ目を考えて繋げる」こと。

    # しかし、反転すると隣接の異同の判定が変わるので、計算が難しい。

    # そこで以下の手法を使う：

    # 1) 反転区間を空（機械不使用）を含めすべての区間に対し検討（全部で O(N^2)は不可）

    # 2) 反転区間は機械1度だけ使用かつ1区間なので、
    # 部分反転が隣接の異同を改善できる場所のみ試す必要がある。

    # 3) 解法として以下のトップダウン効果的な方法を示す:

    # 【実装】
    # 反転区間は1回のみだから、
    # 配列に対して「左右からの交互列長さ」を計算し、
    # その上で各 i から j の区間を反転したときの影響を考える。

    # 計算量の問題から全区間は無理だが、
    # 光らないと推測される区間は反転区間と競合し、動きが確認できる区間として、隣接電球が同じ箇所で試す。

    # そこで今作成する回答では以下の実装をする：

    # 交互列長さを左右から計算して、
    # 境界部分で試せる反転区間の効果を左右からの長さと組み合わせて取得する。

    # 各電球位置iについて、
    # 左右の交互列長さを計算する。

    l = [1]*N  # l[i]: bulbs[0..i]でi終端の最大交互列長
    for i in range(1, N):
        if bulbs[i] != bulbs[i-1]:
            l[i] = l[i-1] + 1
        else:
            l[i] = 1

    r = [1]*N  # r[i]: bulbs[i..N-1]でi始端の最大交互列長
    for i in range(N-2, -1, -1):
        if bulbs[i] != bulbs[i+1]:
            r[i] = r[i+1] + 1
        else:
            r[i] = 1
            
    # 機械で区間反転1回のみ = 区間の電球を全反転(0<->1)
    # この影響を隣接交互条件に反映するのは難しいが、
    # 交互列区間の切れ目付近を操作すると繋げる可能性がある。

    # 反転区間を1つだけとして、交互列の間の境界で試みる。

    # 境界は bulbs[i] == bulbs[i+1] の箇所
    # 該当境界付近で反転区間を左右に伸ばし、
    # l[i] (iまでの交互列長) と r[i+1] (i+1からの交互列長)を繋ぐ試み

    # 一例として反転区間として境界の前後を含む区間を操作すれば、
    # その区間が全反転し、境界の電球が逆転することになるので繋げる可能性がある。

    # 境界iから、L,R区間として安全に範囲を広げるには限界があるが、
    # この問題では境界から1つずつずらして（i,j）を）考えると高コストになる。

    # そこでこの問題の模範解法としてよく知られている手法を実装：

    # 「左右からの最大交互列長を利用し、更に機械を使って区間を反転した時に伸ばせる交互列長を、
    # 両端区間の隙間を区間反転で繋ぐように想定して、拡張する」というもの。

    # 以下コードで処理：

    # 境界位置を探す
    max_len = answer  # 機械不使用も含む最大値

    # 境界とは bulbs[i] == bulbs[i+1]
    boundaries = []
    for i in range(N-1):
        if bulbs[i] == bulbs[i+1]:
            boundaries.append(i)

    # 各境界について、区間反転を使ってそこを繋げたと仮定した最大交互列長を計算
    # 具体的には
    # 操作区間の左端は反転開始地点、右端は反転終了地点とし
    # 区間反転区間の左右の交互列長さ(l, r)を組み合わせる
    
    # 境界iでの最大は
    # (l[i]) + (r[i+1]) + 1
    # +1は、境界の電球自体を反転することで繋げるという直感的なための余分の長さとして入れてよい

    # ただし必ずしも+1して良いわけではないが例示のため

    for i in boundaries:
        # 機械がこの境界の両側を繋ぐと考えた場合の長さ
        # それに加えて、機械を使った区間の長さも考慮すると、最大長は最大でもNなので制限は不要
        candidate = l[i] + r[i+1]
        if candidate > max_len:
            max_len = candidate

    # さらに境界でなくても、反転区間を使って交互列を伸ばすことがあるため

    # 交互列の区間リストintervalsと境界indexの活用もあるが、
    # 詳細な範囲探索や部分反転の検討は計算量が重くなるため今回は割愛

    # 最後にmax_lenを出力
    print(max_len)

if __name__ == "__main__":
    main()