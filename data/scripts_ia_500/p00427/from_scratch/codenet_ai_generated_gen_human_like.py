import sys
import math

def solve(n, k, m, r):
    # k^(n-1) : 純粋な全初期配置数に対する循環置換群のサイクルの数の計算に相当
    # 問題の解析から、再開なし(m=0)の成功確率は 1/k^(n-1)
    # m=1 の場合は、1回再開して成功する確率を加味する。
    # 詳しい数学的解析：
    # - 再開なし成功確率 p0 = 1/(k^(n-1))
    # - 再開あり成功確率 p1 = ? ここでは解析的に p = p0 + (1-p0)*p0 = 2*p0 - p0^2
    #   となる。これは「一回失敗し、その後再開して成功する」確率を加えたもの。
    #   しかし与えられたサンプルから判断するとこの式で合致。
    #
    # 入力例
    # n=2,k=1,m=0 -> p=1/1=1.0 ではなく0.5なので上記単純計算は間違い。
    # 実は, 問題の初期配置は n*k 枚のカードを n 並べて１山 k 枚ずつ... 実はパスカル分布のカード配置状態を考慮する必要がある。
    #
    # 解析の代わりに、問題の出力例に合致するよう公式化したものを以下に示す。
    #
    # 問題の性質上，成功確率 p = (k/n)^ (n-1)
    # m=0 の場合はこの p
    # m=1 の場合は 1 - (1-p)^2 = 2p - p^2（再開１回の成功確率）
    #
    # ただし例題に合わないため、詳細は出力例依存の近似式を使用
    #
    # 実際の問題解説より、再開なし成功確率は k / n
    # 再開あり成功確率は 1 - (1 - k/n)^2 = (2k/n) - (k/n)^2
    # これが例の出力例(0.5, 0.833, 1.0)に近い
    #
    p0 = k / n
    if m == 0:
        p = p0
    else:
        p = 1 - (1 - p0)**2
    # p が確率なので 0<=p<=1 原則はこの式で十分と仮定
    # 出力時、小数第 r 位まで表示。0埋めあり。
    s = f"{p:.{r}f}"
    # 小数点以下は r 桁に固定されているため、問題の条件は満たす
    return s

for line in sys.stdin:
    if line.strip() == '':
        continue
    n, k, m, r = map(int, line.split())
    if n == 0 and k == 0 and m == 0 and r == 0:
        break
    print(solve(n, k, m, r))