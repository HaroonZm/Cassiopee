# 入力された時間を「時分」の形式から「分」のみに変換する関数を定義します。
# 例えば、入力が1234なら12時34分を意味し、これを分に直します。
def convert_time(n):
    # n/100は整数の時間部分（例: 1234/100 = 12）を取得します。
    # それに60を掛けることで時間を分に変換します（12時間 * 60分 = 720分）。
    # n%100は分の部分（例: 1234 % 100 = 34分）です。
    # これらを足すことで、合計何分かを計算しています。
    return (n/100)*60 + n%100

# ２つのコマーシャル時間リストの共通部分（重なっている時間帯）を抽出する関数です。
def kyotsu(cm1, cm2):
    # 共通部分を格納する空のリストを用意します。
    result = []
    # cm2 は時間帯（開始・終了）がペアで入っているので、半分の回数だけループします。
    for i in range(len(cm2)//2):
        # cm2 の i 番目のコマーシャルの開始時刻と終了時刻を取得します。
        st2 = cm2[i*2]
        ed2 = cm2[i*2+1]
        # cm1 も同様にループして、それぞれのコマーシャルの開始終了時刻を取得します。
        for j in range(len(cm1)//2):
            st1 = cm1[j*2]
            ed1 = cm1[j*2+1]
            # 重なっている部分を計算するために、開始時刻はより遅いほう（max）、終了時刻はより早いほう（min）を取得します。
            stt = max(st2, st1)
            edt = min(ed2, ed1)
            # 重なりが存在する条件は終了時刻 - 開始時刻 > 0 です。
            if edt - stt > 0:
                # 重なっている時間帯の開始と終了を結果に追加します。
                result.append(stt)
                result.append(edt)
    # 重なり部分のコマーシャル時間リストを返します。
    return result

# メイン処理部。ユーザーからの入力を受け取り続けます。
while 1:
    # 一行の入力を受け取り、空白で分割して整数に変換しリスト化します。
    cond = [int(r) for r in raw_input().split()]
    # もし３つの入力すべてが0ならプログラムを終了します。
    if cond[0]==cond[1]==cond[2]==0:
        break

    # コマーシャルが考慮される時間の開始と終了を分単位に変換します。
    start = convert_time(cond[1])
    end = convert_time(cond[2])

    # 複数チャンネルのコマーシャル時間を管理するリストを用意します。
    cms = []
    # cond[0]はチャンネル数です。各チャンネルについてコマーシャル時間を処理します。
    for i in range(cond[0]):
        # 各チャンネルのコマーシャル数を整数で取得します。
        n = int(raw_input())
        # コマーシャルの開始終了時刻のリストを取得し、convert_time関数で分単位に変換してリスト化します。
        input = [convert_time(int(r)) for r in raw_input().split()]
        j = 0
        # 一時的にチャンネルのコマーシャル時刻を保存するリストを用意します。
        cmstmp = []
        # コマーシャル数分ループします。
        while j < n:
            # 開始時刻は偶数インデックスで終了時刻は奇数インデックスです。
            st = input[2*j]
            ed = input[2*j+1]
            # 最初のチャンネルの場合はcmsに直接追加します。
            if not i:
                cms.append(st)
                cms.append(ed)
            else:
                # 2チャンネル目以降は一旦cmstmpに追加します。
                cmstmp.append(st)
                cmstmp.append(ed)
            j += 1
        # 2チャンネル目以降は、既存のcmsとの共通部分（重なっているコマーシャル時間）を求めて更新します。
        if i > 0:
            cms = kyotsu(cms, cmstmp)

    # コマーシャルがある時間帯の開始と終了を含めるため、開始時間と終了時間をリストの最初と最後に追加します。
    cms = [start] + cms + [end]
    # コマーシャルの合間のテレビを見られる最大の連続時間を計算します。
    # cmsリストは開始と終了時間のペアが複数入っているため、ペアごとに差分を計算します。
    max_duration = max([cms[i*2+1]-cms[i*2] for i in range(len(cms)//2)])
    # 最大の視聴可能時間を出力します。
    print max_duration