import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

# 問題概要：
# N本の木が一列に並び、それぞれにイルミネーションの美しさA_iがある。
# M個の区間[L_j, R_j]があり、それら区間の中で2つ以上の木にイルミネーションをつけてはいけない。
# 条件を満たしつつ、美しさの合計の最大値を求める。

# 考え方：
# 各区間は「2つ以上のイルミネーション禁止」という独立した条件ではなく、複数区間が絡み合うため複雑。
# 各木の状態は選ぶか選ばないかの二択。
# 複数区間制約は、区間内の選んだ木の数 ≤ 1という制約。
# この問題は「区間の独立集合問題」のように見えるが、複雑なので別のアプローチが必要。

# 解法アプローチ：
# 1. 区間の重なり最大箇所を探す。複雑さを考え、貪欲法などは困難。
# 2. 区間条件は、区間内で複数選べない。つまり区間内の複数選択を防ぐ制約。
# 3. 最大の美しさの部分集合で、禁止区間で複数存在しないように。
# 4. 制約を満たしつつ、最大値を取る集合を考える。
# 
# 重要な発想：区間制約内の複数選択禁止というのは、区間をまたぐ木の選択同時出現を制限するという意味。
# 
# 解法提案：
# この問題は「最大独立集合」問題に帰着し、Nが最大2×10^5と大きく、一般的なDPは難しい。
#
# だが、区間の性質を活かすと、「区間をまたぐ木は最大1つ選べる」制約は、
# これらの区間を「辺」とするグラフに置き換えて頂点集合に制限がある形とみなせる。
#
# ここでは scanner と sweep line を用いた「最大重複数のチェック」をしつつ、
# 問題の制約を満たす集合を見つける。
#
# 具体的には：
# - 区間は、「該当区間内で2つ以上選択するのは不可」なので、その区間内の木が2つ以上選ばれるのはNG
# - つまり、選んだ木は、重複する区間内で1つだけ。
# - 各木に対して、どの区間に被るかを認識
# - 制約を「木が被る区間は独立になる制約として解釈」
#
# この問題の提示された解法は、**区間の終了位置R_jをキー**に、DPを行い区間制約と照合しながら解くこと。
#
# 実装ポイント：
# - 区間情報をR_jでグループ化する
# - dp[i]: 木1～iまで考えた時の最大美しさ合計
# - 木iを選ぶ時は、区間制約を守るため、その木にかかる区間の開始位置より前までdpで参照
# - 木iを選ばない時は、dp[i-1]
#
# 区間制約を木の選択に反映するため、各木iに影響する区間の左端をすべて調べ、
# そのなかで最大の左端（＝木iの選択可能な範囲の下限）を見つける。
#
# dp計算：
# dp[i] = max(dp[i-1], dp[left-1] + A_i)
# ただしleftは、木iが所属するすべての区間の開始位置の最大値
#
# また、M=0のときは単純にすべて選ぶDPと同じになる。
#
# 以上のアイデアで高速に計算可能。

N, M = map(int, input().split())
A = list(map(int, input().split()))

# 各木が属する区間の最大のL値を保存
# 木iにかかる区間の左端の最大値を計算するため、リストや最大値管理用配列を使う

max_L_for_tree = [1] * N  # 初期値は1（1-indexedなので）

# 区間を与えられたら、区間内部の木すべてのmax_L_for_treeを更新するとO(N*M)となり遅いので工夫要
# 区間の左端L_jは範囲の下限になる
# 区間[L_j, R_j]では木 i∈[L_j, R_j]に対してmax_L_for_tree[i] = max(..., L_j)

# 区間を区間カバーの形で管理し、差分配列で対応
diff = [0]*(N+2)  # 差分で区間の左端の最大を管理するのは難しいので別案を検討

# もう一つの方法として、木ごとに区間の中で最大のL_jを求めるために、
# 各区間の情報をまとめて、木番号ごとに最も左のL_jを記録するためセグメント木を検討もできるが実装困難

# そこで、木iにかかる区間の最大のL_jは、区間をR_jでソートし、そしてdp[i]の計算で
# 木iを選ぶときにiより前の木までしか区間の制約で選べないことを利用して、R_jでまとめて処理する別案を採用

intervals = [[] for _ in range(N+1)]  # R_j毎に区間Lを格納（1-indexed扱い）

for _ in range(M):
    L, R = map(int, input().split())
    intervals[R].append(L)

dp = [0]*(N+1)  # dp[i]: 木1～iまで考えたときの最大美しさ合計

maxL = 0  # 木iの最新の区間Lの最大値を記録。更新しながら、区間制約を満たす左端を見る。

for i in range(1, N+1):
    # i番目の木にかかる区間の左端最大値を調整
    for L in intervals[i]:
        if L > maxL:
            maxL = L
    # 木iを選ばない場合
    not_choose = dp[i-1]
    # 木iを選ぶ場合
    # 選ぶ場合は、区間制約のためmaxL-1までしか選べない（maxL以上の木は選べない区間の開始）
    choose = dp[maxL-1] + A[i-1]
    dp[i] = max(not_choose, choose)

print(dp[N])