# 超都観光 問題の解法
# 交差点は (X, Y) の格子状に並び，隣接交差点は南北東西だけでなく，斜め北東、斜め南西も道がある。
# 各移動は1本の道の使用に相当し、これらの移動のコストはすべて1。
# したがって、ある2点間の最短距離は「道の本数の最小値」である。
#
# 観光スポットを順番に訪れるために通る道の本数の合計の最小値は、
# 各隣接観光スポット間の「最短距離」の総和になる。
#
# このグリッドでの移動は、横、縦、斜め北東、斜め南西が可能だが、
# それは「チェビシェフ距離 (Chebyshev distance)」で最短距離が計算できる世界と同じ。
#
# 具体的に、ある2点 (x1, y1) と (x2, y2) 間の最短移動距離は、
# max(|x1 - x2|, |y1 - y2|) である。
#
# なぜなら、
# - 一度に斜め移動 (北東方向に1移動) をすれば、x座標もy座標も同時に±1される。
# - 斜め移動を最大限利用すると、x座標差とy座標差のうち小さい方をまとめて斜め移動で縮められ、
#   残りの差分は縦または横に移動で補う。
# - 合計で max(|x1 - x2|, |y1 - y2|) の移動本数になる。
#
# よって、
# N 個の観光スポットの順番で (X_i, Y_i) を訪れるとき、
# 総移動距離 = Σ_{i=1}^{N-1} max(|X_i - X_{i+1}|, |Y_i - Y_{i+1}|)
#
# 以下、入力を読み込んで上記計算を行い出力する。

import sys

def main():
    input = sys.stdin.readline
    W, H, N = map(int, input().split())
    spots = [tuple(map(int, input().split())) for _ in range(N)]

    total_distance = 0
    for i in range(N - 1):
        x1, y1 = spots[i]
        x2, y2 = spots[i + 1]
        dist = max(abs(x1 - x2), abs(y1 - y2))
        total_distance += dist

    print(total_distance)

if __name__ == "__main__":
    main()