import sys
sys.setrecursionlimit(10**7)

# 入力処理
W, H = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(H)]

# ゲームの状況を考える際、駒は格子点上にあり、東または南へ移動する。
# 領地は境界線の北東側（先攻：信夫くん）と南西側（後攻：静夫くん）に分かれる。

# DPの定義：
# dp[i][j] = ある位置(i,j)からゲーム終了まで双方が最適にプレイしたときの
# 先攻プレーヤー（信夫くん）の「差分スコア」（信夫くんスコア - 静夫くんスコア）の最大値
# この差分スコアは境界線を決める際に先攻プレーヤーが得られる有利さを示す。

# 駒は(0,0) からスタートし、(H,W) の格子点に到達する。
# 領地は境界線の両側のマス目に分かれ、北東側の領域（境界線の上または右側）は先攻
# 南西側（境界線の下または左側）は後攻 の領域となる。

# 差分スコアを計算するために、境界線が通るポイントの東か南に隣接する区画の重みを利用する。
# 境界線が点(i,j)から東に動くとき、その境界線は区画(i,j)の下側（つまり grid[i][j]）と左側とは反対側へ伸びるため、
# 東に動くときは境界線の北東側に隣接する区画は(gridの)行はi、列はjで、
# 南に動くときは行はi、列はj-1かj?

# 計算を簡潔に行うために、境界線が(i,j)から動くとき、その区画の値を差分に足すことを考える。
# 以下の論理を使う（文献などにある類題応用）：

# 先攻の差分スコア = (先攻の領地の和) - (後攻の領地の和)
# 境界線を決める動きによって、移動方向の差分値（境界に沿う区画の損得）を加減していく。

# 南か東に動く際の差分の変化を以下のように定義し、
# dp[i][j] = max(差分値に基づく残り手の差分結果)
# 交互に動くので、自分が動くなら最大化し、相手なら最小化する。

# ここでは、dp[i][j]は”現在の手番のプレイヤーが駒を(i,j)から動かすときの差分の最大値”とした。

# dpを後ろから計算する。

# W,H は区画数なので格子点は (H+1) x (W+1)

# 差分値：位置(i,j)から東に動く場合は、その位置の区画は grid[i][j]
# 位置(i,j)から南に動く場合は、その位置の左の区画の値 grid[i][j-1]

# エッジケースも考慮する。

dp = [[0]*(W+1) for _ in range(H+1)]

# dp の求め方：
# (H,W)はゴール地点なのでdp[H][W] = 0
# 東か南に動く手があれば、その手を選択して差分スコアを最大化（現在の最善手を選ぶ）。
# 交互に動くので交互に符号を変える工夫をする。
# 解説：
# 今いる位置をdpのインデックスとし、次に向かう区画のスコアを差分に含める。
# 先攻が動く時は最大化、
# 後攻が動く時は最小化。
# 手番は到達位置までの歩数の偶奇で判定 possible by (i+j) % 2

for i in range(H, -1, -1):
    for j in range(W, -1, -1):
        # ゴール地点は差分0
        if i == H and j == W:
            dp[i][j] = 0
            continue

        # 手番判定： (i+j) の偶奇で先攻(偶数)か後攻(奇数)か判定
        turn = (i + j) % 2
        candidates = []

        # 右に動ければ（東）
        if j < W:
            # 東に1歩動くと境界線が1区画動く
            # その区画は grid[i][j]（i,jは0basedで行(i),列(j)）
            score = grid[i][j]
            next_dp = dp[i][j+1]
            # 次の状態は相手の手番になるので反転
            candidates.append(score - next_dp)

        # 下に動ければ（南）
        if i < H:
            # 南に1歩動くと境界線が1区画動く
            # その区画は grid[i][j-1]ではなく grid[i][j-1]? → j そのままでいい
            # ただしjが0の時左の区画は無いので j==0のときは東しか動けないはず
            # 南に動くと境界線は左側の区画に隣接するため、正しくは grid[i][j-1]
            # jが0なら南にしか動けない（端）
            if j - 1 >= 0:
                score = grid[i][j-1]
            else:
                score = 0  # 左の区画が無いため得点は0として扱う
            next_dp = dp[i+1][j]
            candidates.append(score - next_dp)

        # 先攻の手番（turn == 0）は最大化、後攻の手番は最小化
        if turn == 0:
            dp[i][j] = max(candidates)
        else:
            dp[i][j] = min(candidates)

# dp[0][0] は差分スコア(信夫くん - 静夫くん)の最大値
# 問題は絶対値を出力
print(abs(dp[0][0]))