# AOJ 0519: Worst Reporter
# Python3 2018.6.20 bal4u

# トポロジーソート V:総ノード数, to[][]:隣接リスト
def topological_sort(V, to):
    # V はグラフのノード数（頂点数）を表します。
    # to は隣接リストとして、各頂点から出る辺の行き先のリストが格納されています。
    
    # cnt は各ノードに入ってくる辺の本数（入次数）を格納するリストです。
    # ここでは頂点の数だけの0のリストを作成し、後でカウントします。
    cnt = [0]*V
    
    # 次に、全てのノード i について、そのノードから出ている辺の終点 j に対して、
    # ノード j の入次数を1つ増やしています。
    for i in range(V):  # 0からV-1まで全ノードに対して
        for j in to[i]: # iから出る全ての辺の終点jに対して
            cnt[j] += 1  # jの入次数を1増やす

    # Q は「入次数が0のノード」を管理するためのキュー（リスト）です。
    Q = []
    
    # 全てのノードに対して、もし入次数が0であれば、Qに追加します。
    # 入次数0のノードは、先に処理できる順序の候補となります。
    for i in range(V):
        if cnt[i] == 0:
            Q.append(i)

    # f は、トポロジカルソート中に同時に複数の入次数0のノードが存在したかどうかを表すフラグです。
    # これは「複数の選択肢があるか」を判定するために使われます。
    f = 0
    
    # Qが空になるまで繰り返します。Qが空になるということは全てのノードを処理したことを意味します。
    while len(Q) > 0:
        # f |= len(Q) > 1 は、もし現在のQの長さが2以上なら（複数の候補あり）fをTrue（1）にします。
        # |= はビットOR代入演算子で、fが一度1になるとずっと1です。
        f |= len(Q) > 1

        # 現在のQの先頭（0番目）のノードiを取り出します。
        i = Q[0]
        # 取り出したノードはQから削除します。
        del Q[0]
        
        # ノードの番号は0始まりですが、問題の出力は1始まりであるため、1を足して表示します。
        # ここでi+1をprintすることで、解答や経路などを表示しています。
        print(i+1)  # ノードの表示
        
        # 現在処理しているノードiから出る全てのノードkに対して、仮にiを取り除いた後の
        # 入次数を計算します。つまり、kに入る辺の数を減らします。
        for k in to[i]:
            cnt[k] -= 1  # 入次数を1減らす
            # もし、そのノードkの入次数が0になったら、それは次に処理すべきノード候補なのでQに追加します。
            if cnt[k] == 0:
                Q.append(k)
    
    # 最後にfを返します。これは1なら、トポロジカルソートの途中で複数選択肢があった（注意が必要）ことを示し、
    # 0なら一意な順序でソートできたことを示します。
    return f    

# 以下は入力部分の処理です

# n はノードの数。input()で文字列として受け取り、int変換して整数にしています。
n = int(input())

# to は隣接リストを示す空のリストをn個分用意しています。
# [[] for i in range(n)] で、n個分の空リストを作成。to[i] が空リストの状態でスタート。
to = [[] for i in range(n)]

# m は辺の数。これもinput()で受け取り整数に変換。
m = int(input())

# 次にm回繰り返して、a,bの2つの整数を標準入力から読み込みます。
# それぞれの辺はaからbへの有向辺を意味します。
for i in range(m):
    a, b = list(map(int, input().split()))
    # 入力は1始まりで与えられているので、内部処理は0始まりに合わせるために-1しています。
    # to[a-1]にb-1を追加することで、ノードa-1からノードb-1へ辺があることを示しています。
    to[a-1].append(b-1)

# topological_sort関数を呼び出し、n個のノードと隣接リストtoを渡します。
# 返り値がTrue（1）の場合は1を、False（0）の場合は0を出力するようにしています。
print(1 if topological_sort(n, to) else 0)