En te basant sur cet énoncé, réécris le code suivant tout en conservant exactement sa fonctionnalité.

```python
while 1:
    N = int(input())
    if not N:
        break
    S = []
    for i in range(N):
        h, r = map(int, input().split())
        S.append((h, r))
    M = int(input())
    for i in range(M):
        h, r = map(int, input().split())
        S.append((h, r))

    S.sort()
    memo = [-1]*(N+M)
    def dfs(i):
        if memo[i] != -1:
            return memo[i]
        hi, ri = S[i]
        r = 0
        for j in range(i+1, N+M):
            hj, rj = S[j]
            if hi < hj and ri < rj:
                r = max(r, dfs(j))
        memo[i] = r+1
        return r+1
    print(dfs(0))
```